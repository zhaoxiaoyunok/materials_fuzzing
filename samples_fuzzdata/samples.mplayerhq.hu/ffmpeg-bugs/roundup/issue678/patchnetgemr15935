Only in .: 0
Only in .: a.out
Only in .: audiodump.wav
Only in .: bz2lib.c
Only in .: bz2lib.s
Only in .: ceconf
Only in .: Changelog.orig
Only in .: Changelog.rej
Only in .: cmdutils.d
Only in .: cmdutils.o
Only in .: config.err
Only in .: config.h
Only in .: config.mak
diff -ruwp ./configure ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//configure
--- ./configure	2009-02-21 10:55:35.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//configure	2009-01-08 09:00:00.000000000 +0100
@@ -108,6 +108,8 @@ show_help(){
   echo "  --enable-libtheora       enable Theora encoding via libtheora [no]"
   echo "  --enable-libvorbis       enable Vorbis encoding via libvorbis,"
   echo "                           native implementation exists [no]"
+  echo "  --enable-libtremor       enable Vorbis decoding via libTremor,"
+  echo "                           native implementation exists [no]"
   echo "  --enable-libx264         enable H.264 encoding via x264 [no]"
   echo "  --enable-libxvid         enable Xvid encoding via xvidcore,"
   echo "                           native MPEG-4/Xvid encoder exists [no]"
@@ -150,6 +152,7 @@ show_help(){
   echo "  --disable-ipv6           disable IPv6 support [no]"
   echo "  --disable-mpegaudio-hp   faster (but less accurate)"
   echo "                           MPEG audio decoding [no]"
+  echo "  --enable-asfcrypt        enable ASF decryption code"
   echo "  --disable-fft            disable FFT code"
   echo "  --disable-golomb         disable Golomb code"
   echo "  --disable-mdct           disable MDCT code"
@@ -729,6 +732,7 @@ COMPONENT_LIST="
 
 CONFIG_LIST="
     $COMPONENT_LIST
+    asfcrypt
     avfilter
     avfilter_lavf
     avisynth
@@ -758,6 +762,7 @@ CONFIG_LIST="
     libspeex
     libtheora
     libvorbis
+    libtremor
     libx264
     libxvid
     mdct
@@ -1011,6 +1016,7 @@ libschroedinger_encoder_deps="libschroed
 libspeex_decoder_deps="libspeex"
 libtheora_encoder_deps="libtheora"
 libvorbis_encoder_deps="libvorbis"
+libtremor_decoder_deps="libtremor"
 libx264_encoder_deps="libx264"
 libxvid_encoder_deps="libxvid"
 mpeg4aac_decoder_deps="libfaad"
@@ -1107,7 +1113,7 @@ enable stripping
 vhook="default"
 
 # build settings
-add_cflags -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112
+#add_cflags -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112
 SHFLAGS='-shared -Wl,-soname,$$(@F)'
 VHOOKSHFLAGS='$(SHFLAGS)'
 FFSERVERLDFLAGS=-Wl,-E
@@ -1270,7 +1276,7 @@ TMPO="${TMPDIR1}/ffmpeg-conf-${RANDOM}-$
 TMPS="${TMPDIR1}/ffmpeg-conf-${RANDOM}-$$-${RANDOM}.S"
 TMPSH="${TMPDIR1}/ffmpeg-conf-${RANDOM}-$$-${RANDOM}.sh"
 
-check_cflags -std=c99
+#check_cflags -std=c99
 
 case "$arch" in
     i386|i486|i586|i686|i86pc|BePC)
@@ -1850,7 +1856,7 @@ done
 
 # these are off by default, so fail if requested and not available
 enabled avisynth   && require2 vfw32 "windows.h vfw.h" AVIFileInit -lvfw32
-enabled libamr_nb  && require  libamrnb amrnb/interf_dec.h Speech_Decode_Frame_init -lamrnb -lm
+enabled libamr_nb  && require  libamrnb amrnb/sp_dec.h Speech_Decode_Frame_init -lamrnb -lm
 enabled libamr_wb  && require  libamrwb amrwb/dec_if.h D_IF_init -lamrwb -lm
 enabled libdirac   && add_cflags $(pkg-config --cflags dirac) &&
                       require  libdirac libdirac_decoder/dirac_parser.h dirac_decoder_init -ldirac_decoder &&
@@ -1865,6 +1871,7 @@ enabled libschroedinger && add_cflags $(
 enabled libspeex   && require  libspeex speex/speex.h speex_decoder_init -lspeex
 enabled libtheora  && require  libtheora theora/theora.h theora_info_init -ltheora -logg
 enabled libvorbis  && require  libvorbis vorbis/vorbisenc.h vorbis_info_init -lvorbisenc -lvorbis -logg
+enabled libtremor  && require  libtremor Tremor/ivorbiscodec.h vorbis_info_init -lTremor -ltinyc
 enabled libx264    && require  libx264 x264.h x264_encoder_open -lx264 -lm &&
                       { check_cpp_condition x264.h "X264_BUILD >= 65" ||
                         die "ERROR: libx264 version must be >= 0.65."; }
@@ -1998,14 +2005,14 @@ enabled debug && add_cflags -g"$debuglev
 
 # add some useful compiler flags if supported
 check_cflags -Wdeclaration-after-statement
-check_cflags -Wall
+#check_cflags -Wall
 check_cflags -Wno-switch
 check_cflags -Wdisabled-optimization
 check_cflags -Wpointer-arith
-check_cflags -Wredundant-decls
+#check_cflags -Wredundant-decls
 check_cflags -Wno-pointer-sign
-check_cflags -Wcast-qual
-check_cflags -Wwrite-strings
+#check_cflags -Wcast-qual
+#check_cflags -Wwrite-strings
 check_cflags -Wtype-limits
 enabled extra_warnings && check_cflags -Winline
 
@@ -2022,8 +2029,8 @@ elif enabled optimizations; then
     if $cc -v 2>&1 | grep -q xlc; then
         add_cflags  "-O5"
         add_ldflags "-O5"
-    else
-        add_cflags "-O3"
+#    else
+#         add_cflags "-O3"
     fi
 fi
 check_cflags -fno-math-errno
@@ -2098,6 +2105,7 @@ enabled libdc1394 && append pkg_requires
 enabled libdirac  && append pkg_requires "dirac"
 enabled libtheora && append pkg_requires "theora"
 enabled libvorbis && append pkg_requires "vorbisenc"
+enabled libtremor && append pkg_requires "Tremor"
 
 echo "install prefix            $prefix"
 echo "source path               $source_path"
@@ -2173,6 +2181,7 @@ echo "libschroedinger enabled   ${libsch
 echo "libspeex enabled          ${libspeex-no}"
 echo "libtheora enabled         ${libtheora-no}"
 echo "libvorbis enabled         ${libvorbis-no}"
+echo "libtremor enabled         ${libtremor-no}"
 echo "libx264 enabled           ${libx264-no}"
 echo "libxvid enabled           ${libxvid-no}"
 echo "zlib enabled              ${zlib-no}"
Only in .: configure.orig
Only in .: configure.rej
Only in ./doc: .svn
Only in .: ebp.c
Only in .: ebp.s
Only in .: ffmpeg
Only in .: ffmpeg.d
Only in .: ffmpeg_g
Only in .: ffmpeg.o
Only in .: ffplay
Only in .: ffplay.d
Only in .: ffplay_g
Only in .: ffplay.o
Only in ./ffpresets: .svn
Only in .: ffserver
Only in .: ffserver.d
Only in .: ffserver_g
Only in .: ffserver.o
Only in ./libavcodec: 4xm.d
Only in ./libavcodec: 4xm.o
Only in ./libavcodec: 8bps.d
Only in ./libavcodec: 8bps.o
diff -ruwp ./libavcodec/8svx.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/8svx.c
--- ./libavcodec/8svx.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/8svx.c	2009-01-08 09:00:00.000000000 +0100
@@ -95,7 +95,7 @@ AVCodec eightsvx_fib_decoder = {
   .type           = CODEC_TYPE_AUDIO,
   .id             = CODEC_ID_8SVX_FIB,
   .priv_data_size = sizeof (EightSvxContext),
-  .init           = eightsvx_decode_init,
+  .codec_init     = eightsvx_decode_init,
   .decode         = eightsvx_decode_frame,
   .long_name      = NULL_IF_CONFIG_SMALL("8SVX fibonacci"),
 };
@@ -105,7 +105,7 @@ AVCodec eightsvx_exp_decoder = {
   .type           = CODEC_TYPE_AUDIO,
   .id             = CODEC_ID_8SVX_EXP,
   .priv_data_size = sizeof (EightSvxContext),
-  .init           = eightsvx_decode_init,
+  .codec_init     = eightsvx_decode_init,
   .decode         = eightsvx_decode_frame,
   .long_name      = NULL_IF_CONFIG_SMALL("8SVX exponential"),
 };
Only in ./libavcodec: 8svx.d
Only in ./libavcodec: 8svx.o
diff -ruwp ./libavcodec/aac_ac3_parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_ac3_parser.c
--- ./libavcodec/aac_ac3_parser.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_ac3_parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -88,3 +88,13 @@ get_next:
 
     return i;
 }
+
+/* Netgem: memory leak */
+av_cold void ff_aac_ac3_parse_close(AVCodecParserContext *s1)
+{
+    AACAC3ParseContext *s = s1->priv_data;
+    ParseContext *pc = &s->pc;
+
+    ff_parse_context_close(pc);
+}
+/* End Netgem */
Only in ./libavcodec: aac_ac3_parser.d
diff -ruwp ./libavcodec/aac_ac3_parser.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_ac3_parser.h
--- ./libavcodec/aac_ac3_parser.h	2009-02-21 10:47:57.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_ac3_parser.h	2009-01-08 09:00:00.000000000 +0100
@@ -50,4 +50,6 @@ int ff_aac_ac3_parse(AVCodecParserContex
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size);
 
+av_cold void ff_aac_ac3_parse_close(AVCodecParserContext *s1);/* Netgem: memory leak */
+
 #endif /* AVCODEC_AAC_AC3_PARSER_H */
Only in ./libavcodec: aac_ac3_parser.o
Only in ./libavcodec: aac.d
Only in ./libavcodec: aac.o
diff -ruwp ./libavcodec/aac_parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_parser.c
--- ./libavcodec/aac_parser.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/aac_parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -88,5 +88,5 @@ AVCodecParser aac_parser = {
     sizeof(AACAC3ParseContext),
     aac_parse_init,
     ff_aac_ac3_parse,
-    NULL,
+    ff_aac_ac3_parse_close,/* Netgem: memory leak */
 };
Only in ./libavcodec: aac_parser.d
Only in ./libavcodec: aac_parser.o
Only in ./libavcodec: aactab.d
Only in ./libavcodec: aactab.o
Only in ./libavcodec: aandcttab.d
Only in ./libavcodec: aandcttab.o
Only in ./libavcodec: aasc.d
Only in ./libavcodec: aasc.o
Only in ./libavcodec: ac3.d
Only in ./libavcodec: ac3dec.d
Only in ./libavcodec: ac3dec_data.d
Only in ./libavcodec: ac3dec_data.o
Only in ./libavcodec: ac3dec.o
Only in ./libavcodec: ac3enc.d
Only in ./libavcodec: ac3enc.o
Only in ./libavcodec: ac3.o
diff -ruwp ./libavcodec/ac3_parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/ac3_parser.c
--- ./libavcodec/ac3_parser.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/ac3_parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -192,5 +192,5 @@ AVCodecParser ac3_parser = {
     sizeof(AACAC3ParseContext),
     ac3_parse_init,
     ff_aac_ac3_parse,
-    ff_parse_close,
+    ff_aac_ac3_parse_close,/* Netgem: memory leak */
 };
Only in ./libavcodec: ac3_parser.d
Only in ./libavcodec: ac3_parser.o
Only in ./libavcodec: ac3tab.d
Only in ./libavcodec: ac3tab.o
Only in ./libavcodec: adpcm.d
Only in ./libavcodec: adpcm.o
Only in ./libavcodec: adxdec.d
Only in ./libavcodec: adxdec.o
Only in ./libavcodec: adxenc.d
Only in ./libavcodec: adxenc.o
Only in ./libavcodec: alac.d
Only in ./libavcodec: alacenc.d
Only in ./libavcodec: alacenc.o
Only in ./libavcodec: alac.o
diff -ruwp ./libavcodec/allcodecs.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/allcodecs.c
--- ./libavcodec/allcodecs.c	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/allcodecs.c	2009-01-08 09:00:00.000000000 +0100
@@ -297,6 +297,7 @@ void avcodec_register_all(void)
     REGISTER_DECODER (LIBSPEEX, libspeex);
     REGISTER_ENCODER (LIBTHEORA, libtheora);
     REGISTER_ENCODER (LIBVORBIS, libvorbis);
+    REGISTER_DECODER (LIBTREMOR, libtremor); /* Netgem */
     REGISTER_ENCODER (LIBX264, libx264);
     REGISTER_ENCODER (LIBXVID, libxvid);
 
Only in ./libavcodec: allcodecs.c.orig
Only in ./libavcodec: allcodecs.d
Only in ./libavcodec: allcodecs.o
Only in ./libavcodec/alpha: .svn
Only in ./libavcodec: apedec.d
Only in ./libavcodec: apedec.o
Only in ./libavcodec/armv4l: .svn
diff -ruwp ./libavcodec/asv1.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/asv1.c
--- ./libavcodec/asv1.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/asv1.c	2009-01-08 09:00:00.000000000 +0100
@@ -605,6 +605,7 @@ static av_cold int decode_end(AVCodecCon
     return 0;
 }
 
+#ifdef CONFIG_ASV1_DECODER
 AVCodec asv1_decoder = {
     "asv1",
     CODEC_TYPE_VIDEO,
@@ -617,7 +618,9 @@ AVCodec asv1_decoder = {
     CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("ASUS V1"),
 };
+#endif
 
+#ifdef CONFIG_ASV2_DECODER
 AVCodec asv2_decoder = {
     "asv2",
     CODEC_TYPE_VIDEO,
@@ -630,6 +633,7 @@ AVCodec asv2_decoder = {
     CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("ASUS V2"),
 };
+#endif
 
 #ifdef CONFIG_ASV1_ENCODER
 AVCodec asv1_encoder = {
Only in ./libavcodec: asv1.d
Only in ./libavcodec: asv1.o
diff -ruwp ./libavcodec/atrac3.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/atrac3.c
--- ./libavcodec/atrac3.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/atrac3.c	2009-01-08 09:00:00.000000000 +0100
@@ -1073,8 +1073,8 @@ AVCodec atrac3_decoder =
     .type = CODEC_TYPE_AUDIO,
     .id = CODEC_ID_ATRAC3,
     .priv_data_size = sizeof(ATRAC3Context),
-    .init = atrac3_decode_init,
-    .close = atrac3_decode_close,
+    .codec_init = atrac3_decode_init,
+    .codec_close = atrac3_decode_close,
     .decode = atrac3_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("Atrac 3 (Adaptive TRansform Acoustic Coding 3)"),
 };
Only in ./libavcodec: atrac3.d
Only in ./libavcodec: atrac3.o
diff -ruwp ./libavcodec/audioconvert.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/audioconvert.c
--- ./libavcodec/audioconvert.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/audioconvert.c	2009-01-08 09:00:00.000000000 +0100
@@ -187,7 +187,7 @@ int av_audio_convert(AVAudioConvert *ctx
     for(ch=0; ch<ctx->out_channels; ch++){
         const int is=  in_stride[ch];
         const int os= out_stride[ch];
-        uint8_t *pi=  in[ch];
+        const uint8_t *pi=  in[ch];
         uint8_t *po= out[ch];
         uint8_t *end= po + os*len;
         if(!out[ch])
Only in ./libavcodec: audioconvert.d
Only in ./libavcodec: audioconvert.o
diff -ruwp ./libavcodec/avcodec.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/avcodec.h
--- ./libavcodec/avcodec.h	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/avcodec.h	2009-01-08 09:00:00.000000000 +0100
@@ -2283,6 +2283,14 @@ typedef struct AVCodecContext {
      * - decoding: Set by user.
      */
     int64_t request_channel_layout;
+
+    /**
+     * Netgem: Divx use packed bitstream
+     * - encoding: unused
+     * - decoding: Set by libavcodec.
+     */
+    int divx_packed;
+
 } AVCodecContext;
 
 /**
@@ -2299,9 +2307,9 @@ typedef struct AVCodec {
     enum CodecType type;
     enum CodecID id;
     int priv_data_size;
-    int (*init)(AVCodecContext *);
+    int (*codec_init)(AVCodecContext *);
     int (*encode)(AVCodecContext *, uint8_t *buf, int buf_size, void *data);
-    int (*close)(AVCodecContext *);
+    int (*codec_close)(AVCodecContext *);
     int (*decode)(AVCodecContext *, void *outdata, int *outdata_size,
                   const uint8_t *buf, int buf_size);
     /**
@@ -2916,7 +2924,8 @@ typedef struct AVBitStreamFilter {
                   AVCodecContext *avctx, const char *args,
                   uint8_t **poutbuf, int *poutbuf_size,
                   const uint8_t *buf, int buf_size, int keyframe);
-    void (*close)(AVBitStreamFilterContext *bsfc);
+    void (*filter_close)(AVBitStreamFilterContext *bsfc);
+    void (*filter_reset)(AVBitStreamFilterContext *bsfc); /* Netgem */
     struct AVBitStreamFilter *next;
 } AVBitStreamFilter;
 
@@ -2926,6 +2935,7 @@ int av_bitstream_filter_filter(AVBitStre
                                AVCodecContext *avctx, const char *args,
                                uint8_t **poutbuf, int *poutbuf_size,
                                const uint8_t *buf, int buf_size, int keyframe);
+void av_bitstream_filter_reset(AVBitStreamFilterContext *bsf);
 void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
 
 AVBitStreamFilter *av_bitstream_filter_next(AVBitStreamFilter *f);
Only in ./libavcodec: avcodec.h.orig
Only in ./libavcodec: avcodec.h.rej
Only in ./libavcodec: avs.d
Only in ./libavcodec: avs.o
diff -ruwp ./libavcodec/bethsoftvideo.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bethsoftvideo.c
--- ./libavcodec/bethsoftvideo.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bethsoftvideo.c	2009-01-08 09:00:00.000000000 +0100
@@ -133,8 +133,8 @@ AVCodec bethsoftvid_decoder = {
     .type = CODEC_TYPE_VIDEO,
     .id = CODEC_ID_BETHSOFTVID,
     .priv_data_size = sizeof(BethsoftvidContext),
-    .init = bethsoftvid_decode_init,
-    .close = bethsoftvid_decode_end,
+    .codec_init = bethsoftvid_decode_init,
+    .codec_close = bethsoftvid_decode_end,
     .decode = bethsoftvid_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("Bethesda VID video"),
 };
Only in ./libavcodec: bethsoftvideo.d
Only in ./libavcodec: bethsoftvideo.o
diff -ruwp ./libavcodec/bfi.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bfi.c
--- ./libavcodec/bfi.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bfi.c	2009-01-08 09:00:00.000000000 +0100
@@ -175,8 +175,8 @@ AVCodec bfi_decoder = {
     .type = CODEC_TYPE_VIDEO,
     .id = CODEC_ID_BFI,
     .priv_data_size = sizeof(BFIContext),
-    .init = bfi_decode_init,
-    .close = bfi_decode_close,
+    .codec_init = bfi_decode_init,
+    .codec_close = bfi_decode_close,
     .decode = bfi_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("Brute Force & Ignorance"),
 };
Only in ./libavcodec: bfi.d
Only in ./libavcodec/bfin: .svn
Only in ./libavcodec: bfi.o
Only in ./libavcodec: bitstream.d
diff -ruwp ./libavcodec/bitstream_filter.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bitstream_filter.c
--- ./libavcodec/bitstream_filter.c	2008-12-18 22:24:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bitstream_filter.c	2009-01-08 09:00:00.000000000 +0100
@@ -48,9 +48,10 @@ AVBitStreamFilterContext *av_bitstream_f
 }
 
 void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc){
-    if(bsfc->filter->close)
-        bsfc->filter->close(bsfc);
+    if(bsfc->filter->filter_close)
+        bsfc->filter->filter_close(bsfc);
     av_freep(&bsfc->priv_data);
+    if (bsfc->parser) /* Netgem: some filters do not use parsers */
     av_parser_close(bsfc->parser);
     av_free(bsfc);
 }
@@ -63,3 +64,10 @@ int av_bitstream_filter_filter(AVBitStre
     *poutbuf_size= buf_size;
     return bsfc->filter->filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size, keyframe);
 }
+
+/* Netgem */
+void av_bitstream_filter_reset(AVBitStreamFilterContext *bsfc){
+    if(bsfc->filter->filter_reset)
+        bsfc->filter->filter_reset(bsfc);
+}
+/* End Netgem */
Only in ./libavcodec: bitstream_filter.d
Only in ./libavcodec: bitstream_filter.o
diff -ruwp ./libavcodec/bitstream.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bitstream.h
--- ./libavcodec/bitstream.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/bitstream.h	2009-01-08 09:00:00.000000000 +0100
@@ -34,6 +34,17 @@
 #include "libavutil/intreadwrite.h"
 #include "libavutil/log.h"
 
+/* Netgem compatibility */
+#ifndef __intptr_t_defined
+typedef int                     intptr_t;
+#  define __intptr_t_defined
+#endif
+#ifndef __uintptr_t_defined
+typedef unsigned int            uintptr_t;
+#  define __uintptr_t_defined
+#endif
+/* end Netgem */
+
 #if defined(ALT_BITSTREAM_READER_LE) && !defined(ALT_BITSTREAM_READER)
 #   define ALT_BITSTREAM_READER
 #endif
Only in ./libavcodec: bitstream.o
Only in ./libavcodec: bmp.d
Only in ./libavcodec: bmpenc.d
Only in ./libavcodec: bmpenc.o
Only in ./libavcodec: bmp.o
Only in ./libavcodec: c93.d
Only in ./libavcodec: c93.o
Only in ./libavcodec: cabac.d
diff -ruwp ./libavcodec/cabac.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/cabac.h
--- ./libavcodec/cabac.h	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/cabac.h	2009-01-08 09:00:00.000000000 +0100
@@ -51,6 +51,8 @@ typedef struct CABACContext{
     PutBitContext pb;
 }CABACContext;
 
+#ifndef DO_NOT_USE_AVCODEC_CABAC_FUNCTIONS /* Netgem */
+
 extern uint8_t ff_h264_mlps_state[4*64];
 extern uint8_t ff_h264_lps_range[4*2*64];  ///< rangeTabLPS
 extern uint8_t ff_h264_mps_state[2*64];     ///< transIdxMPS
@@ -755,4 +757,6 @@ static int get_cabac_ueg(CABACContext *c
 }
 #endif /* 0 */
 
+#endif /* End Netgem: DO_NOT_USE_AVCODEC_CABAC_FUNCTIONS */
+
 #endif /* AVCODEC_CABAC_H */
Only in ./libavcodec: cabac.o
Only in ./libavcodec: cavs.d
Only in ./libavcodec: cavsdec.d
Only in ./libavcodec: cavsdec.o
Only in ./libavcodec: cavsdsp.d
Only in ./libavcodec: cavsdsp.o
Only in ./libavcodec: cavs.o
Only in ./libavcodec: cavs_parser.d
Only in ./libavcodec: cavs_parser.o
Only in ./libavcodec: celp_filters.d
Only in ./libavcodec: celp_filters.o
Only in ./libavcodec: celp_math.d
Only in ./libavcodec: celp_math.o
Only in ./libavcodec: cinepak.d
Only in ./libavcodec: cinepak.o
Only in ./libavcodec: cljr.d
Only in ./libavcodec: cljr.o
diff -ruwp ./libavcodec/cook.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/cook.c
--- ./libavcodec/cook.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/cook.c	2009-01-08 09:00:00.000000000 +0100
@@ -1192,8 +1192,8 @@ AVCodec cook_decoder =
     .type = CODEC_TYPE_AUDIO,
     .id = CODEC_ID_COOK,
     .priv_data_size = sizeof(COOKContext),
-    .init = cook_decode_init,
-    .close = cook_decode_close,
+    .codec_init = cook_decode_init,
+    .codec_close = cook_decode_close,
     .decode = cook_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("COOK"),
 };
Only in ./libavcodec: cook.d
Only in ./libavcodec: cook.o
Only in ./libavcodec: cscd.d
Only in ./libavcodec: cscd.o
Only in ./libavcodec: cyuv.d
Only in ./libavcodec: cyuv.o
diff -ruwp ./libavcodec/dca.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dca.c
--- ./libavcodec/dca.c	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dca.c	2009-01-08 09:00:00.000000000 +0100
@@ -1328,7 +1328,7 @@ AVCodec dca_decoder = {
     .type = CODEC_TYPE_AUDIO,
     .id = CODEC_ID_DTS,
     .priv_data_size = sizeof(DCAContext),
-    .init = dca_decode_init,
+    .codec_init = dca_decode_init,
     .decode = dca_decode_frame,
     .close = dca_decode_end,
     .long_name = NULL_IF_CONFIG_SMALL("DCA (DTS Coherent Acoustics)"),
Only in ./libavcodec: dca.d
Only in ./libavcodec: dca.o
Only in ./libavcodec: dca_parser.d
Only in ./libavcodec: dca_parser.o
Only in ./libavcodec: dirac_parser.d
Only in ./libavcodec: dirac_parser.o
Only in ./libavcodec: dnxhddata.d
Only in ./libavcodec: dnxhddata.o
Only in ./libavcodec: dnxhddec.d
Only in ./libavcodec: dnxhddec.o
Only in ./libavcodec: dnxhdenc.d
Only in ./libavcodec: dnxhdenc.o
Only in ./libavcodec: dnxhd_parser.d
Only in ./libavcodec: dnxhd_parser.o
Only in ./libavcodec: dpcm.d
Only in ./libavcodec: dpcm.o
Only in ./libavcodec: dsicinav.d
Only in ./libavcodec: dsicinav.o
diff -ruwp ./libavcodec/dsputil.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dsputil.c
--- ./libavcodec/dsputil.c	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dsputil.c	2009-01-08 09:00:00.000000000 +0100
@@ -4376,6 +4376,7 @@ void dsputil_init(DSPContext* c, AVCodec
     c->avg_h264_chroma_pixels_tab[2]= avg_h264_chroma_mc2_c;
     c->put_no_rnd_h264_chroma_pixels_tab[0]= put_no_rnd_h264_chroma_mc8_c;
 
+    if (ENABLE_H264_DECODER || ENABLE_SVQ3_DECODER) { /* Netgem */
     c->weight_h264_pixels_tab[0]= weight_h264_pixels16x16_c;
     c->weight_h264_pixels_tab[1]= weight_h264_pixels16x8_c;
     c->weight_h264_pixels_tab[2]= weight_h264_pixels8x16_c;
@@ -4396,6 +4397,7 @@ void dsputil_init(DSPContext* c, AVCodec
     c->biweight_h264_pixels_tab[7]= biweight_h264_pixels4x2_c;
     c->biweight_h264_pixels_tab[8]= biweight_h264_pixels2x4_c;
     c->biweight_h264_pixels_tab[9]= biweight_h264_pixels2x2_c;
+    } /* Netgem */
 
     c->draw_edges = draw_edges_c;
 
@@ -4464,6 +4466,7 @@ void dsputil_init(DSPContext* c, AVCodec
     c->add_png_paeth_prediction= ff_add_png_paeth_prediction;
 #endif
 
+    if (ENABLE_H264_DECODER || ENABLE_SVQ3_DECODER) { /* Netgem */
     c->h264_v_loop_filter_luma= h264_v_loop_filter_luma_c;
     c->h264_h_loop_filter_luma= h264_h_loop_filter_luma_c;
     c->h264_v_loop_filter_chroma= h264_v_loop_filter_chroma_c;
@@ -4471,6 +4474,7 @@ void dsputil_init(DSPContext* c, AVCodec
     c->h264_v_loop_filter_chroma_intra= h264_v_loop_filter_chroma_intra_c;
     c->h264_h_loop_filter_chroma_intra= h264_h_loop_filter_chroma_intra_c;
     c->h264_loop_filter_strength= NULL;
+    } /* Netgem */
 
     if (ENABLE_ANY_H263) {
         c->h263_h_loop_filter= h263_h_loop_filter_c;
Only in ./libavcodec: dsputil.d
Only in ./libavcodec: dsputil.o
Only in ./libavcodec: dump_extradata_bsf.d
Only in ./libavcodec: dump_extradata_bsf.o
Only in ./libavcodec: dvbsub.d
diff -ruwp ./libavcodec/dvbsubdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dvbsubdec.c
--- ./libavcodec/dvbsubdec.c	2009-02-21 10:47:57.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/dvbsubdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -439,12 +439,13 @@ static int dvbsub_read_2bit_string(uint8
     int run_length;
     int pixels_read = 0;
 
-    init_get_bits(&gb, *srcbuf, buf_size << 8);
+    init_get_bits(&gb, *srcbuf, buf_size << 3);
 
-    while (get_bits_count(&gb) < (buf_size << 8) && pixels_read < dbuf_len) {
+    while (get_bits_count(&gb) < (buf_size << 3)) {
         bits = get_bits(&gb, 2);
 
         if (bits) {
+            if (pixels_read < dbuf_len) {
             if (non_mod != 1 || bits != 1) {
                 if (map_table)
                     *destbuf++ = map_table[bits];
@@ -452,14 +453,17 @@ static int dvbsub_read_2bit_string(uint8
                     *destbuf++ = bits;
             }
             pixels_read++;
+            }
         } else {
             bits = get_bits1(&gb);
             if (bits == 1) {
                 run_length = get_bits(&gb, 3) + 3;
                 bits = get_bits(&gb, 2);
 
-                if (non_mod == 1 && bits == 1)
+                if (non_mod == 1 && bits == 1) {
+                    if (pixels_read < dbuf_len - run_length)
                     pixels_read += run_length;
+                }
                 else {
                     if (map_table)
                         bits = map_table[bits];
@@ -476,8 +480,10 @@ static int dvbsub_read_2bit_string(uint8
                         run_length = get_bits(&gb, 4) + 12;
                         bits = get_bits(&gb, 2);
 
-                        if (non_mod == 1 && bits == 1)
+                        if (non_mod == 1 && bits == 1) {
+                            if (pixels_read < dbuf_len - run_length)
                             pixels_read += run_length;
+                        }
                         else {
                             if (map_table)
                                 bits = map_table[bits];
@@ -490,8 +496,10 @@ static int dvbsub_read_2bit_string(uint8
                         run_length = get_bits(&gb, 8) + 29;
                         bits = get_bits(&gb, 2);
 
-                        if (non_mod == 1 && bits == 1)
+                        if (non_mod == 1 && bits == 1) {
+                            if (pixels_read < dbuf_len - run_length)
                             pixels_read += run_length;
+                        }
                         else {
                             if (map_table)
                                 bits = map_table[bits];
@@ -501,36 +509,33 @@ static int dvbsub_read_2bit_string(uint8
                             }
                         }
                     } else if (bits == 1) {
-                        pixels_read += 2;
                         if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
-                        if (pixels_read <= dbuf_len) {
+                        if (pixels_read < dbuf_len - 1) {
                             *destbuf++ = bits;
                             *destbuf++ = bits;
+                            pixels_read += 2;
                         }
                     } else {
-                        (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
-                        return pixels_read;
+                        break;
                     }
                 } else {
                     if (map_table)
                         bits = map_table[0];
                     else
                         bits = 0;
+                    if (pixels_read < dbuf_len) {
                     *destbuf++ = bits;
                     pixels_read++;
                 }
             }
         }
     }
-
-    if (get_bits(&gb, 6))
-        av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
+    }
 
     (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
-
     return pixels_read;
 }
 
@@ -544,12 +549,13 @@ static int dvbsub_read_4bit_string(uint8
     int run_length;
     int pixels_read = 0;
 
-    init_get_bits(&gb, *srcbuf, buf_size << 8);
+    init_get_bits(&gb, *srcbuf, buf_size << 3);
 
-    while (get_bits_count(&gb) < (buf_size << 8) && pixels_read < dbuf_len) {
+    while (get_bits_count(&gb) < (buf_size << 3)) {
         bits = get_bits(&gb, 4);
 
         if (bits) {
+            if (pixels_read < dbuf_len) {
             if (non_mod != 1 || bits != 1) {
                 if (map_table)
                     *destbuf++ = map_table[bits];
@@ -557,14 +563,14 @@ static int dvbsub_read_4bit_string(uint8
                     *destbuf++ = bits;
             }
             pixels_read++;
+            }
         } else {
             bits = get_bits1(&gb);
             if (bits == 0) {
                 run_length = get_bits(&gb, 3);
 
                 if (run_length == 0) {
-                    (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
-                    return pixels_read;
+                    break;
                 }
 
                 run_length += 2;
@@ -584,8 +590,10 @@ static int dvbsub_read_4bit_string(uint8
                     run_length = get_bits(&gb, 2) + 4;
                     bits = get_bits(&gb, 4);
 
-                    if (non_mod == 1 && bits == 1)
+                    if (non_mod == 1 && bits == 1) {
+                        if (pixels_read < dbuf_len - run_length)
                         pixels_read += run_length;
+                    }
                     else {
                         if (map_table)
                             bits = map_table[bits];
@@ -600,8 +608,10 @@ static int dvbsub_read_4bit_string(uint8
                         run_length = get_bits(&gb, 4) + 9;
                         bits = get_bits(&gb, 4);
 
-                        if (non_mod == 1 && bits == 1)
+                        if (non_mod == 1 && bits == 1) {
+                            if (pixels_read < dbuf_len - run_length)
                             pixels_read += run_length;
+                        }
                         else {
                             if (map_table)
                                 bits = map_table[bits];
@@ -614,8 +624,10 @@ static int dvbsub_read_4bit_string(uint8
                         run_length = get_bits(&gb, 8) + 25;
                         bits = get_bits(&gb, 4);
 
-                        if (non_mod == 1 && bits == 1)
+                        if (non_mod == 1 && bits == 1) {
+                            if (pixels_read < dbuf_len - run_length)
                             pixels_read += run_length;
+                        }
                         else {
                             if (map_table)
                                 bits = map_table[bits];
@@ -625,20 +637,21 @@ static int dvbsub_read_4bit_string(uint8
                             }
                         }
                     } else if (bits == 1) {
-                        pixels_read += 2;
                         if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
-                        if (pixels_read <= dbuf_len) {
+                        if (pixels_read < dbuf_len - 1) {
                             *destbuf++ = bits;
                             *destbuf++ = bits;
+                            pixels_read += 2;
                         }
                     } else {
                         if (map_table)
                             bits = map_table[0];
                         else
                             bits = 0;
+                        if (pixels_read < dbuf_len) {
                         *destbuf++ = bits;
                         pixels_read ++;
                     }
@@ -646,12 +659,9 @@ static int dvbsub_read_4bit_string(uint8
             }
         }
     }
-
-    if (get_bits(&gb, 8))
-        av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
+    }
 
     (*srcbuf) += (get_bits_count(&gb) + 7) >> 3;
-
     return pixels_read;
 }
 
@@ -664,10 +674,11 @@ static int dvbsub_read_8bit_string(uint8
     int run_length;
     int pixels_read = 0;
 
-    while (*srcbuf < sbuf_end && pixels_read < dbuf_len) {
+    while (*srcbuf < sbuf_end) {
         bits = *(*srcbuf)++;
 
         if (bits) {
+            if (pixels_read < dbuf_len) {
             if (non_mod != 1 || bits != 1) {
                 if (map_table)
                     *destbuf++ = map_table[bits];
@@ -675,12 +686,13 @@ static int dvbsub_read_8bit_string(uint8
                     *destbuf++ = bits;
             }
             pixels_read++;
+            }
         } else {
             bits = *(*srcbuf)++;
             run_length = bits & 0x7f;
             if ((bits & 0x80) == 0) {
                 if (run_length == 0) {
-                    return pixels_read;
+                    break;
                 }
 
                 if (map_table)
@@ -694,20 +706,21 @@ static int dvbsub_read_8bit_string(uint8
             } else {
                 bits = *(*srcbuf)++;
 
-                if (non_mod == 1 && bits == 1)
+                if (non_mod == 1 && bits == 1) {
+                    if (pixels_read < dbuf_len - run_length);
                     pixels_read += run_length;
+                }
+                else {
                 if (map_table)
                     bits = map_table[bits];
-                else while (run_length-- > 0 && pixels_read < dbuf_len) {
+                    while (run_length-- > 0 && pixels_read < dbuf_len) {
                     *destbuf++ = bits;
                     pixels_read++;
                 }
             }
         }
     }
-
-    if (*(*srcbuf)++)
-        av_log(0, AV_LOG_ERROR, "DVBSub error: line overflow\n");
+    }
 
     return pixels_read;
 }
@@ -1035,8 +1048,11 @@ static void dvbsub_parse_region_segment(
     }
     region->clut = *buf++;
 
-    if (region->depth == 8)
+    if (region->depth == 8) {
         region->bgcolor = *buf++;
+
+        buf += 1;
+    }
     else {
         buf += 1;
 
@@ -1312,9 +1328,11 @@ static int dvbsub_display_end_segment(AV
         switch (region->depth) {
         case 2:
             clut_table = clut->clut4;
+            rect->nb_colors = 4;
             break;
         case 8:
             clut_table = clut->clut256;
+            rect->nb_colors = 256;
             break;
         case 4:
         default:
Only in ./libavcodec: dvbsubdec.d
Only in ./libavcodec: dvbsubdec.o
Only in ./libavcodec: dvbsub.o
Only in ./libavcodec: dvbsub_parser.d
Only in ./libavcodec: dvbsub_parser.o
Only in ./libavcodec: dv.d
Only in ./libavcodec: dvdsubdec.d
Only in ./libavcodec: dvdsubdec.o
Only in ./libavcodec: dvdsubenc.d
Only in ./libavcodec: dvdsubenc.o
Only in ./libavcodec: dvdsub_parser.d
Only in ./libavcodec: dvdsub_parser.o
Only in ./libavcodec: dv.o
Only in ./libavcodec: dxa.d
Only in ./libavcodec: dxa.o
Only in ./libavcodec: eac3dec.d
Only in ./libavcodec: eac3dec.o
Only in ./libavcodec: eacmv.d
Only in ./libavcodec: eacmv.o
Only in ./libavcodec: eaidct.d
Only in ./libavcodec: eaidct.o
Only in ./libavcodec: eatgq.d
Only in ./libavcodec: eatgq.o
Only in ./libavcodec: eatgv.d
Only in ./libavcodec: eatgv.o
Only in ./libavcodec: eatqi.d
Only in ./libavcodec: eatqi.o
Only in ./libavcodec: elbg.d
Only in ./libavcodec: elbg.o
Only in ./libavcodec: error_resilience.d
Only in ./libavcodec: error_resilience.o
Only in ./libavcodec: escape124.d
Only in ./libavcodec: escape124.o
Only in ./libavcodec: eval.d
Only in ./libavcodec: eval.o
Only in ./libavcodec: faandct.d
Only in ./libavcodec: faandct.o
Only in ./libavcodec: faanidct.d
Only in ./libavcodec: faanidct.o
Only in ./libavcodec: faxcompr.d
Only in ./libavcodec: faxcompr.o
Only in ./libavcodec: fft.d
Only in ./libavcodec: fft.o
diff -ruwp ./libavcodec/ffv1.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/ffv1.c
--- ./libavcodec/ffv1.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/ffv1.c	2009-01-08 09:00:00.000000000 +0100
@@ -1011,6 +1011,7 @@ static int decode_frame(AVCodecContext *
     return bytes_read;
 }
 
+#ifdef CONFIG_FFV1_DECODER
 AVCodec ffv1_decoder = {
     "ffv1",
     CODEC_TYPE_VIDEO,
@@ -1024,6 +1025,7 @@ AVCodec ffv1_decoder = {
     NULL,
     .long_name= NULL_IF_CONFIG_SMALL("FFmpeg codec #1"),
 };
+#endif
 
 #ifdef CONFIG_FFV1_ENCODER
 AVCodec ffv1_encoder = {
Only in ./libavcodec: ffv1.d
Only in ./libavcodec: ffv1.o
Only in ./libavcodec: flacdec.d
Only in ./libavcodec: flacdec.o
Only in ./libavcodec: flacenc.d
Only in ./libavcodec: flacenc.o
Only in ./libavcodec: flashsv.d
Only in ./libavcodec: flashsvenc.d
Only in ./libavcodec: flashsvenc.o
Only in ./libavcodec: flashsv.o
Only in ./libavcodec: flicvideo.d
Only in ./libavcodec: flicvideo.o
Only in ./libavcodec: fraps.d
Only in ./libavcodec: fraps.o
diff -ruwp ./libavcodec/g726.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/g726.c
--- ./libavcodec/g726.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/g726.c	2009-01-08 09:00:00.000000000 +0100
@@ -396,6 +396,7 @@ AVCodec adpcm_g726_encoder = {
 };
 #endif
 
+#ifdef CONFIG_ADPCM_G726_DECODER
 AVCodec adpcm_g726_decoder = {
     "g726",
     CODEC_TYPE_AUDIO,
@@ -407,3 +408,4 @@ AVCodec adpcm_g726_decoder = {
     g726_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("G.726 ADPCM"),
 };
+#endif
Only in ./libavcodec: g726.d
Only in ./libavcodec: g726.o
Only in ./libavcodec: gif.d
Only in ./libavcodec: gifdec.d
Only in ./libavcodec: gifdec.o
Only in ./libavcodec: gif.o
Only in ./libavcodec: golomb.d
Only in ./libavcodec: golomb.o
Only in ./libavcodec: h261.d
Only in ./libavcodec: h261dec.d
Only in ./libavcodec: h261dec.o
Only in ./libavcodec: h261enc.d
Only in ./libavcodec: h261enc.o
Only in ./libavcodec: h261.o
Only in ./libavcodec: h261_parser.d
Only in ./libavcodec: h261_parser.o
diff -ruwp ./libavcodec/h263.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h263.c
--- ./libavcodec/h263.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h263.c	2009-01-08 09:00:00.000000000 +0100
@@ -54,7 +54,7 @@
 #define H263_MBTYPE_B_VLC_BITS 6
 #define CBPC_B_VLC_BITS 3
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 static void h263_encode_block(MpegEncContext * s, DCTELEM * block,
                               int n);
 static void h263p_encode_umotion(MpegEncContext * s, int val);
@@ -72,15 +72,15 @@ static int h263_decode_block(MpegEncCont
 static inline int mpeg4_decode_dc(MpegEncContext * s, int n, int *dir_ptr);
 static inline int mpeg4_decode_block(MpegEncContext * s, DCTELEM * block,
                               int n, int coded, int intra, int rvlc);
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 static int h263_pred_dc(MpegEncContext * s, int n, int16_t **dc_val_ptr);
 static void mpeg4_encode_visual_object_header(MpegEncContext * s);
 static void mpeg4_encode_vol_header(MpegEncContext * s, int vo_number, int vol_number);
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_ANY_H263_ENCODER
 static void mpeg4_decode_sprite_trajectory(MpegEncContext * s, GetBitContext *gb);
 static inline int ff_mpeg4_pred_dc(MpegEncContext * s, int n, int level, int *dir_ptr, int encoding);
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 static uint8_t uni_DCtab_lum_len[512];
 static uint8_t uni_DCtab_chrom_len[512];
 static uint16_t uni_DCtab_lum_bits[512];
@@ -155,7 +155,7 @@ static void show_pict_info(MpegEncContex
     );
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 
 static void aspect_to_info(MpegEncContext * s, AVRational aspect){
     int i;
@@ -585,7 +585,7 @@ void ff_clean_mpeg4_qscales(MpegEncConte
     }
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_ANY_H263_ENCODER
 
 #define tab_size ((signed)FF_ARRAY_ELEMS(s->direct_scale_mv[0]))
 #define tab_bias (tab_size/2)
@@ -736,7 +736,7 @@ void ff_h263_update_motion_val(MpegEncCo
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 
 static inline int h263_get_motion_length(MpegEncContext * s, int val, int f_code){
     int l, bit_size, code;
@@ -1549,7 +1549,7 @@ void ff_h263_loop_filter(MpegEncContext
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 static int h263_pred_dc(MpegEncContext * s, int n, int16_t **dc_val_ptr)
 {
     int x, y, wrap, a, c, pred_dc, scale;
@@ -1594,7 +1594,7 @@ static int h263_pred_dc(MpegEncContext *
     *dc_val_ptr = &dc_val[x + y * wrap];
     return pred_dc;
 }
-#endif /* CONFIG_ENCODERS */
+#endif /* ENABLE_ANY_H263_ENCODER */
 
 static void h263_pred_acdc(MpegEncContext * s, DCTELEM *block, int n)
 {
@@ -1741,7 +1741,7 @@ int16_t *h263_pred_motion(MpegEncContext
     return *mot_val;
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER || ENABLE_SVQ1_ENCODER
 void ff_h263_encode_motion(MpegEncContext * s, int val, int f_code)
 {
     int range, l, bit_size, sign, code, bits;
@@ -2511,7 +2511,7 @@ void mpeg4_encode_picture_header(MpegEnc
     //    printf("****frame %d\n", picture_number);
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_ANY_H263_ENCODER
 
 /**
  * predicts the dc.
@@ -2652,7 +2652,7 @@ void mpeg4_pred_ac(MpegEncContext * s, D
 
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 
 /**
  * encodes the dc value.
@@ -2976,6 +2976,7 @@ int ff_h263_decode_mba(MpegEncContext *s
     return mb_pos;
 }
 
+#if ENABLE_ANY_H263_ENCODER
 void ff_h263_encode_mba(MpegEncContext *s)
 {
     int i, mb_pos;
@@ -2986,6 +2987,7 @@ void ff_h263_encode_mba(MpegEncContext *
     mb_pos= s->mb_x + s->mb_width*s->mb_y;
     put_bits(&s->pb, ff_mba_length[i], mb_pos);
 }
+#endif
 
 /**
  * decodes the group of blocks header or slice header.
@@ -3049,7 +3051,7 @@ static inline void memsetw(short *tab, i
         tab[i] = val;
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 
 void ff_mpeg4_init_partitions(MpegEncContext *s)
 {
@@ -3090,7 +3092,7 @@ void ff_mpeg4_merge_partitions(MpegEncCo
     s->last_bits= put_bits_count(&s->pb);
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_ANY_H263_ENCODER
 
 int ff_mpeg4_get_video_packet_prefix_length(MpegEncContext *s){
     switch(s->pict_type){
@@ -3106,7 +3108,7 @@ int ff_mpeg4_get_video_packet_prefix_len
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_ANY_H263_ENCODER
 
 void ff_mpeg4_encode_video_packet_header(MpegEncContext *s)
 {
@@ -3120,7 +3122,7 @@ void ff_mpeg4_encode_video_packet_header
     put_bits(&s->pb, 1, 0); /* no HEC */
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_ANY_H263_ENCODER
 
 /**
  * check if the next stuff is a resync marker or the end.
@@ -5750,6 +5752,7 @@ static int decode_user_data(MpegEncConte
     if(e>=2){
         s->divx_version= ver;
         s->divx_build= build;
+        s->avctx->divx_packed= /* Netgem: export divx_packed value */
         s->divx_packed= e==3 && last=='p';
         if(s->divx_packed && !s->showed_packed_warning) {
             av_log(s->avctx, AV_LOG_WARNING, "Invalid and inefficient vfw-avi packed B frames detected\n");
Only in ./libavcodec: h263.d
diff -ruwp ./libavcodec/h263dec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h263dec.c
--- ./libavcodec/h263dec.c	2009-02-21 10:48:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h263dec.c	2009-01-08 09:00:00.000000000 +0100
@@ -712,6 +712,7 @@ av_log(avctx, AV_LOG_DEBUG, "%"PRId64"\n
     return get_consumed_bytes(s, buf_size);
 }
 
+#ifdef CONFIG_MPEG4_DECODER
 AVCodec mpeg4_decoder = {
     "mpeg4",
     CODEC_TYPE_VIDEO,
@@ -725,7 +726,9 @@ AVCodec mpeg4_decoder = {
     .flush= ff_mpeg_flush,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2"),
 };
+#endif //CONFIG_MPEG4_DECODER
 
+#ifdef CONFIG_H263_DECODER
 AVCodec h263_decoder = {
     "h263",
     CODEC_TYPE_VIDEO,
@@ -739,7 +742,9 @@ AVCodec h263_decoder = {
     .flush= ff_mpeg_flush,
     .long_name= NULL_IF_CONFIG_SMALL("H.263"),
 };
+#endif //CONFIG_H263_DECODER
 
+#ifdef CONFIG_MSMPEG4V1_DECODER
 AVCodec msmpeg4v1_decoder = {
     "msmpeg4v1",
     CODEC_TYPE_VIDEO,
@@ -752,7 +757,9 @@ AVCodec msmpeg4v1_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1"),
 };
+#endif //CONFIG_MSMPEG4V1_DECODER
 
+#ifdef CONFIG_MSMPEG4V2_DECODER
 AVCodec msmpeg4v2_decoder = {
     "msmpeg4v2",
     CODEC_TYPE_VIDEO,
@@ -765,7 +772,9 @@ AVCodec msmpeg4v2_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2"),
 };
+#endif //CONFIG_MSMPEG4V2_DECODER
 
+#ifdef CONFIG_MSMPEG4V3_DECODER
 AVCodec msmpeg4v3_decoder = {
     "msmpeg4",
     CODEC_TYPE_VIDEO,
@@ -778,7 +787,9 @@ AVCodec msmpeg4v3_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3"),
 };
+#endif //CONFIG_MSMPEG4V3_DECODER
 
+#ifdef CONFIG_WMV1_DECODER
 AVCodec wmv1_decoder = {
     "wmv1",
     CODEC_TYPE_VIDEO,
@@ -791,7 +802,9 @@ AVCodec wmv1_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("Windows Media Video 7"),
 };
+#endif //CONFIG_WMV1_DECODER
 
+#ifdef CONFIG_H263I_DECODER
 AVCodec h263i_decoder = {
     "h263i",
     CODEC_TYPE_VIDEO,
@@ -804,7 +817,9 @@ AVCodec h263i_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name = NULL_IF_CONFIG_SMALL("H.263i"),
 };
+#endif //CONFIG_H263I_DECODER
 
+#ifdef CONFIG_FLV_DECODER
 AVCodec flv_decoder = {
     "flv",
     CODEC_TYPE_VIDEO,
@@ -817,3 +832,4 @@ AVCodec flv_decoder = {
     CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1,
     .long_name= NULL_IF_CONFIG_SMALL("Flash Video"),
 };
+#endif //CONFIG_FLV_DECODER
Only in ./libavcodec: h263dec.d
Only in ./libavcodec: h263dec.o
Only in ./libavcodec: h263.o
Only in ./libavcodec: h263_parser.d
Only in ./libavcodec: h263_parser.o
diff -ruwp ./libavcodec/h264.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264.c
--- ./libavcodec/h264.c	2009-02-21 11:13:29.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264.c	2009-01-08 09:00:00.000000000 +0100
@@ -78,6 +78,22 @@ static void filter_mb( H264Context *h, i
 static void filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize);
 static Picture * remove_long(H264Context *h, int i, int ref_mask);
 
+/* Netgem */
+static void init_dequant_tables(H264Context *h);
+static void init_scan_tables(H264Context *h);
+static int alloc_tables(H264Context *h);
+static void clone_tables(H264Context *dst, H264Context *src);
+static void execute_decode_slices(H264Context *h, int context_count);
+static inline int unreference_pic(H264Context *h, Picture *pic, int refmask);
+static int frame_start(H264Context *h);
+static void clone_slice(H264Context *dst, H264Context *src);
+static int decode_ref_pic_list_reordering(H264Context *h);
+static void fill_mbaff_ref_list(H264Context *h);
+static inline void direct_dist_scale_factor(H264Context * const h);
+static inline void direct_ref_list_init(H264Context * const h);
+static int execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count);
+/* End Netgem */
+
 static av_always_inline uint32_t pack16to32(int a, int b){
 #ifdef WORDS_BIGENDIAN
    return (b&0xFFFF) + (a<<16);
@@ -86,6 +102,8 @@ static av_always_inline uint32_t pack16t
 #endif
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
+
 static const uint8_t rem6[52]={
 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,
 };
@@ -1365,6 +1383,7 @@ static inline void write_back_motion(H26
         }
     }
 }
+#endif /* Netgem */
 
 /**
  * Decodes a network abstraction layer unit.
@@ -1453,6 +1472,7 @@ static int decode_rbsp_trailing(H264Cont
     return 0;
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  * IDCT transforms the 16 dc values and dequantizes them.
  * @param qp quantization parameter
@@ -1492,6 +1512,7 @@ static void h264_luma_dc_dequant_idct_c(
         block[stride*10+offset]= ((((z0 - z3)*qmul + 128 ) >> 8));
     }
 }
+#endif /* Netgem */
 
 #if 0
 /**
@@ -1536,6 +1557,7 @@ static void h264_luma_dc_dct_c(DCTELEM *
 #undef xStride
 #undef stride
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 static void chroma_dc_dequant_idct_c(DCTELEM *block, int qp, int qmul){
     const int stride= 16*2;
     const int xStride= 16;
@@ -1556,6 +1578,7 @@ static void chroma_dc_dequant_idct_c(DCT
     block[stride*1 + xStride*0]= ((a-c)*qmul) >> 7;
     block[stride*1 + xStride*1]= ((e-b)*qmul) >> 7;
 }
+#endif /* Netgem */
 
 #if 0
 static void chroma_dc_dct_c(DCTELEM *block){
@@ -1587,6 +1610,7 @@ static inline int get_chroma_qp(H264Cont
     return h->pps.chroma_qp_table[t][qscale];
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 //FIXME need to check that this does not overflow signed 32 bit for low qp, I am not sure, it's very close
 //FIXME check that gcc inlines this (and optimizes intra & separate_dc stuff away)
 static inline int quantize_c(DCTELEM *block, uint8_t *scantable, int qscale, int intra, int separate_dc){
@@ -2017,8 +2041,9 @@ static av_cold void decode_init_vlc(void
                  INIT_VLC_USE_NEW_STATIC);
     }
 }
+#endif /* Netgem */
 
-static void free_tables(H264Context *h){
+void ff_h264_free_tables(H264Context *h){ /* Netgem */
     int i;
     H264Context *hx;
     av_freep(&h->intra4x4_pred_mode);
@@ -2041,8 +2066,16 @@ static void free_tables(H264Context *h){
         av_freep(&hx->top_borders[0]);
         av_freep(&hx->s.obmc_scratchpad);
     }
+
+    for(i = 0; i < MAX_SPS_COUNT; i++)
+        av_freep(h->sps_buffers + i);
+
+    for(i = 0; i < MAX_PPS_COUNT; i++)
+        av_freep(h->pps_buffers + i);
+
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 static void init_dequant8_coeff_table(H264Context *h){
     int i,q,x;
     const int transpose = (h->s.dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly
@@ -2146,12 +2179,13 @@ static int alloc_tables(H264Context *h){
 
     s->obmc_scratchpad = NULL;
 
+    if (ENABLE_ANY_H264_DECODER && s->decode) /* Netgem */
     if(!h->dequant4_coeff[0])
         init_dequant_tables(h);
 
     return 0;
 fail:
-    free_tables(h);
+    ff_h264_free_tables(h);
     return -1;
 }
 
@@ -2173,6 +2207,7 @@ static void clone_tables(H264Context *ds
     dst->s.obmc_scratchpad = NULL;
     ff_h264_pred_init(&dst->hpc, src->s.codec_id);
 }
+#endif /* Netgem */
 
 /**
  * Init context
@@ -2187,6 +2222,7 @@ fail:
     return -1; // free_tables will clean up for us
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 static av_cold void common_init(H264Context *h){
     MpegEncContext * const s = &h->s;
 
@@ -2194,6 +2230,7 @@ static av_cold void common_init(H264Cont
     s->height = s->avctx->height;
     s->codec_id= s->avctx->codec->id;
 
+    if (ENABLE_ANY_H264_DECODER) /* Netgem */
     ff_h264_pred_init(&h->hpc, s->codec_id);
 
     h->dequant_coeff_pps= -1;
@@ -2253,7 +2290,7 @@ static int frame_start(H264Context *h){
      * MPV_frame_start uses pict_type to derive key_frame.
      * This is incorrect for H.264; IDR markings must be used.
      * Zero here; IDR markings per slice in frame or fields are ORed in later.
-     * See decode_nal_units().
+     * See ff_h264_decode_nal_units().
      */
     s->current_picture_ptr->key_frame= 0;
 
@@ -2559,7 +2596,7 @@ static av_always_inline void hl_decode_m
                                     idct_dc_add(ptr, h->mb + i*16, linesize);
                                 else
                                     idct_add(ptr, h->mb + i*16, linesize);
-                            }else
+                            }else if (ENABLE_SVQ3_DECODER) /* Netgem */
                                 svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);
                         }
                     }
@@ -2569,7 +2606,7 @@ static av_always_inline void hl_decode_m
                 if(is_h264){
                     if(!transform_bypass)
                         h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);
-                }else
+                }else if (ENABLE_SVQ3_DECODER) /* Netgem */
                     svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);
             }
             if(h->deblocking_filter)
@@ -2603,7 +2640,7 @@ static av_always_inline void hl_decode_m
                         }
                     }
                 }
-            }else{
+            }else if (ENABLE_SVQ3_DECODER){ /* Netgem */
                 for(i=0; i<16; i++){
                     if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ //FIXME benchmark weird rule, & below
                         uint8_t * const ptr= dest_y + block_offset[i];
@@ -2630,7 +2667,7 @@ static av_always_inline void hl_decode_m
                     else if(h->mb[i*16])
                         idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);
                 }
-            }else{
+            }else if (ENABLE_SVQ3_DECODER){ /* Netgem */
                 for(i=16; i<16+8; i++){
                     if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){
                         uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i];
@@ -2681,6 +2718,7 @@ static void hl_decode_mb(H264Context *h)
         hl_decode_mb_complex(h);
     else hl_decode_mb_simple(h);
 }
+#endif /* Netgem */
 
 static void pic_as_field(Picture *pic, const int parity){
     int i;
@@ -2810,6 +2848,7 @@ static int fill_default_ref_list(H264Con
 static void print_short_term(H264Context *h);
 static void print_long_term(H264Context *h);
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  * Extract structure information about the picture described by pic_num in
  * the current decoding context (frame or field). Note that pic_num is
@@ -2977,6 +3016,7 @@ static void fill_mbaff_ref_list(H264Cont
         memcpy(h->implicit_weight[16+2*j+1], h->implicit_weight[j], sizeof(*h->implicit_weight));
     }
 }
+#endif /* Netgem */
 
 static int pred_weight_table(H264Context *h){
     MpegEncContext * const s = &h->s;
@@ -3115,6 +3155,7 @@ static void idr(H264Context *h){
     h->prev_poc_lsb= 0;
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /* forget old pics after a seek */
 static void flush_dpb(AVCodecContext *avctx){
     H264Context *h= avctx->priv_data;
@@ -3189,6 +3230,7 @@ static Picture * remove_short(H264Contex
 
     return pic;
 }
+#endif /* Netgem */
 
 /**
  * Remove a picture from the long term reference list by its index in
@@ -3211,6 +3253,7 @@ static Picture * remove_long(H264Context
     return pic;
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  * print short term list
  */
@@ -3398,6 +3441,7 @@ static int execute_ref_pic_marking(H264C
     print_long_term(h);
     return 0;
 }
+#endif /* Netgem */
 
 static int decode_ref_pic_marking(H264Context *h, GetBitContext *gb){
     MpegEncContext * const s = &h->s;
@@ -3530,16 +3574,19 @@ static int init_poc(H264Context *h){
         field_poc[1]= poc;
     }
 
+    if (s->current_picture_ptr) { /* Netgem */
     if(s->picture_structure != PICT_BOTTOM_FIELD)
         s->current_picture_ptr->field_poc[0]= field_poc[0];
     if(s->picture_structure != PICT_TOP_FIELD)
         s->current_picture_ptr->field_poc[1]= field_poc[1];
     cur->poc= FFMIN(cur->field_poc[0], cur->field_poc[1]);
+    } /* Netgem */
 
     return 0;
 }
 
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  * initialize scan tables
  */
@@ -3615,6 +3662,7 @@ static void clone_slice(H264Context *dst
     memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));
     memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));
 }
+#endif /* Netgem */
 
 /**
  * decodes a slice header.
@@ -3698,6 +3746,7 @@ static int decode_slice_header(H264Conte
 
     if(h == h0 && h->dequant_coeff_pps != pps_id){
         h->dequant_coeff_pps = pps_id;
+        if (ENABLE_ANY_H264_DECODER && s->decode) /* Netgem */
         init_dequant_tables(h);
     }
 
@@ -3717,7 +3766,7 @@ static int decode_slice_header(H264Conte
         && (   s->width != s->avctx->width || s->height != s->avctx->height)) {
         if(h != h0)
             return -1;   // width / height changed during parallelized decoding
-        free_tables(h);
+        ff_h264_free_tables(h);
         MPV_common_end(s);
     }
     if (!s->context_initialized) {
@@ -3727,8 +3776,11 @@ static int decode_slice_header(H264Conte
             return -1;
         s->first_field = 0;
 
+        if (ENABLE_ANY_H264_DECODER && s->decode) { /* Netgem */
         init_scan_tables(h);
         alloc_tables(h);
+        } else /* Netgem */
+            s->obmc_scratchpad = NULL; /* Netgem */
 
         for(i = 1; i < s->avctx->thread_count; i++) {
             H264Context *c;
@@ -3737,8 +3789,10 @@ static int decode_slice_header(H264Conte
             memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));
             c->sps = h->sps;
             c->pps = h->pps;
+            if (ENABLE_ANY_H264_DECODER && s->decode) { /* Netgem */
             init_scan_tables(c);
             clone_tables(c, h);
+            } /* Netgem */
         }
 
         for(i = 0; i < s->avctx->thread_count; i++)
@@ -3777,6 +3831,7 @@ static int decode_slice_header(H264Conte
     }
     h->mb_field_decoding_flag= s->picture_structure != PICT_FRAME;
 
+    if (ENABLE_ANY_H264_DECODER && s->decode) { /* Netgem */
     if(h0->current_slice == 0){
         while(h->frame_num !=  h->prev_frame_num &&
               h->frame_num != (h->prev_frame_num+1)%(1<<h->sps.log2_max_frame_num)){
@@ -3837,6 +3892,7 @@ static int decode_slice_header(H264Conte
         clone_slice(h, h0);
 
     s->current_picture_ptr->frame_num= h->frame_num; //FIXME frame_num cleanup
+    } /* Netgem */
 
     assert(s->mb_num == s->mb_width * s->mb_height);
     if(first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num ||
@@ -3915,6 +3971,7 @@ static int decode_slice_header(H264Conte
         fill_default_ref_list(h);
     }
 
+    if (ENABLE_ANY_H264_DECODER && s->decode) { /* Netgem */
     if(h->slice_type_nos!=FF_I_TYPE && decode_ref_pic_list_reordering(h) < 0)
         return -1;
 
@@ -3945,6 +4002,8 @@ static int decode_slice_header(H264Conte
         direct_dist_scale_factor(h);
     direct_ref_list_init(h);
 
+    } /* Netgem */
+
     if( h->slice_type_nos != FF_I_TYPE && h->pps.cabac ){
         tmp = get_ue_golomb(&s->gb);
         if(tmp > 2){
@@ -4047,7 +4106,8 @@ static int decode_slice_header(H264Conte
                first_mb_in_slice,
                av_get_pict_type_char(h->slice_type), h->slice_type_fixed ? " fix" : "", h->nal_unit_type == NAL_IDR_SLICE ? " IDR" : "",
                pps_id, h->frame_num,
-               s->current_picture_ptr->field_poc[0], s->current_picture_ptr->field_poc[1],
+               s->current_picture_ptr?s->current_picture_ptr->field_poc[0]:0, /* Netgem */
+               s->current_picture_ptr?s->current_picture_ptr->field_poc[1]:0, /* Netgem */
                h->ref_count[0], h->ref_count[1],
                s->qscale,
                h->deblocking_filter, h->slice_alpha_c0_offset/2, h->slice_beta_offset/2,
@@ -4060,6 +4120,7 @@ static int decode_slice_header(H264Conte
     return 0;
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  *
  */
@@ -6802,6 +6863,7 @@ static int decode_slice(struct AVCodecCo
 #endif
     return -1; //not reached
 }
+#endif /* Netgem */
 
 static int decode_picture_timing(H264Context *h){
     MpegEncContext * const s = &h->s;
@@ -7324,6 +7386,7 @@ static inline int decode_picture_paramet
     return 0;
 }
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 /**
  * Call decode_slice() for each context.
  *
@@ -7358,9 +7421,10 @@ static void execute_decode_slices(H264Co
             h->s.error_count += h->thread_context[i]->s.error_count;
     }
 }
+#endif /* Netgem */
 
 
-static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
+int ff_h264_decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
     MpegEncContext * const s = &h->s;
     AVCodecContext * const avctx= s->avctx;
     int buf_index=0;
@@ -7458,6 +7522,7 @@ static int decode_nal_units(H264Context
             if((err = decode_slice_header(hx, h)))
                break;
 
+            if (s->current_picture_ptr) /* Netgem */
             s->current_picture_ptr->key_frame|= (hx->nal_unit_type == NAL_IDR_SLICE);
             if(hx->redundant_pic_count==0 && hx->s.hurry_up < 5
                && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)
@@ -7523,6 +7588,7 @@ static int decode_nal_units(H264Context
         }
 
         if(context_count == h->max_contexts) {
+            if (ENABLE_ANY_H264_DECODER && s->decode) /* Netgem */
             execute_decode_slices(h, context_count);
             context_count = 0;
         }
@@ -7540,6 +7606,7 @@ static int decode_nal_units(H264Context
             goto again;
         }
     }
+    if(ENABLE_ANY_H264_DECODER && s->decode) /* Netgem */
     if(context_count)
         execute_decode_slices(h, context_count);
     return buf_index;
@@ -7555,42 +7622,11 @@ static int get_consumed_bytes(MpegEncCon
         return pos;
 }
 
-static int decode_frame(AVCodecContext *avctx,
-                             void *data, int *data_size,
-                             const uint8_t *buf, int buf_size)
+/* Netgem: moved from decode_frame() */
+int ff_h264_decode_extradata(H264Context *h)
 {
-    H264Context *h = avctx->priv_data;
-    MpegEncContext *s = &h->s;
-    AVFrame *pict = data;
-    int buf_index;
-
-    s->flags= avctx->flags;
-    s->flags2= avctx->flags2;
-
-   /* end of stream, output what is still in the buffers */
-    if (buf_size == 0) {
-        Picture *out;
-        int i, out_idx;
-
-//FIXME factorize this with the output code below
-        out = h->delayed_pic[0];
-        out_idx = 0;
-        for(i=1; h->delayed_pic[i] && (h->delayed_pic[i]->poc && !h->delayed_pic[i]->key_frame); i++)
-            if(h->delayed_pic[i]->poc < out->poc){
-                out = h->delayed_pic[i];
-                out_idx = i;
-            }
-
-        for(i=out_idx; h->delayed_pic[i]; i++)
-            h->delayed_pic[i] = h->delayed_pic[i+1];
-
-        if(out){
-            *data_size = sizeof(AVFrame);
-            *pict= *(AVFrame*)out;
-        }
-
-        return 0;
-    }
+    MpegEncContext * const s = &h->s;
+    AVCodecContext * const avctx= s->avctx;
 
     if(h->is_avc && !h->got_avcC) {
         int i, cnt, nalsize;
@@ -7611,7 +7647,7 @@ static int decode_frame(AVCodecContext *
         p += 6;
         for (i = 0; i < cnt; i++) {
             nalsize = AV_RB16(p) + 2;
-            if(decode_nal_units(h, p, nalsize) < 0) {
+            if(ff_h264_decode_nal_units(h, p, nalsize) < 0) {
                 av_log(avctx, AV_LOG_ERROR, "Decoding sps %d from avcC failed\n", i);
                 return -1;
             }
@@ -7621,7 +7657,7 @@ static int decode_frame(AVCodecContext *
         cnt = *(p++); // Number of pps
         for (i = 0; i < cnt; i++) {
             nalsize = AV_RB16(p) + 2;
-            if(decode_nal_units(h, p, nalsize)  != nalsize) {
+            if(ff_h264_decode_nal_units(h, p, nalsize)  != nalsize) {
                 av_log(avctx, AV_LOG_ERROR, "Decoding pps %d from avcC failed\n", i);
                 return -1;
             }
@@ -7634,12 +7670,57 @@ static int decode_frame(AVCodecContext *
     }
 
     if(!h->got_avcC && !h->is_avc && s->avctx->extradata_size){
-        if(decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0)
+        if(ff_h264_decode_nal_units(h, s->avctx->extradata, s->avctx->extradata_size) < 0)
             return -1;
         h->got_avcC = 1;
     }
 
-    buf_index=decode_nal_units(h, buf, buf_size);
+    return 0;
+}
+/* End Netgem */
+
+#ifdef CONFIG_H264_DECODER
+static int decode_frame(AVCodecContext *avctx,
+                             void *data, int *data_size,
+                             const uint8_t *buf, int buf_size)
+{
+    H264Context *h = avctx->priv_data;
+    MpegEncContext *s = &h->s;
+    AVFrame *pict = data;
+    int buf_index;
+
+    s->flags= avctx->flags;
+    s->flags2= avctx->flags2;
+
+   /* end of stream, output what is still in the buffers */
+    if (buf_size == 0) {
+        Picture *out;
+        int i, out_idx;
+
+//FIXME factorize this with the output code below
+        out = h->delayed_pic[0];
+        out_idx = 0;
+        for(i=1; h->delayed_pic[i] && (h->delayed_pic[i]->poc && !h->delayed_pic[i]->key_frame); i++)
+            if(h->delayed_pic[i]->poc < out->poc){
+                out = h->delayed_pic[i];
+                out_idx = i;
+            }
+
+        for(i=out_idx; h->delayed_pic[i]; i++)
+            h->delayed_pic[i] = h->delayed_pic[i+1];
+
+        if(out){
+            *data_size = sizeof(AVFrame);
+            *pict= *(AVFrame*)out;
+        }
+
+        return 0;
+    }
+
+    if (ff_h264_decode_extradata(h) < 0) /* Netgem */
+        return -1; /* Netgem */
+
+    buf_index=ff_h264_decode_nal_units(h, buf, buf_size);
     if(buf_index < 0)
         return -1;
 
@@ -7818,6 +7899,8 @@ static int decode_frame(AVCodecContext *
 #endif
     return get_consumed_bytes(s, buf_index, buf_size);
 }
+#endif /* Netgem */
+
 #if 0
 static inline void fill_mb_avail(H264Context *h){
     MpegEncContext * const s = &h->s;
@@ -8014,21 +8097,17 @@ int main(void){
 #endif /* TEST */
 
 
+#if ENABLE_ANY_H264_DECODER /* Netgem */
 static av_cold int decode_end(AVCodecContext *avctx)
 {
     H264Context *h = avctx->priv_data;
     MpegEncContext *s = &h->s;
-    int i;
 
     av_freep(&h->rbsp_buffer[0]);
     av_freep(&h->rbsp_buffer[1]);
-    free_tables(h); //FIXME cleanup init stuff perhaps
-
-    for(i = 0; i < MAX_SPS_COUNT; i++)
-        av_freep(h->sps_buffers + i);
+    ff_h264_free_tables(h); //FIXME cleanup init stuff perhaps
 
-    for(i = 0; i < MAX_PPS_COUNT; i++)
-        av_freep(h->pps_buffers + i);
+    /* Netgem: moved sps_buffers and pps_buffers into ff_h264_free_tables() */
 
     MPV_common_end(s);
 
@@ -8051,5 +8130,8 @@ AVCodec h264_decoder = {
     .flush= flush_dpb,
     .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
 };
+#endif //CONFIG_H264_DECODER
 
+#ifdef CONFIG_SVQ3_DECODER
 #include "svq3.c"
+#endif //CONFIG_SVQ3_DECODER
Only in ./libavcodec: h264.c.orig
Only in ./libavcodec: h264.d
diff -ruwp ./libavcodec/h264.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264.h
--- ./libavcodec/h264.h	2009-02-21 11:13:29.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264.h	2009-01-08 09:00:00.000000000 +0100
@@ -29,10 +29,20 @@
 #define AVCODEC_H264_H
 
 #include "dsputil.h"
-#include "cabac.h"
 #include "mpegvideo.h"
 #include "h264pred.h"
 
+/* Netgem */
+#define ENABLE_ANY_H264_DECODER (ENABLE_H264_DECODER || \
+                                 ENABLE_SVQ3_DECODER)
+#if !ENABLE_ANY_H264_DECODER
+#  define DO_NOT_USE_AVCODEC_CABAC_FUNCTIONS
+#endif
+
+#include "cabac.h"
+/* End Netgem */
+
+
 #define interlaced_dct interlaced_dct_is_a_bad_name
 #define mb_intra mb_intra_is_not_initialized_see_mb_type
 
@@ -493,4 +503,10 @@ typedef struct H264Context{
     SEI_PicStructType sei_pic_struct;
 }H264Context;
 
+/* Netgem: export for H264 parser */
+int ff_h264_decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size);
+int ff_h264_decode_extradata(H264Context *h);
+void ff_h264_free_tables(H264Context *h);
+/* End Netgem */
+
 #endif /* AVCODEC_H264_H */
Only in ./libavcodec: h264.h.orig
Only in ./libavcodec: h264idct.d
Only in ./libavcodec: h264idct.o
diff -ruwp ./libavcodec/h264_mp4toannexb_bsf.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264_mp4toannexb_bsf.c
--- ./libavcodec/h264_mp4toannexb_bsf.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264_mp4toannexb_bsf.c	2009-01-08 09:00:00.000000000 +0100
@@ -27,14 +27,21 @@ typedef struct H264BSFContext {
     uint32_t size;
 } H264BSFContext;
 
-static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
+static int alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,
                            const uint8_t *sps_pps, uint32_t sps_pps_size,
                            const uint8_t *in,      uint32_t in_size) {
     uint32_t offset = *poutbuf_size;
     uint8_t nal_header_size = offset ? 3 : 4;
+    uint8_t *buftmp;
+    uint32_t sizetmp;
 
-    *poutbuf_size += sps_pps_size+in_size+nal_header_size;
-    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);
+    sizetmp = *poutbuf_size + sps_pps_size+in_size+nal_header_size;
+    buftmp = av_realloc(*poutbuf, sizetmp);
+    if (!buftmp)
+        return AVERROR(ENOMEM);
+
+    *poutbuf_size = sizetmp;
+    *poutbuf = buftmp;
     if (sps_pps)
         memcpy(*poutbuf+offset, sps_pps, sps_pps_size);
     memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);
@@ -44,6 +51,7 @@ static void alloc_and_copy(uint8_t **pou
         (*poutbuf+offset+sps_pps_size)[0] = (*poutbuf+offset+sps_pps_size)[1] = 0;
         (*poutbuf+offset+sps_pps_size)[2] = 1;
     }
+    return 0;
 }
 
 static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
@@ -54,6 +62,7 @@ static int h264_mp4toannexb_filter(AVBit
     H264BSFContext *ctx = bsfc->priv_data;
     uint8_t unit_type;
     uint32_t nal_size, cumul_size = 0;
+    int err;
 
     /* nothing to filter */
     if (!avctx->extradata || avctx->extradata_size < 6) {
@@ -119,15 +128,19 @@ static int h264_mp4toannexb_filter(AVBit
 
         /* prepend only to the first type 5 NAL unit of an IDR picture */
         if (ctx->first_idr && unit_type == 5) {
-            alloc_and_copy(poutbuf, poutbuf_size,
+            err= alloc_and_copy(poutbuf, poutbuf_size,
                            ctx->sps_pps_data, ctx->size,
                            buf, nal_size);
+            if (err < 0)
+                return err;
             ctx->first_idr = 0;
         }
         else {
-            alloc_and_copy(poutbuf, poutbuf_size,
+            err= alloc_and_copy(poutbuf, poutbuf_size,
                            NULL, 0,
                            buf, nal_size);
+            if (err < 0)
+                return err;
             if (!ctx->first_idr && unit_type == 1)
                 ctx->first_idr = 1;
         }
Only in ./libavcodec: h264_mp4toannexb_bsf.d
Only in ./libavcodec: h264_mp4toannexb_bsf.o
Only in ./libavcodec: h264.o
diff -ruwp ./libavcodec/h264_parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264_parser.c
--- ./libavcodec/h264_parser.c	2009-02-21 10:48:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/h264_parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -93,6 +93,51 @@ static int h264_parse(AVCodecParserConte
     ParseContext *pc = &h->s.parse_context;
     int next;
 
+    /* Netgem: full H264 parsing  */
+    if (!h->s.avctx && avctx) {
+
+        //avctx->debug |= FF_DEBUG_STARTCODE | FF_DEBUG_PICT_INFO;
+        avctx->thread_count = 1;
+
+        /* from h264.c:decode_init() */
+        h->s.avctx = avctx;
+
+        /* from h264.c:common_init() */
+        h->s.width = avctx->width;
+        h->s.height = avctx->height;
+        h->s.codec_id= avctx->codec_id;
+        h->dequant_coeff_pps= -1;
+        h->s.unrestricted_mv=1;
+        h->s.decode=0; //important!
+        memset(h->pps.scaling_matrix4, 16, 6*16*sizeof(uint8_t));
+        memset(h->pps.scaling_matrix8, 16, 2*64*sizeof(uint8_t));
+
+        /* from h264.c:decode_init() */
+        h->s.out_format = FMT_H264;
+        h->s.workaround_bugs= avctx->workaround_bugs;
+        h->s.quarter_sample = 1;
+        h->s.low_delay= 1;
+        avctx->pix_fmt = PIX_FMT_YUV420P;
+
+        /* from h264.c:decode_init() */
+        if(avctx->extradata_size > 0 && avctx->extradata &&
+           *(char *)avctx->extradata == 1){
+            h->is_avc = 1;
+            h->got_avcC = 0;
+        } else {
+            h->is_avc = 0;
+        }
+ 
+        /* from h264.c:decode_init() */
+        h->thread_context[0] = h;
+        h->outputed_poc = INT_MIN;
+        h->prev_poc_msb= 1<<16;
+
+        /* finally: decode extradata */
+        ff_h264_decode_extradata(h);
+    }
+    /* End Netgem */
+
     if(s->flags & PARSER_FLAG_COMPLETE_FRAMES){
         next= buf_size;
     }else{
@@ -110,6 +155,12 @@ static int h264_parse(AVCodecParserConte
         }
     }
 
+    /* Netgem: full H264 parsing  */
+    if (!h->s.decode && avctx && !avctx->width) {
+        ff_h264_decode_nal_units(h, buf, buf_size);
+    }
+    /* End Netgem */
+
     *poutbuf = buf;
     *poutbuf_size = buf_size;
     return next;
@@ -139,20 +190,29 @@ static int h264_split(AVCodecContext *av
     return 0;
 }
 
-static void close(AVCodecParserContext *s)
+/* Netgem: memory leak */
+static av_cold void h264_parse_close(AVCodecParserContext *s)
 {
     H264Context *h = s->priv_data;
     ParseContext *pc = &h->s.parse_context;
 
-    av_free(pc->buffer);
+    if (h->s.avctx && !h->s.decode) {
+        /* from h264.c:decode_end() */
+        av_freep(&h->rbsp_buffer[0]);
+        av_freep(&h->rbsp_buffer[1]);
+        ff_h264_free_tables(h);
+        MPV_common_end(&h->s);
 }
 
+    ff_parse_context_close(pc);
+}
+/* End Netgem */
 
 AVCodecParser h264_parser = {
     { CODEC_ID_H264 },
     sizeof(H264Context),
     NULL,
     h264_parse,
-    close,
+    h264_parse_close, /* Netgem: memory leak */
     h264_split,
 };
Only in ./libavcodec: h264_parser.c.orig
Only in ./libavcodec: h264_parser.d
Only in ./libavcodec: h264_parser.o
Only in ./libavcodec: h264pred.d
Only in ./libavcodec: h264pred.o
Only in ./libavcodec: huffman.d
Only in ./libavcodec: huffman.o
Only in ./libavcodec: huffyuv.d
Only in ./libavcodec: huffyuv.o
Only in ./libavcodec/i386: .svn
Only in ./libavcodec: idcinvideo.d
Only in ./libavcodec: idcinvideo.o
diff -ruwp ./libavcodec/imc.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/imc.c
--- ./libavcodec/imc.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/imc.c	2009-01-08 09:00:00.000000000 +0100
@@ -823,8 +823,8 @@ AVCodec imc_decoder = {
     .type = CODEC_TYPE_AUDIO,
     .id = CODEC_ID_IMC,
     .priv_data_size = sizeof(IMCContext),
-    .init = imc_decode_init,
-    .close = imc_decode_close,
+    .codec_init = imc_decode_init,
+    .codec_close = imc_decode_close,
     .decode = imc_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("IMC (Intel Music Coder)"),
 };
Only in ./libavcodec: imc.d
Only in ./libavcodec: imc.o
Only in ./libavcodec: imgconvert.c.orig
Only in ./libavcodec: imgconvert.d
Only in ./libavcodec: imgconvert.o
Only in ./libavcodec: imx_dump_header_bsf.d
Only in ./libavcodec: imx_dump_header_bsf.o
Only in ./libavcodec: indeo2.d
Only in ./libavcodec: indeo2.o
Only in ./libavcodec: indeo3.d
Only in ./libavcodec: indeo3.o
Only in ./libavcodec: interplayvideo.d
Only in ./libavcodec: interplayvideo.o
Only in ./libavcodec: intrax8.d
Only in ./libavcodec: intrax8dsp.d
Only in ./libavcodec: intrax8dsp.o
Only in ./libavcodec: intrax8.o
diff -ruwp ./libavcodec/jfdctfst.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/jfdctfst.c
--- ./libavcodec/jfdctfst.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/jfdctfst.c	2009-01-08 09:00:00.000000000 +0100
@@ -143,8 +143,19 @@
  * descale to yield a DCTELEM result.
  */
 
+#if defined(ARCH_MIPS)
+
+/* Note: we use an asm macro because gcc wants to use shift and adds
+   which are slower on 4KEC (XXX: fix gcc) */
+#define FORCED_MUL(a, b) ({ int __res; asm volatile("mul %0, %1, %2": "=r" (__res) : "r" (a), "r" (b)); __res; })
+#define MULTIPLY(var, const)  (DESCALE(FORCED_MUL(var, const), CONST_BITS))
+
+#else
+
 #define MULTIPLY(var,const)  ((DCTELEM) DESCALE((var) * (const), CONST_BITS))
 
+#endif
+
 static av_always_inline void row_fdct(DCTELEM * data){
   int_fast16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   int_fast16_t tmp10, tmp11, tmp12, tmp13;
Only in ./libavcodec: jfdctfst.d
Only in ./libavcodec: jfdctfst.o
Only in ./libavcodec: jfdctint.d
Only in ./libavcodec: jfdctint.o
Only in ./libavcodec: jpegls.d
Only in ./libavcodec: jpeglsdec.d
Only in ./libavcodec: jpeglsdec.o
Only in ./libavcodec: jpeglsenc.d
Only in ./libavcodec: jpeglsenc.o
Only in ./libavcodec: jpegls.o
Only in ./libavcodec: jrevdct.d
Only in ./libavcodec: jrevdct.o
Only in ./libavcodec: kmvc.d
Only in ./libavcodec: kmvc.o
Only in ./libavcodec: lcldec.d
Only in ./libavcodec: lcldec.o
Only in ./libavcodec: lclenc.d
Only in ./libavcodec: lclenc.o
diff -ruwp ./libavcodec/libamr.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/libamr.c
--- ./libavcodec/libamr.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/libamr.c	2009-01-08 09:00:00.000000000 +0100
@@ -69,12 +69,12 @@
 
 #define MMS_IO
 
-#include "amr/sp_dec.h"
-#include "amr/d_homing.h"
-#include "amr/typedef.h"
-#include "amr/sp_enc.h"
-#include "amr/sid_sync.h"
-#include "amr/e_homing.h"
+#include <amrnb/sp_dec.h>
+#include <amrnb/d_homing.h>
+#include <amrnb/typedef.h>
+#include <amrnb/sp_enc.h>
+#include <amrnb/sid_sync.h>
+#include <amrnb/e_homing.h>
 
 #else
 #include <amrnb/interf_dec.h>
@@ -245,16 +245,16 @@ static int amr_nb_decode_close(AVCodecCo
 
 static int amr_nb_decode_frame(AVCodecContext * avctx,
             void *data, int *data_size,
-            uint8_t * buf, int buf_size)
+            const uint8_t * buf, int buf_size)
 {
     AMRContext *s = avctx->priv_data;
-    uint8_t*amrData=buf;
+    const uint8_t*amrData=buf;
     int offset=0;
     UWord8 toc, q, ft;
     Word16 serial[SERIAL_FRAMESIZE];   /* coded bits */
     Word16 *synth;
-    UWord8 *packed_bits;
-    static Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};
+    const UWord8 *packed_bits;
+    static const Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};
     int i;
 
     //printf("amr_decode_frame data_size=%i buf=0x%X buf_size=%d frameCount=%d!!\n",*data_size,buf,buf_size,s->frameCount);
@@ -441,7 +441,7 @@ static int amr_nb_encode_close(AVCodecCo
 
 static int amr_nb_decode_frame(AVCodecContext * avctx,
             void *data, int *data_size,
-            uint8_t * buf, int buf_size)
+            const uint8_t * buf, int buf_size)
 {
     AMRContext *s = avctx->priv_data;
     uint8_t*amrData=buf;
@@ -492,8 +492,7 @@ static int amr_nb_encode_frame(AVCodecCo
 
 #endif
 
-#if defined(CONFIG_LIBAMR_NB) || defined(CONFIG_LIBAMR_NB_FIXED)
-
+#ifdef CONFIG_LIBAMR_NB_DECODER
 AVCodec libamr_nb_decoder =
 {
     "libamr_nb",
@@ -506,7 +505,9 @@ AVCodec libamr_nb_decoder =
     amr_nb_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("libamr-nb Adaptive Multi-Rate (AMR) Narrow-Band"),
 };
+#endif
 
+#ifdef CONFIG_LIBAMR_NB_ENCODER
 AVCodec libamr_nb_encoder =
 {
     "libamr_nb",
@@ -520,7 +521,6 @@ AVCodec libamr_nb_encoder =
     .sample_fmts = (enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
     .long_name = NULL_IF_CONFIG_SMALL("libamr-nb Adaptive Multi-Rate (AMR) Narrow-Band"),
 };
-
 #endif
 
 /* -----------AMR wideband ------------*/
@@ -689,6 +689,7 @@ static int amr_wb_decode_close(AVCodecCo
     return 0;
 }
 
+#ifdef CONFIG_LIBAMR_WB_DECODER
 AVCodec libamr_wb_decoder =
 {
     "libamr_wb",
@@ -701,7 +702,9 @@ AVCodec libamr_wb_decoder =
     amr_wb_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("libamr-wb Adaptive Multi-Rate (AMR) Wide-Band"),
 };
+#endif
 
+#ifdef CONFIG_LIBAMR_WB_ENCODER
 AVCodec libamr_wb_encoder =
 {
     "libamr_wb",
@@ -715,5 +718,6 @@ AVCodec libamr_wb_encoder =
     .sample_fmts = (enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
     .long_name = NULL_IF_CONFIG_SMALL("libamr-wb Adaptive Multi-Rate (AMR) Wide-Band"),
 };
+#endif
 
 #endif //CONFIG_LIBAMR_WB
Only in ./libavcodec: libavcodec.a
Only in ./libavcodec: libavcodec.pc
Only in ./libavcodec: libavcodec-uninstalled.pc
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec: libtremor.c
Only in ./libavcodec: ljpegenc.d
Only in ./libavcodec: ljpegenc.o
Only in ./libavcodec: loco.d
Only in ./libavcodec: loco.o
Only in ./libavcodec: lpc.d
Only in ./libavcodec: lpc.o
Only in ./libavcodec: lzw.d
Only in ./libavcodec: lzwenc.d
Only in ./libavcodec: lzwenc.o
Only in ./libavcodec: lzw.o
Only in ./libavcodec: mace.d
Only in ./libavcodec: mace.o
Only in ./libavcodec: Makefile
Only in ./libavcodec: Makefile.orig
Only in ./libavcodec: mdct.d
Only in ./libavcodec: mdct.o
Only in ./libavcodec: mdec.d
Only in ./libavcodec: mdec.o
Only in ./libavcodec: mimic.d
Only in ./libavcodec: mimic.o
Only in ./libavcodec: mjpega_dump_header_bsf.d
Only in ./libavcodec: mjpega_dump_header_bsf.o
Only in ./libavcodec: mjpegbdec.d
Only in ./libavcodec: mjpegbdec.o
Only in ./libavcodec: mjpeg.d
diff -ruwp ./libavcodec/mjpegdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mjpegdec.c
--- ./libavcodec/mjpegdec.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mjpegdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -1357,6 +1357,7 @@ av_cold int ff_mjpeg_decode_end(AVCodecC
     return 0;
 }
 
+#ifdef CONFIG_MJPEG_DECODER
 AVCodec mjpeg_decoder = {
     "mjpeg",
     CODEC_TYPE_VIDEO,
@@ -1370,7 +1371,9 @@ AVCodec mjpeg_decoder = {
     NULL,
     .long_name = NULL_IF_CONFIG_SMALL("MJPEG (Motion JPEG)"),
 };
+#endif //CONFIG_MJPEG_DECODER
 
+#ifdef CONFIG_THP_DECODER
 AVCodec thp_decoder = {
     "thp",
     CODEC_TYPE_VIDEO,
@@ -1384,3 +1387,4 @@ AVCodec thp_decoder = {
     NULL,
     .long_name = NULL_IF_CONFIG_SMALL("Nintendo Gamecube THP video"),
 };
+#endif //CONFIG_THP_DECODER
Only in ./libavcodec: mjpegdec.d
Only in ./libavcodec: mjpegdec.o
Only in ./libavcodec: mjpegenc.d
Only in ./libavcodec: mjpegenc.o
Only in ./libavcodec: mjpeg.o
Only in ./libavcodec: mjpeg_parser.d
Only in ./libavcodec: mjpeg_parser.o
Only in ./libavcodec/mlib: .svn
Only in ./libavcodec: mlp.d
Only in ./libavcodec: mlpdec.d
Only in ./libavcodec: mlpdec.o
Only in ./libavcodec: mlp.o
Only in ./libavcodec: mlp_parser.d
Only in ./libavcodec: mlp_parser.o
Only in ./libavcodec: mmvideo.d
Only in ./libavcodec: mmvideo.o
Only in ./libavcodec: motion_est.d
Only in ./libavcodec: motion_est.o
Only in ./libavcodec: motionpixels.d
Only in ./libavcodec: motionpixels.o
Only in ./libavcodec: movsub_bsf.d
Only in ./libavcodec: movsub_bsf.o
Only in ./libavcodec: mp3_header_compress_bsf.d
Only in ./libavcodec: mp3_header_compress_bsf.o
Only in ./libavcodec: mp3_header_decompress_bsf.d
Only in ./libavcodec: mp3_header_decompress_bsf.o
Only in ./libavcodec: mpc7.d
Only in ./libavcodec: mpc7.o
Only in ./libavcodec: mpc8.d
Only in ./libavcodec: mpc8.o
Only in ./libavcodec: mpc.d
Only in ./libavcodec: mpc.o
diff -ruwp ./libavcodec/mpeg12.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12.c
--- ./libavcodec/mpeg12.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12.c	2009-01-08 09:00:00.000000000 +0100
@@ -45,6 +45,8 @@
 #define MB_PTYPE_VLC_BITS 6
 #define MB_BTYPE_VLC_BITS 6
 
+#if ENABLE_ANY_MPEGVIDEO_DECODER
+
 static inline int mpeg1_decode_block_inter(MpegEncContext *s,
                               DCTELEM *block,
                               int n);
@@ -63,16 +65,22 @@ static inline int mpeg2_fast_decode_bloc
 static int mpeg_decode_motion(MpegEncContext *s, int fcode, int pred);
 static void exchange_uv(MpegEncContext *s);
 
+#endif //ENABLE_ANY_MPEGVIDEO_DECODER
+
 extern int XVMC_field_start(MpegEncContext *s, AVCodecContext *avctx);
 extern int XVMC_field_end(MpegEncContext *s);
 extern void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 
+#if ENABLE_ANY_MPEGVIDEO_DECODER
+
 static const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
                                            PIX_FMT_NONE};
 
+#endif //ENABLE_ANY_MPEGVIDEO_DECODER
+
 uint8_t ff_mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
 
 
@@ -139,6 +147,8 @@ void ff_mpeg1_clean_buffers(MpegEncConte
 /******************************************/
 /* decoding */
 
+#if ENABLE_ANY_MPEGVIDEO_DECODER
+
 static VLC mv_vlc;
 static VLC mbincr_vlc;
 static VLC mb_ptype_vlc;
@@ -2167,6 +2177,9 @@ static void mpeg_decode_gop(AVCodecConte
             time_code_hours, time_code_minutes, time_code_seconds,
             time_code_pictures, closed_gop, broken_link);
 }
+
+#endif //ENABLE_ANY_MPEGVIDEO_DECODER
+
 /**
  * Finds the end of the current frame in the bitstream.
  * @return the position of the first byte of the next frame, or -1
@@ -2225,6 +2238,8 @@ int ff_mpeg1_find_frame_end(ParseContext
     return END_NOT_FOUND;
 }
 
+#if ENABLE_ANY_MPEGVIDEO_DECODER
+
 static int decode_chunks(AVCodecContext *avctx,
                              AVFrame *picture, int *data_size,
                              const uint8_t *buf, int buf_size);
@@ -2429,6 +2444,9 @@ static int mpeg_decode_end(AVCodecContex
     return 0;
 }
 
+#endif //ENABLE_ANY_MPEGVIDEO_DECODER
+
+#ifdef CONFIG_MPEG1VIDEO_DECODER
 AVCodec mpeg1video_decoder = {
     "mpeg1video",
     CODEC_TYPE_VIDEO,
@@ -2442,7 +2460,9 @@ AVCodec mpeg1video_decoder = {
     .flush= ff_mpeg_flush,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-1 video"),
 };
+#endif //CONFIG_MPEG1VIDEO_DECODER
 
+#ifdef CONFIG_MPEG2VIDEO_DECODER
 AVCodec mpeg2video_decoder = {
     "mpeg2video",
     CODEC_TYPE_VIDEO,
@@ -2456,7 +2476,9 @@ AVCodec mpeg2video_decoder = {
     .flush= ff_mpeg_flush,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-2 video"),
 };
+#endif //CONFIG_MPEG2VIDEO_DECODER
 
+#ifdef CONFIG_MPEGVIDEO_DECODER
 //legacy decoder
 AVCodec mpegvideo_decoder = {
     "mpegvideo",
@@ -2471,6 +2493,7 @@ AVCodec mpegvideo_decoder = {
     .flush= ff_mpeg_flush,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-1 video"),
 };
+#endif //CONFIG_MPEGVIDEO_DECODER
 
 #ifdef HAVE_XVMC
 static av_cold int mpeg_mc_decode_init(AVCodecContext *avctx){
@@ -2492,6 +2515,7 @@ static av_cold int mpeg_mc_decode_init(A
     return 0;
 }
 
+#ifdef CONFIG_MPEG_XVMC_DECODER
 AVCodec mpeg_xvmc_decoder = {
     "mpegvideo_xvmc",
     CODEC_TYPE_VIDEO,
@@ -2505,5 +2529,6 @@ AVCodec mpeg_xvmc_decoder = {
     .flush= ff_mpeg_flush,
     .long_name = NULL_IF_CONFIG_SMALL("MPEG-1 video XvMC (X-Video Motion Compensation)"),
 };
+#endif //CONFIG_MPEG_XVMC_DECODER
 
-#endif
+#endif //HAVE_XVMC
Only in ./libavcodec: mpeg12.c.orig
Only in ./libavcodec: mpeg12.d
Only in ./libavcodec: mpeg12data.d
Only in ./libavcodec: mpeg12data.o
diff -ruwp ./libavcodec/mpeg12enc.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12enc.c
--- ./libavcodec/mpeg12enc.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12enc.c	2009-01-08 09:00:00.000000000 +0100
@@ -927,6 +927,7 @@ static void mpeg1_encode_block(MpegEncCo
     put_bits(&s->pb, table_vlc[112][1], table_vlc[112][0]);
 }
 
+#ifdef CONFIG_MPEG1VIDEO_ENCODER
 AVCodec mpeg1video_encoder = {
     "mpeg1video",
     CODEC_TYPE_VIDEO,
@@ -940,7 +941,9 @@ AVCodec mpeg1video_encoder = {
     .capabilities= CODEC_CAP_DELAY,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-1 video"),
 };
+#endif
 
+#ifdef CONFIG_MPEG2VIDEO_ENCODER
 AVCodec mpeg2video_encoder = {
     "mpeg2video",
     CODEC_TYPE_VIDEO,
@@ -954,3 +957,4 @@ AVCodec mpeg2video_encoder = {
     .capabilities= CODEC_CAP_DELAY,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-2 video"),
 };
+#endif
Only in ./libavcodec: mpeg12enc.d
Only in ./libavcodec: mpeg12enc.o
diff -ruwp ./libavcodec/mpeg12.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12.h
--- ./libavcodec/mpeg12.h	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg12.h	2009-01-08 09:00:00.000000000 +0100
@@ -56,4 +56,12 @@ static inline int decode_dc(GetBitContex
     return diff;
 }
 
+/* Netgem */
+#define ENABLE_ANY_MPEGVIDEO_DECODER (ENABLE_MPEGVIDEO_DECODER  ||      \
+                                      ENABLE_MPEG1VIDEO_DECODER ||      \
+                                      ENABLE_MPEG2VIDEO_DECODER ||      \
+                                      ENABLE_MPEG_XVMC_DECODER  ||      \
+                                      ENABLE_MDEC_DECODER)
+/* End Netgem */
+
 #endif /* AVCODEC_MPEG12_H */
Only in ./libavcodec: mpeg12.o
Only in ./libavcodec: mpeg4audio.d
Only in ./libavcodec: mpeg4audio.o
diff -ruwp ./libavcodec/mpeg4video_parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg4video_parser.c
--- ./libavcodec/mpeg4video_parser.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpeg4video_parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -97,6 +97,7 @@ static int mpeg4video_parse_init(AVCodec
     pc->enc = av_mallocz(sizeof(MpegEncContext));
     if (!pc->enc)
         return -1;
+    h263_decode_init_vlc(pc->enc); /* Netgem: must init on parse */
     pc->first_picture = 1;
     return 0;
 }
Only in ./libavcodec: mpeg4video_parser.d
Only in ./libavcodec: mpeg4video_parser.o
Only in ./libavcodec: mpegaudio.d
Only in ./libavcodec: mpegaudiodata.d
Only in ./libavcodec: mpegaudiodata.o
diff -ruwp ./libavcodec/mpegaudiodec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpegaudiodec.c
--- ./libavcodec/mpegaudiodec.c	2009-02-21 11:00:08.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpegaudiodec.c	2009-01-08 09:00:00.000000000 +0100
@@ -28,6 +28,10 @@
 #include "bitstream.h"
 #include "dsputil.h"
 
+/* Netgem */
+#define ENABLE_ANY_MPEGAUDIO_DECODER \
+    (ENABLE_MP2_DECODER || ENABLE_MP3_DECODER || ENABLE_MP3ADU_DECODER || ENABLE_MP3ON4_DECODER)
+
 /*
  * TODO:
  *  - in low precision mode, use more 16 bit multiplies in synth filter
@@ -81,6 +85,8 @@ typedef struct GranuleDef {
 static void compute_antialias_integer(MPADecodeContext *s, GranuleDef *g);
 static void compute_antialias_float(MPADecodeContext *s, GranuleDef *g);
 
+#if ENABLE_ANY_MPEGAUDIO_DECODER /* Netgem */
+
 /* vlc structure for decoding layer 3 huffman tables */
 static VLC huff_vlc[16];
 static VLC_TYPE huff_vlc_tables[
@@ -530,6 +536,8 @@ static int decode_init(AVCodecContext *
     return 0;
 }
 
+#endif /* Netgem */
+
 /* tab[i][j] = 1.0 / (2.0 * cos(pi*(2*k+1) / 2^(6 - j))) */
 
 /* cos(i*pi/64) */
@@ -934,6 +942,8 @@ void ff_mpa_synth_filter(MPA_INT *synth_
     *synth_buf_offset = offset;
 }
 
+#if ENABLE_ANY_MPEGAUDIO_DECODER /* Netgem */
+
 #define C3 FIXHR(0.86602540378443864676/2)
 
 /* 0.5 / cos(pi*(2*i+1)/36) */
@@ -2322,6 +2332,8 @@ static void flush(AVCodecContext *avctx)
     s->last_buf_size= 0;
 }
 
+#endif /* Netgem */
+
 #ifdef CONFIG_MP3ADU_DECODER
 static int decode_frame_adu(AVCodecContext * avctx,
                         void *data, int *data_size,
Only in ./libavcodec: mpegaudiodec.d
Only in ./libavcodec: mpegaudiodecheader.d
Only in ./libavcodec: mpegaudiodecheader.o
Only in ./libavcodec: mpegaudiodec.o
Only in ./libavcodec: mpegaudioenc.d
Only in ./libavcodec: mpegaudioenc.o
Only in ./libavcodec: mpegaudio.o
Only in ./libavcodec: mpegaudio_parser.d
Only in ./libavcodec: mpegaudio_parser.o
Only in ./libavcodec: mpegvideo.c.orig
Only in ./libavcodec: mpegvideo.d
diff -ruwp ./libavcodec/mpegvideo_enc.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpegvideo_enc.c
--- ./libavcodec/mpegvideo_enc.c	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/mpegvideo_enc.c	2009-01-08 09:00:00.000000000 +0100
@@ -3737,6 +3737,7 @@ int dct_quantize_c(MpegEncContext *s,
     return last_non_zero;
 }
 
+#ifdef CONFIG_H263_ENCODER
 AVCodec h263_encoder = {
     "h263",
     CODEC_TYPE_VIDEO,
@@ -3748,7 +3749,9 @@ AVCodec h263_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("H.263"),
 };
+#endif
 
+#ifdef CONFIG_H263P_ENCODER
 AVCodec h263p_encoder = {
     "h263p",
     CODEC_TYPE_VIDEO,
@@ -3760,7 +3763,9 @@ AVCodec h263p_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("H.263+ / H.263 version 2"),
 };
+#endif
 
+#ifdef CONFIG_FLV_ENCODER
 AVCodec flv_encoder = {
     "flv",
     CODEC_TYPE_VIDEO,
@@ -3772,7 +3777,9 @@ AVCodec flv_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("Flash Video"),
 };
+#endif
 
+#ifdef CONFIG_RV10_ENCODER
 AVCodec rv10_encoder = {
     "rv10",
     CODEC_TYPE_VIDEO,
@@ -3784,7 +3791,9 @@ AVCodec rv10_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("RealVideo 1.0"),
 };
+#endif
 
+#ifdef CONFIG_RV20_ENCODER
 AVCodec rv20_encoder = {
     "rv20",
     CODEC_TYPE_VIDEO,
@@ -3796,7 +3805,9 @@ AVCodec rv20_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("RealVideo 2.0"),
 };
+#endif
 
+#ifdef CONFIG_MPEG4_ENCODER
 AVCodec mpeg4_encoder = {
     "mpeg4",
     CODEC_TYPE_VIDEO,
@@ -3809,7 +3820,9 @@ AVCodec mpeg4_encoder = {
     .capabilities= CODEC_CAP_DELAY,
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2"),
 };
+#endif
 
+#ifdef CONFIG_MSMPEG4V1_ENCODER
 AVCodec msmpeg4v1_encoder = {
     "msmpeg4v1",
     CODEC_TYPE_VIDEO,
@@ -3821,7 +3834,9 @@ AVCodec msmpeg4v1_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 1"),
 };
+#endif
 
+#ifdef CONFIG_MSMPEG4V2_ENCODER
 AVCodec msmpeg4v2_encoder = {
     "msmpeg4v2",
     CODEC_TYPE_VIDEO,
@@ -3833,7 +3848,9 @@ AVCodec msmpeg4v2_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2"),
 };
+#endif
 
+#ifdef CONFIG_MSMPEG4V3_ENCODER
 AVCodec msmpeg4v3_encoder = {
     "msmpeg4",
     CODEC_TYPE_VIDEO,
@@ -3845,7 +3862,9 @@ AVCodec msmpeg4v3_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3"),
 };
+#endif
 
+#ifdef CONFIG_WMV1_ENCODER
 AVCodec wmv1_encoder = {
     "wmv1",
     CODEC_TYPE_VIDEO,
@@ -3857,3 +3876,4 @@ AVCodec wmv1_encoder = {
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_YUV420P, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("Windows Media Video 7"),
 };
+#endif
Only in ./libavcodec: mpegvideo_enc.d
Only in ./libavcodec: mpegvideo_enc.o
Only in ./libavcodec: mpegvideo.o
Only in ./libavcodec: mpegvideo_parser.d
Only in ./libavcodec: mpegvideo_parser.o
Only in ./libavcodec: mpegvideo_xvmc.d
Only in ./libavcodec: mpegvideo_xvmc.o
diff -ruwp ./libavcodec/msmpeg4.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/msmpeg4.c
--- ./libavcodec/msmpeg4.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/msmpeg4.c	2009-01-08 09:00:00.000000000 +0100
@@ -62,10 +62,10 @@ static uint32_t v2_dc_chroma_table[512][
 static int msmpeg4_decode_dc(MpegEncContext * s, int n, int *dir_ptr);
 static void init_h263_dc_for_msmpeg4(void);
 static inline void msmpeg4_memsetw(short *tab, int val, int n);
-#ifdef CONFIG_ENCODERS
+#if ENABLE_MSMPEG4_ENCODER
 static void msmpeg4v2_encode_motion(MpegEncContext * s, int val);
 static int get_size_of_code(MpegEncContext * s, RLTable *rl, int last, int run, int level, int intra);
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_MSMPEG4_ENCODER
 static int msmpeg4v12_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 static int msmpeg4v34_decode_mb(MpegEncContext *s, DCTELEM block[6][64]);
 
@@ -79,9 +79,9 @@ int frame_count = 0;
 
 #include "msmpeg4data.h"
 
-#ifdef CONFIG_ENCODERS //strangely gcc includes this even if it is not references
+#if ENABLE_MSMPEG4_ENCODER //strangely gcc includes this even if it is not references
 static uint8_t rl_length[NB_RL_TABLES][MAX_LEVEL+1][MAX_RUN+1][2];
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_MSMPEG4_ENCODER
 
 static uint8_t static_rl_table_store[NB_RL_TABLES][2][2*MAX_RUN + MAX_LEVEL + 3];
 
@@ -134,7 +134,7 @@ static void common_init(MpegEncContext *
     }
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_MSMPEG4_ENCODER
 
 /* build the table which associate a (x,y) motion vector to a vlc */
 static void init_mv_table(MVTable *tab)
@@ -382,7 +382,7 @@ void msmpeg4_encode_ext_header(MpegEncCo
             assert(s->flipflop_rounding==0);
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_MSMPEG4_ENCODER
 
 /* predict coded block */
 int ff_msmpeg4_coded_block_pred(MpegEncContext * s, int n, uint8_t **coded_block_ptr)
@@ -411,7 +411,7 @@ int ff_msmpeg4_coded_block_pred(MpegEncC
     return pred;
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_MSMPEG4_ENCODER
 
 void ff_msmpeg4_encode_motion(MpegEncContext * s,
                                   int mx, int my)
@@ -591,7 +591,7 @@ void msmpeg4_encode_mb(MpegEncContext *
     }
 }
 
-#endif //CONFIG_ENCODERS
+#endif //ENABLE_MSMPEG4_ENCODER
 
 static inline int msmpeg4v1_pred_dc(MpegEncContext * s, int n,
                                     int32_t **dc_val_ptr)
@@ -771,6 +771,8 @@ static inline int msmpeg4_pred_dc(MpegEn
 
 #define DC_MAX 119
 
+#if ENABLE_MSMPEG4_ENCODER
+
 static void msmpeg4_encode_dc(MpegEncContext * s, int level, int n, int *dir_ptr)
 {
     int sign, code;
@@ -979,6 +981,8 @@ else
     }
 }
 
+#endif //ENABLE_MSMPEG4_ENCODER
+
 /****************************************/
 /* decoding stuff */
 
@@ -1362,7 +1366,7 @@ static inline void msmpeg4_memsetw(short
         tab[i] = val;
 }
 
-#ifdef CONFIG_ENCODERS
+#if ENABLE_MSMPEG4_ENCODER
 static void msmpeg4v2_encode_motion(MpegEncContext * s, int val)
 {
     int range, bit_size, sign, code, bits;
Only in ./libavcodec: msmpeg4.d
Only in ./libavcodec: msmpeg4data.d
Only in ./libavcodec: msmpeg4data.o
Only in ./libavcodec: msmpeg4.o
Only in ./libavcodec: msrle.d
Only in ./libavcodec: msrledec.d
Only in ./libavcodec: msrledec.o
Only in ./libavcodec: msrle.o
Only in ./libavcodec: msvideo1.d
Only in ./libavcodec: msvideo1.o
Only in ./libavcodec: nellymoser.d
Only in ./libavcodec: nellymoserdec.d
Only in ./libavcodec: nellymoserdec.o
Only in ./libavcodec: nellymoserenc.d
Only in ./libavcodec: nellymoserenc.o
Only in ./libavcodec: nellymoser.o
Only in ./libavcodec: noise_bsf.d
Only in ./libavcodec: noise_bsf.o
Only in ./libavcodec: nuv.d
Only in ./libavcodec: nuv.o
Only in ./libavcodec: opt.d
Only in ./libavcodec: options.d
Only in ./libavcodec: options.o
Only in ./libavcodec: opt.o
diff -ruwp ./libavcodec/parser.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/parser.c
--- ./libavcodec/parser.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/parser.c	2009-01-08 09:00:00.000000000 +0100
@@ -288,11 +288,18 @@ int ff_combine_frame(ParseContext *pc, i
     return 0;
 }
 
+/* Netgem */
+void ff_parse_context_close(ParseContext *pc)
+{
+    av_freep(&pc->buffer);
+}
+/* End Netgem */
+
 void ff_parse_close(AVCodecParserContext *s)
 {
     ParseContext *pc = s->priv_data;
 
-    av_freep(&pc->buffer);
+    ff_parse_context_close(pc); /* Netgem */
 }
 
 void ff_parse1_close(AVCodecParserContext *s)
Only in ./libavcodec: parser.d
diff -ruwp ./libavcodec/parser.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/parser.h
--- ./libavcodec/parser.h	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/parser.h	2009-01-08 09:00:00.000000000 +0100
@@ -59,6 +59,7 @@ int ff_mpeg4video_split(AVCodecContext *
                         int buf_size);
 void ff_parse_close(AVCodecParserContext *s);
 void ff_parse1_close(AVCodecParserContext *s);
+void ff_parse_context_close(ParseContext *pc); /* Netgem */
 
 /**
  * Fetches timestamps for a specific byte within the current access unit.
Only in ./libavcodec: parser.o
Only in ./libavcodec: pcm.d
Only in ./libavcodec: pcm.o
Only in ./libavcodec: pcx.d
Only in ./libavcodec: pcx.o
Only in ./libavcodec: png.d
Only in ./libavcodec: pngdec.d
Only in ./libavcodec: pngdec.o
Only in ./libavcodec: pngenc.d
Only in ./libavcodec: pngenc.o
Only in ./libavcodec: png.o
Only in ./libavcodec: pnm.d
Only in ./libavcodec: pnmenc.d
Only in ./libavcodec: pnmenc.o
Only in ./libavcodec: pnm.o
Only in ./libavcodec: pnm_parser.d
Only in ./libavcodec: pnm_parser.o
Only in ./libavcodec/ppc: .svn
Only in ./libavcodec/ps2: .svn
Only in ./libavcodec: ptx.d
Only in ./libavcodec: ptx.o
Only in ./libavcodec: qcelpdec.d
Only in ./libavcodec: qcelpdec.o
Only in ./libavcodec: qcelp_lsp.d
Only in ./libavcodec: qcelp_lsp.o
diff -ruwp ./libavcodec/qdm2.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/qdm2.c
--- ./libavcodec/qdm2.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/qdm2.c	2009-01-08 09:00:00.000000000 +0100
@@ -2040,8 +2040,8 @@ AVCodec qdm2_decoder =
     .type = CODEC_TYPE_AUDIO,
     .id = CODEC_ID_QDM2,
     .priv_data_size = sizeof(QDM2Context),
-    .init = qdm2_decode_init,
-    .close = qdm2_decode_close,
+    .codec_init = qdm2_decode_init,
+    .codec_close = qdm2_decode_close,
     .decode = qdm2_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("QDesign Music Codec 2"),
 };
Only in ./libavcodec: qdm2.d
Only in ./libavcodec: qdm2.o
Only in ./libavcodec: qdrw.d
Only in ./libavcodec: qdrw.o
Only in ./libavcodec: qpeg.d
Only in ./libavcodec: qpeg.o
Only in ./libavcodec: qtrle.d
Only in ./libavcodec: qtrleenc.d
Only in ./libavcodec: qtrleenc.o
Only in ./libavcodec: qtrle.o
Only in ./libavcodec: ra144.d
Only in ./libavcodec: ra144.o
Only in ./libavcodec: ra288.d
Only in ./libavcodec: ra288.o
Only in ./libavcodec: rangecoder.d
Only in ./libavcodec: rangecoder.o
Only in ./libavcodec: ratecontrol.d
Only in ./libavcodec: ratecontrol.o
Only in ./libavcodec: raw.d
Only in ./libavcodec: rawdec.d
Only in ./libavcodec: rawdec.o
Only in ./libavcodec: rawenc.d
Only in ./libavcodec: rawenc.o
Only in ./libavcodec: raw.o
Only in ./libavcodec: rdft.d
Only in ./libavcodec: rdft.o
Only in ./libavcodec: remove_extradata_bsf.d
Only in ./libavcodec: remove_extradata_bsf.o
Only in ./libavcodec: resample2.d
Only in ./libavcodec: resample2.o
diff -ruwp ./libavcodec/resample.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/resample.c
--- ./libavcodec/resample.c	2009-02-21 10:46:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/resample.c	2009-01-08 09:00:00.000000000 +0100
@@ -35,6 +35,14 @@ struct ReSampleContext {
     float ratio;
     /* channel convert */
     int input_channels, output_channels, filter_channels;
+
+    /* Netgem: move malloc to resample init code */
+    int real_temp_len[2];
+    short *bufin[2];
+    int real_bufin_len[2];
+    short *bufout[2];
+    int real_bufout_len[2];
+    /* End Netgem */
 };
 
 /* n1: number of samples */
@@ -162,7 +170,14 @@ ReSampleContext *audio_resample_init(int
       s->filter_channels = 2;
 
 #define TAPS 16
-    s->resample_context= av_resample_init(output_rate, input_rate, TAPS, 10, 0, 0.8);
+#if (defined ARCH_MIPS) || (defined ARCH_POWERPC_405)
+#  define PHASE  4
+#  define LINEAR 1
+#else
+#  define PHASE  10
+#  define LINEAR 0
+#endif
+    s->resample_context= av_resample_init(output_rate, input_rate, TAPS, PHASE, LINEAR, 0.8);
 
     return s;
 }
@@ -172,10 +187,9 @@ ReSampleContext *audio_resample_init(int
 int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)
 {
     int i, nb_samples1;
-    short *bufin[2];
-    short *bufout[2];
     short *buftmp2[2], *buftmp3[2];
     int lenout;
+    short *p;
 
     if (s->input_channels == s->output_channels && s->ratio == 1.0 && 0) {
         /* nothing to do */
@@ -183,28 +197,36 @@ int audio_resample(ReSampleContext *s, s
         return nb_samples;
     }
 
-    /* XXX: move those malloc to resample init code */
     for(i=0; i<s->filter_channels; i++){
-        bufin[i]= av_malloc( (nb_samples + s->temp_len) * sizeof(short) );
-        memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));
-        buftmp2[i] = bufin[i] + s->temp_len;
+        p= av_fast_realloc(s->bufin[i], &s->real_bufin_len[i], (nb_samples + s->temp_len) * sizeof(short) );
+        if (!p && (nb_samples + s->temp_len))
+            return -1;
+        s->bufin[i]= p;
+        memcpy(s->bufin[i], s->temp[i], s->temp_len * sizeof(short));
+        buftmp2[i] = s->bufin[i] + s->temp_len;
     }
 
     /* make some zoom to avoid round pb */
     lenout= 4*nb_samples * s->ratio + 16;
-    bufout[0]= av_malloc( lenout * sizeof(short) );
-    bufout[1]= av_malloc( lenout * sizeof(short) );
+    p= av_fast_realloc(s->bufout[0], &s->real_bufout_len[0], lenout * sizeof(short) );
+    if (!p && lenout)
+        return -1;
+    s->bufout[0]= p;
+    p= av_fast_realloc(s->bufout[1], &s->real_bufout_len[1], lenout * sizeof(short) );
+    if (!p && lenout)
+        return -1;
+    s->bufout[1]= p;
 
     if (s->input_channels == 2 &&
         s->output_channels == 1) {
         buftmp3[0] = output;
         stereo_to_mono(buftmp2[0], input, nb_samples);
     } else if (s->output_channels >= 2 && s->input_channels == 1) {
-        buftmp3[0] = bufout[0];
+        buftmp3[0] = s->bufout[0];
         memcpy(buftmp2[0], input, nb_samples*sizeof(short));
     } else if (s->output_channels >= 2) {
-        buftmp3[0] = bufout[0];
-        buftmp3[1] = bufout[1];
+        buftmp3[0] = s->bufout[0];
+        buftmp3[1] = s->bufout[1];
         stereo_split(buftmp2[0], buftmp2[1], input, nb_samples);
     } else {
         buftmp3[0] = output;
@@ -219,10 +241,13 @@ int audio_resample(ReSampleContext *s, s
         int consumed;
         int is_last= i+1 == s->filter_channels;
 
-        nb_samples1 = av_resample(s->resample_context, buftmp3[i], bufin[i], &consumed, nb_samples, lenout, is_last);
+        nb_samples1 = av_resample(s->resample_context, buftmp3[i], s->bufin[i], &consumed, nb_samples, lenout, is_last);
         s->temp_len= nb_samples - consumed;
-        s->temp[i]= av_realloc(s->temp[i], s->temp_len*sizeof(short));
-        memcpy(s->temp[i], bufin[i] + consumed, s->temp_len*sizeof(short));
+        p= av_fast_realloc(s->temp[i], &s->real_temp_len[i], s->temp_len*sizeof(short));
+        if (!p && s->temp_len)
+            return -1;
+        s->temp[i]= p;
+        memcpy(s->temp[i], s->bufin[i] + consumed, s->temp_len*sizeof(short));
     }
 
     if (s->output_channels == 2 && s->input_channels == 1) {
@@ -233,18 +258,18 @@ int audio_resample(ReSampleContext *s, s
         ac3_5p1_mux(output, buftmp3[0], buftmp3[1], nb_samples1);
     }
 
-    for(i=0; i<s->filter_channels; i++)
-        av_free(bufin[i]);
-
-    av_free(bufout[0]);
-    av_free(bufout[1]);
     return nb_samples1;
 }
 
 void audio_resample_close(ReSampleContext *s)
 {
+    int i;
     av_resample_close(s->resample_context);
     av_freep(&s->temp[0]);
     av_freep(&s->temp[1]);
+    for(i=0; i<s->filter_channels; i++)
+        av_freep(&s->bufin[i]);
+    av_freep(&s->bufout[0]);
+    av_freep(&s->bufout[1]);
     av_free(s);
 }
Only in ./libavcodec: resample.d
Only in ./libavcodec: resample.o
Only in ./libavcodec: rl2.d
Only in ./libavcodec: rl2.o
Only in ./libavcodec: rle.d
Only in ./libavcodec: rle.o
Only in ./libavcodec: roqaudioenc.d
Only in ./libavcodec: roqaudioenc.o
Only in ./libavcodec: roqvideo.d
Only in ./libavcodec: roqvideodec.d
Only in ./libavcodec: roqvideodec.o
Only in ./libavcodec: roqvideoenc.d
Only in ./libavcodec: roqvideoenc.o
Only in ./libavcodec: roqvideo.o
Only in ./libavcodec: rpza.d
Only in ./libavcodec: rpza.o
Only in ./libavcodec: rtjpeg.d
Only in ./libavcodec: rtjpeg.o
diff -ruwp ./libavcodec/rv10.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/rv10.c
--- ./libavcodec/rv10.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/rv10.c	2009-01-08 09:00:00.000000000 +0100
@@ -259,7 +259,9 @@ void rv10_encode_picture_header(MpegEncC
 
     put_bits(&s->pb, 3, 0);     /* ignored */
 }
+#endif //ENABLE_RV10_ENCODER
 
+#if ENABLE_RV20_ENCODER
 void rv20_encode_picture_header(MpegEncContext *s, int picture_number){
     put_bits(&s->pb, 2, s->pict_type); //I 0 vs. 1 ?
     put_bits(&s->pb, 1, 0);     /* unknown bit */
@@ -288,6 +290,7 @@ void rv20_encode_picture_header(MpegEncC
         s->c_dc_scale_table= ff_mpeg1_dc_scale_table;
     }
 }
+#endif //ENABLE_RV20_ENCODER
 
 #if 0 /* unused, remove? */
 static int get_num(GetBitContext *gb)
Only in ./libavcodec: rv10.d
Only in ./libavcodec: rv10.o
Only in ./libavcodec: rv30.d
Only in ./libavcodec: rv30dsp.d
Only in ./libavcodec: rv30dsp.o
Only in ./libavcodec: rv30.o
Only in ./libavcodec: rv34.d
Only in ./libavcodec: rv34.o
Only in ./libavcodec: rv40.d
Only in ./libavcodec: rv40dsp.d
Only in ./libavcodec: rv40dsp.o
Only in ./libavcodec: rv40.o
Only in ./libavcodec: s3tc.d
Only in ./libavcodec: s3tc.o
Only in ./libavcodec: sgidec.d
Only in ./libavcodec: sgidec.o
Only in ./libavcodec: sgienc.d
Only in ./libavcodec: sgienc.o
Only in ./libavcodec/sh4: .svn
Only in ./libavcodec: shorten.d
Only in ./libavcodec: shorten.o
Only in ./libavcodec: simple_idct.d
Only in ./libavcodec: simple_idct.o
Only in ./libavcodec: smacker.d
Only in ./libavcodec: smacker.o
Only in ./libavcodec: smc.d
Only in ./libavcodec: smc.o
Only in ./libavcodec: snow.d
Only in ./libavcodec: snow.o
Only in ./libavcodec: sonic.d
Only in ./libavcodec: sonic.o
diff -ruwp ./libavcodec/sp5xdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/sp5xdec.c
--- ./libavcodec/sp5xdec.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/sp5xdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -188,6 +188,7 @@ static int sp5x_decode_frame(AVCodecCont
     return i;
 }
 
+#ifdef CONFIG_SP5X_DECODER
 AVCodec sp5x_decoder = {
     "sp5x",
     CODEC_TYPE_VIDEO,
@@ -201,7 +202,9 @@ AVCodec sp5x_decoder = {
     NULL,
     .long_name = NULL_IF_CONFIG_SMALL("Sunplus JPEG (SP5X)"),
 };
+#endif //CONFIG_SP5X_DECODER
 
+#ifdef CONFIG_AMV_DECODER
 AVCodec amv_decoder = {
     "amv",
     CODEC_TYPE_VIDEO,
@@ -213,3 +216,4 @@ AVCodec amv_decoder = {
     sp5x_decode_frame,
     .long_name = NULL_IF_CONFIG_SMALL("AMV Video"),
 };
+#endif //CONFIG_AMV_DECODER
Only in ./libavcodec: sp5xdec.d
Only in ./libavcodec: sp5xdec.o
Only in ./libavcodec/sparc: .svn
Only in ./libavcodec: sunrast.d
Only in ./libavcodec: sunrast.o
Only in ./libavcodec: .svn
Only in ./libavcodec: svq1.d
Only in ./libavcodec: svq1dec.d
Only in ./libavcodec: svq1dec.o
Only in ./libavcodec: svq1enc.d
Only in ./libavcodec: svq1enc.o
Only in ./libavcodec: svq1.o
Only in ./libavcodec: targa.d
diff -ruwp ./libavcodec/targaenc.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/targaenc.c
--- ./libavcodec/targaenc.c	2009-02-21 10:46:41.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/targaenc.c	2009-01-08 09:00:00.000000000 +0100
@@ -153,7 +153,7 @@ AVCodec targa_encoder = {
     .type = CODEC_TYPE_VIDEO,
     .id = CODEC_ID_TARGA,
     .priv_data_size = sizeof(TargaContext),
-    .init = targa_encode_init,
+    .codec_init = targa_encode_init,
     .encode = targa_encode_frame,
     .pix_fmts= (enum PixelFormat[]){PIX_FMT_BGR24, PIX_FMT_RGB555, PIX_FMT_GRAY8, PIX_FMT_NONE},
     .long_name= NULL_IF_CONFIG_SMALL("Truevision Targa image"),
Only in ./libavcodec: targaenc.d
Only in ./libavcodec: targaenc.o
Only in ./libavcodec: targa.o
Only in ./libavcodec: tiertexseqv.d
Only in ./libavcodec: tiertexseqv.o
Only in ./libavcodec: tiff.d
Only in ./libavcodec: tiffenc.d
Only in ./libavcodec: tiffenc.o
Only in ./libavcodec: tiff.o
Only in ./libavcodec: truemotion1.d
Only in ./libavcodec: truemotion1.o
Only in ./libavcodec: truemotion2.d
Only in ./libavcodec: truemotion2.o
Only in ./libavcodec: truespeech.d
Only in ./libavcodec: truespeech.o
Only in ./libavcodec: tscc.d
Only in ./libavcodec: tscc.o
Only in ./libavcodec: tta.d
Only in ./libavcodec: tta.o
Only in ./libavcodec: txd.d
Only in ./libavcodec: txd.o
Only in ./libavcodec: ulti.d
Only in ./libavcodec: ulti.o
diff -ruwp ./libavcodec/utils.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/utils.c
--- ./libavcodec/utils.c	2009-02-21 10:54:26.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavcodec/utils.c	2009-01-08 09:00:00.000000000 +0100
@@ -67,16 +67,20 @@ static int volatile entangled_thread_cou
 
 void *av_fast_realloc(void *ptr, unsigned int *size, unsigned int min_size)
 {
+    /* Netgem: on realloc failure, do not update *size */
+    void *ptr2;
+    unsigned int new_size;
+
     if(min_size < *size)
         return ptr;
 
-    *size= FFMAX(17*min_size/16 + 32, min_size);
-
-    ptr= av_realloc(ptr, *size);
-    if(!ptr) //we could set this to the unmodified min_size but this is safer if the user lost the ptr and uses NULL now
-        *size= 0;
+    new_size= FFMAX(17*min_size/16 + 32, min_size);
+    ptr2= av_realloc(ptr, new_size);
 
-    return ptr;
+    if (new_size && ptr2)
+        *size = new_size;
+    return ptr2;
+    /* End Netgem */
 }
 
 /* encoder management */
@@ -855,8 +859,8 @@ int attribute_align_arg avcodec_open(AVC
     avctx->codec = codec;
     avctx->codec_id = codec->id;
     avctx->frame_number = 0;
-    if(avctx->codec->init){
-        ret = avctx->codec->init(avctx);
+    if(avctx->codec->codec_init){
+        ret = avctx->codec->codec_init(avctx);
         if (ret < 0) {
             av_freep(&avctx->priv_data);
             avctx->codec= NULL;
@@ -988,8 +992,8 @@ int avcodec_close(AVCodecContext *avctx)
 
     if (ENABLE_THREADS && avctx->thread_opaque)
         avcodec_thread_free(avctx);
-    if (avctx->codec->close)
-        avctx->codec->close(avctx);
+    if (avctx->codec->codec_close)
+        avctx->codec->codec_close(avctx);
     avcodec_default_free_buffers(avctx);
     av_freep(&avctx->priv_data);
     avctx->codec = NULL;
@@ -1086,8 +1090,10 @@ void avcodec_string(char *buf, int buf_s
                      (enc->codec_tag >> 16) & 0xff,
                      (enc->codec_tag >> 24) & 0xff,
                       enc->codec_tag);
+        } else if (enc->codec_tag) {
+            snprintf(buf1, sizeof(buf1), "tag=0x%04x", enc->codec_tag);
         } else {
-            snprintf(buf1, sizeof(buf1), "0x%04x", enc->codec_tag);
+            snprintf(buf1, sizeof(buf1), "id=0x%04x", enc->codec_id);
         }
         codec_name = buf1;
     }
Only in ./libavcodec: utils.d
Only in ./libavcodec: utils.o
Only in ./libavcodec: vb.d
Only in ./libavcodec: vb.o
Only in ./libavcodec: vc1.c.orig
Only in ./libavcodec: vc1.c.rej
Only in ./libavcodec: vc1.d
Only in ./libavcodec: vc1data.d
Only in ./libavcodec: vc1data.o
Only in ./libavcodec: vc1dsp.d
Only in ./libavcodec: vc1dsp.o
Only in ./libavcodec: vc1.o
Only in ./libavcodec: vc1_parser.d
Only in ./libavcodec: vc1_parser.o
Only in ./libavcodec: vcr1.d
Only in ./libavcodec: vcr1.o
Only in ./libavcodec: vdpau_internal.h.orig
Only in ./libavcodec: vmdav.d
Only in ./libavcodec: vmdav.o
Only in ./libavcodec: vmnc.d
Only in ./libavcodec: vmnc.o
Only in ./libavcodec: vorbis.d
Only in ./libavcodec: vorbis_data.d
Only in ./libavcodec: vorbis_data.o
Only in ./libavcodec: vorbis_dec.d
Only in ./libavcodec: vorbis_dec.o
Only in ./libavcodec: vorbis_enc.d
Only in ./libavcodec: vorbis_enc.o
Only in ./libavcodec: vorbis.o
Only in ./libavcodec: vp3.d
Only in ./libavcodec: vp3dsp.d
Only in ./libavcodec: vp3dsp.o
Only in ./libavcodec: vp3.o
Only in ./libavcodec: vp3_parser.d
Only in ./libavcodec: vp3_parser.o
Only in ./libavcodec: vp56.d
Only in ./libavcodec: vp56data.d
Only in ./libavcodec: vp56data.o
Only in ./libavcodec: vp56.o
Only in ./libavcodec: vp5.d
Only in ./libavcodec: vp5.o
Only in ./libavcodec: vp6.d
Only in ./libavcodec: vp6dsp.d
Only in ./libavcodec: vp6dsp.o
Only in ./libavcodec: vp6.o
Only in ./libavcodec: vqavideo.d
Only in ./libavcodec: vqavideo.o
Only in ./libavcodec: wavpack.d
Only in ./libavcodec: wavpack.o
Only in ./libavcodec: wma.d
Only in ./libavcodec: wmadec.d
Only in ./libavcodec: wmadec.o
Only in ./libavcodec: wmaenc.d
Only in ./libavcodec: wmaenc.o
Only in ./libavcodec: wma.o
Only in ./libavcodec: wmv2.d
Only in ./libavcodec: wmv2dec.d
Only in ./libavcodec: wmv2dec.o
Only in ./libavcodec: wmv2enc.d
Only in ./libavcodec: wmv2enc.o
Only in ./libavcodec: wmv2.o
Only in ./libavcodec: wnv1.d
Only in ./libavcodec: wnv1.o
Only in ./libavcodec: ws-snd1.d
Only in ./libavcodec: ws-snd1.o
Only in ./libavcodec: x86
Only in ./libavcodec: xan.d
Only in ./libavcodec: xan.o
Only in ./libavcodec: xiph.d
Only in ./libavcodec: xiph.o
Only in ./libavcodec: xl.d
Only in ./libavcodec: xl.o
Only in ./libavcodec: xsubdec.d
Only in ./libavcodec: xsubdec.o
Only in ./libavcodec: zmbv.d
Only in ./libavcodec: zmbvenc.d
Only in ./libavcodec: zmbvenc.o
Only in ./libavcodec: zmbv.o
Only in ./libavdevice: alldevices.d
Only in ./libavdevice: alldevices.o
Only in ./libavdevice: alsa-audio-common.d
Only in ./libavdevice: alsa-audio-common.o
Only in ./libavdevice: alsa-audio-dec.d
Only in ./libavdevice: alsa-audio-dec.o
Only in ./libavdevice: alsa-audio-enc.d
Only in ./libavdevice: alsa-audio-enc.o
Only in ./libavdevice: dv1394.d
Only in ./libavdevice: dv1394.o
Only in ./libavdevice: libavdevice.a
Only in ./libavdevice: libavdevice.pc
Only in ./libavdevice: libavdevice-uninstalled.pc
Only in ./libavdevice: Makefile
Only in ./libavdevice: oss_audio.d
Only in ./libavdevice: oss_audio.o
Only in ./libavdevice: .svn
Only in ./libavdevice: v4l2.d
Only in ./libavdevice: v4l2.o
Only in ./libavdevice: v4l.d
Only in ./libavdevice: v4l.o
Only in ./libavfilter: Makefile
Only in ./libavfilter: .svn
Only in ./libavformat: 4xm.d
Only in ./libavformat: 4xm.o
Only in ./libavformat: adtsenc.d
Only in ./libavformat: adtsenc.o
Only in ./libavformat: aiff.d
Only in ./libavformat: aiff.o
Only in ./libavformat: allformats.d
Only in ./libavformat: allformats.o
Only in ./libavformat: amr.d
Only in ./libavformat: amr.o
Only in ./libavformat: apc.d
Only in ./libavformat: apc.o
Only in ./libavformat: ape.d
Only in ./libavformat: ape.o
diff -ruwp ./libavformat/asf.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/asf.c
--- ./libavformat/asf.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/asf.c	2009-01-08 09:00:00.000000000 +0100
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+//#define DEBUG
+
 #include "libavutil/common.h"
 #include "libavcodec/mpegaudio.h"
 #include "avformat.h"
@@ -34,18 +36,8 @@ extern void ff_mms_set_stream_selection(
 #define FRAME_HEADER_SIZE 17
 // Fix Me! FRAME_HEADER_SIZE may be different.
 
-static const GUID index_guid = {
-    0x90, 0x08, 0x00, 0x33, 0xb1, 0xe5, 0xcf, 0x11, 0x89, 0xf4, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xcb
-};
-
-static const GUID stream_bitrate_guid = { /* (http://get.to/sdp) */
-    0xce, 0x75, 0xf8, 0x7b, 0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2
-};
 /**********************************/
 /* decoding */
-
-//#define DEBUG
-
 #ifdef DEBUG
 #define PRINT_IF_GUID(g,cmp) \
 if (!memcmp(g, &cmp, sizeof(GUID))) \
@@ -59,6 +51,7 @@ static void print_guid(const GUID *g)
     else PRINT_IF_GUID(g, stream_header);
     else PRINT_IF_GUID(g, audio_stream);
     else PRINT_IF_GUID(g, audio_conceal_none);
+    else PRINT_IF_GUID(g, audio_conceal_spread);
     else PRINT_IF_GUID(g, video_stream);
     else PRINT_IF_GUID(g, video_conceal_none);
     else PRINT_IF_GUID(g, command_stream);
@@ -66,7 +59,7 @@ static void print_guid(const GUID *g)
     else PRINT_IF_GUID(g, codec_comment_header);
     else PRINT_IF_GUID(g, codec_comment1_header);
     else PRINT_IF_GUID(g, data_header);
-    else PRINT_IF_GUID(g, index_guid);
+    else PRINT_IF_GUID(g, simple_index_header);
     else PRINT_IF_GUID(g, head1_guid);
     else PRINT_IF_GUID(g, head2_guid);
     else PRINT_IF_GUID(g, my_guid);
@@ -76,21 +69,54 @@ static void print_guid(const GUID *g)
     else PRINT_IF_GUID(g, ext_stream_audio_stream);
     else PRINT_IF_GUID(g, metadata_header);
     else PRINT_IF_GUID(g, stream_bitrate_guid);
-    else
-        dprintf(NULL, "(GUID: unknown) ");
+    /* Netgem */
+    else PRINT_IF_GUID(g, Mutex_Bitrate_header);
+    else PRINT_IF_GUID(g, Stream_Bitrate_Properties_header);
+    else PRINT_IF_GUID(g, Encoded_Content_Encryption_header);
+    else PRINT_IF_GUID(g, Script_Command_header);
+    else PRINT_IF_GUID(g, Marker_header);
+    else PRINT_IF_GUID(g, Bitrate_Mutual_Exclusion_header);
+    else PRINT_IF_GUID(g, Error_Correction_header);
+    else PRINT_IF_GUID(g, Padding_header);
+    else PRINT_IF_GUID(g, Advanced_Mutual_Exclusion_header);
+    else PRINT_IF_GUID(g, Group_Mutual_Exclusion_header);
+    else PRINT_IF_GUID(g, Stream_Prioritization_header);
+    else PRINT_IF_GUID(g, Bandwidth_Sharing_header);
+    else PRINT_IF_GUID(g, Language_List_header);
+    else PRINT_IF_GUID(g, Metadata_Library_header);
+    else PRINT_IF_GUID(g, Index_Parameters_header);
+    else PRINT_IF_GUID(g, Media_Object_Index_Parameters_header);
+    else PRINT_IF_GUID(g, Timecode_Index_Parameters_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_Pixel_Aspect_Ratio_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_Encryption_Sample_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_Timecode_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_File_Name_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_Content_Type_header);
+    else PRINT_IF_GUID(g, Payload_Extension_System_Sample_Duration_header);
+    else PRINT_IF_GUID(g, Format_WaveFormatEx_header);
+    else PRINT_IF_GUID(g, Content_Encryption_header);
+    else PRINT_IF_GUID(g, Extended_Content_Encryption_header);
+    else PRINT_IF_GUID(g, Digital_Signature_header);
+    else PRINT_IF_GUID(g, Index_header);
+   /* end Netgem */
+    else {
+        dprintf(NULL, "(GUID: unknown) {");
     for(i=0;i<16;i++)
         dprintf(NULL, " 0x%02x,", (*g)[i]);
-    dprintf(NULL, "}\n");
+        dprintf(NULL, "}");
+    }
+    dprintf(NULL, "\n");
 }
 #undef PRINT_IF_GUID
 #else
-#define print_guid(g)
+#define print_guid(g) do {} while (0)
 #endif
 
 static void get_guid(ByteIOContext *s, GUID *g)
 {
     assert(sizeof(*g) == 16);
     get_buffer(s, *g, sizeof(*g));
+    print_guid(g);
 }
 
 #if 0
@@ -141,6 +167,8 @@ static int get_value(ByteIOContext *pb,
     }
 }
 
+static void asf_build_top_level_index(AVFormatContext *s); /* Netgem */
+
 static int asf_read_header(AVFormatContext *s, AVFormatParameters *ap)
 {
     ASFContext *asf = s->priv_data;
@@ -152,9 +180,17 @@ static int asf_read_header(AVFormatConte
     int64_t gsize;
     AVRational dar[128];
     uint32_t bitrate[128];
+    char lang_name[128][4]; /* Netgem: languages support */
+    int16_t lang_index[128]; /* Netgem: languages support */
+    ASFPayload payload_ext[128][ASF_PAYLOAD_MAX]; /* Netgem: payload extension */
+    int16_t payload_number[128]; /* Netgem: payload extension */
 
     memset(dar, 0, sizeof(dar));
     memset(bitrate, 0, sizeof(bitrate));
+    memset(lang_name, 0, sizeof(lang_name)); /* Netgem: languages support */
+    memset(lang_index, -1, sizeof(lang_index)); /* Netgem: languages support */
+    memset(payload_ext, 0, sizeof(payload_ext)); /* Netgem: payload extension */
+    memset(payload_number, 0, sizeof(payload_number)); /* Netgem: payload extension */
 
     get_guid(pb, &g);
     if (memcmp(&g, &asf_header, sizeof(GUID)))
@@ -447,6 +483,7 @@ static int asf_read_header(AVFormatConte
             int ext_len, payload_ext_ct, stream_ct;
             uint32_t ext_d, leak_rate, stream_num;
             int64_t pos_ex_st;
+            int16_t lang_id; /* Netgem: languages support */
             pos_ex_st = url_ftell(pb);
 
             get_le64(pb); // starttime
@@ -460,7 +497,7 @@ static int asf_read_header(AVFormatConte
             get_le32(pb); // max-object-size
             get_le32(pb); // flags (reliable,seekable,no_cleanpoints?,resend-live-cleanpoints, rest of bits reserved)
             stream_num = get_le16(pb); // stream-num
-            get_le16(pb); // stream-language-id-index
+            lang_id = get_le16(pb); // stream-language-id-index
             get_le64(pb); // avg frametime in 100ns units
             stream_ct = get_le16(pb); //stream-name-count
             payload_ext_ct = get_le16(pb); //payload-extension-system-count
@@ -468,15 +505,33 @@ static int asf_read_header(AVFormatConte
             if (stream_num < 128)
                 bitrate[stream_num] = leak_rate;
 
+            /* Netgem: languages support */
+            if (stream_num < 128)
+                lang_index[stream_num] = lang_id;
+            /* End Netgem */
+
             for (i=0; i<stream_ct; i++){
                 get_le16(pb);
                 ext_len = get_le16(pb);
                 url_fseek(pb, ext_len, SEEK_CUR);
             }
 
+            /* Netgem: payload extensions */
+            if (stream_num < 128 && payload_ext_ct <= ASF_PAYLOAD_MAX)
+                payload_number[stream_num] = payload_ext_ct;
+            /* End Netgem */
+
             for (i=0; i<payload_ext_ct; i++){
                 get_guid(pb, &g);
                 ext_d=get_le16(pb);
+
+                /* Netgem: payload extensions */
+                if (stream_num < 128 && i < payload_number[stream_num]) {
+                    memcpy(&payload_ext[stream_num][i].guid, &g, sizeof(g));
+                    payload_ext[stream_num][i].size = ext_d;
+                }
+                /* End Netgem */
+
                 ext_len=get_le32(pb);
                 url_fseek(pb, ext_len, SEEK_CUR);
             }
@@ -495,7 +550,6 @@ static int asf_read_header(AVFormatConte
             char tag[16];
 
             get_guid(pb, &g);
-            print_guid(&g);
 
             n = get_le32(pb);
             for(i=0;i<n;i++) {
@@ -513,6 +567,30 @@ static int asf_read_header(AVFormatConte
                 *q = '\0';
             }
 #endif
+
+            /* Netgem: DRM support */
+        } else if (!memcmp(&g, &Extended_Content_Encryption_header, sizeof(GUID))) {
+                s->drm_data_len = get_le32(pb);
+                s->drm_data = av_malloc(s->drm_data_len);
+                get_buffer(pb, s->drm_data, s->drm_data_len);
+            /* End Netgem */
+
+            /* Netgem: languages support */
+        } else if (!memcmp(&g, Language_List_header, sizeof(GUID))) {
+            uint16_t lang_ct;
+            uint8_t lang_len;
+
+            lang_ct = get_le16(pb);
+            for (i=0 ; i<lang_ct ; i++) {
+                lang_len = get_byte(pb);
+                if (i < 128) {
+                    get_str16_nolen(pb, lang_len, lang_name[i], sizeof(lang_name[i]));
+                } else {
+                    url_fskip(pb, lang_len);
+                }
+            }
+            /* End Netgem */
+
         } else if (url_feof(pb)) {
             return -1;
         } else {
@@ -543,6 +621,40 @@ static int asf_read_header(AVFormatConte
         }
     }
 
+    /* Netgem: languages support */
+    for (i=0 ; i<s->nb_streams ; i++) {
+        AVStream *st = s->streams[i];
+        if (st->id >= 0 && st->id < 128) {
+            int lang_id = lang_index[st->id];
+            if (lang_id >= 0 && lang_id < 128) {
+                char *end;
+                strncpy(st->language, lang_name[lang_id], 3);
+                st->language[3] = '\0';
+                if ((end = strchr(st->language, '-')))
+                    *end = '\0';
+            }
+        }
+    }
+    /* End Netgem */
+
+    /* Netgem: payload extension */
+    for (i=0 ; i<s->nb_streams ; i++) {
+        AVStream *st = s->streams[i];
+        if (st->id >= 0 && st->id < 128) {
+            ASFStream *asf_st = st->priv_data;
+            int j;
+            asf_st->nb_payloads = payload_number[st->id];
+            for (j=0 ; j<asf_st->nb_payloads ; j++) {
+                asf_st->payload[j] = payload_ext[st->id][j];
+            }
+        }
+    }
+    /* End Netgem */
+
+    /* Netgem: parse top-level index if exists */
+    asf_build_top_level_index(s);
+    /* End Netgem */
+
     return 0;
 }
 
@@ -623,13 +735,65 @@ static int asf_get_packet(AVFormatContex
         asf->packet_segsizetype = 0x80;
     }
     asf->packet_size_left = packet_length - padsize - rsize;
+#if 0 /* Netgem: removed because that doesn't work on rtsp streaming */
     if (packet_length < asf->hdr.min_pktsize)
         padsize += asf->hdr.min_pktsize - packet_length;
+#endif
     asf->packet_padsize = padsize;
     dprintf(s, "packet: size=%d padsize=%d  left=%d\n", asf->packet_size, asf->packet_padsize, asf->packet_size_left);
     return 0;
 }
 
+/* Netgem: payload extension */
+static void asf_parse_replicated_data(AVFormatContext *s)
+{
+    ASFContext *asf = s->priv_data;
+    ByteIOContext *pb = s->pb;
+    AVStream *st = s->streams[asf->stream_index];
+    ASFStream *asf_st = st->priv_data;
+    int i;
+ 
+    if (asf_st->nb_payloads == 0) {
+        url_fskip(pb, asf->packet_replic_size - 8);
+        return;
+    }
+
+    for (i=0 ; i<asf_st->nb_payloads ; i++) {
+        uint16_t len;
+        if (asf_st->payload[i].size == 0xffff)
+            len = get_le16(pb);
+        else
+            len = asf_st->payload[i].size;
+
+        if (!memcmp(&asf_st->payload[i].guid, Payload_Extension_System_Pixel_Aspect_Ratio_header, sizeof(GUID))) {
+            uint8_t x, y;
+            x = get_byte(pb);
+            y = get_byte(pb);
+            if (x > 0 && y > 0)
+                av_reduce(&st->codec->sample_aspect_ratio.num,
+                          &st->codec->sample_aspect_ratio.den,
+                          x, y, INT_MAX);
+
+#if 0 /* use dvr-ms timestamps */
+        } else if (!memcmp(&asf_st->payload[i].guid, ??????????, sizeof(GUID))) {
+            int64_t ts0, ts1;
+            url_fskip(pb, 10);
+            ts0= get_le64(pb);
+            ts1= get_le64(pb);
+            url_fskip(pb, 12);
+            get_le32(pb);
+            url_fskip(pb, asf->packet_replic_size - 8 - 38 - 4);
+            if(ts0!= -1) asf->packet_frag_timestamp= ts0/10000;
+            else         asf->packet_frag_timestamp= AV_NOPTS_VALUE;
+#endif
+
+        } else {
+            url_fskip(pb, len);
+        }
+    }
+}
+/* End Netgem */
+
 /**
  *
  * @return <0 if error
@@ -639,7 +803,6 @@ static int asf_read_frame_header(AVForma
     ByteIOContext *pb = s->pb;
     int rsize = 1;
     int num = get_byte(pb);
-    int64_t ts0, ts1;
 
     asf->packet_segments--;
     asf->packet_key_frame = num >> 7;
@@ -656,20 +819,7 @@ static int asf_read_frame_header(AVForma
             return -1;
         }
         asf->packet_frag_timestamp = get_le32(pb); // timestamp
-        if(asf->packet_replic_size >= 8+38+4){
-//            for(i=0; i<asf->packet_replic_size-8; i++)
-//                av_log(s, AV_LOG_DEBUG, "%02X ",get_byte(pb));
-//            av_log(s, AV_LOG_DEBUG, "\n");
-            url_fskip(pb, 10);
-            ts0= get_le64(pb);
-            ts1= get_le64(pb);
-            url_fskip(pb, 12);
-            get_le32(pb);
-            url_fskip(pb, asf->packet_replic_size - 8 - 38 - 4);
-            if(ts0!= -1) asf->packet_frag_timestamp= ts0/10000;
-            else         asf->packet_frag_timestamp= AV_NOPTS_VALUE;
-        }else
-            url_fskip(pb, asf->packet_replic_size - 8);
+        asf_parse_replicated_data(s); /* Netgem: payload extension */
         rsize += asf->packet_replic_size; // FIXME - check validity
     } else if (asf->packet_replic_size==1){
         // multipacket - frag_offset is beginning timestamp
@@ -821,6 +971,16 @@ static int asf_read_packet(AVFormatConte
 
         get_buffer(pb, asf_st->pkt.data + asf->packet_frag_offset,
                    asf->packet_frag_size);
+
+        /* Netgem: DRM support */
+        if (s->drm_decrypt) {
+            s->drm_decrypt(s->callback_priv_data,
+                           asf_st->pkt.data + asf->packet_frag_offset,
+                           asf->packet_frag_size);
+        }
+        /* End Netgem */
+
+        if (ENABLE_ASFCRYPT) /* Netgem */
         if (s->key && s->keylen == 20)
             ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,
                             asf->packet_frag_size);
@@ -993,7 +1153,7 @@ static void asf_build_simple_index(AVFor
 
     url_fseek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);
     get_guid(s->pb, &g);
-    if (!memcmp(&g, &index_guid, sizeof(GUID))) {
+    if (!memcmp(&g, &simple_index_header, sizeof(GUID))) {
         gsize = get_le64(s->pb);
         get_guid(s->pb, &g);
         itime=get_le64(s->pb);
@@ -1004,7 +1164,7 @@ static void asf_build_simple_index(AVFor
         for (i=0;i<ict;i++){
             int pktnum=get_le32(s->pb);
             int pktct =get_le16(s->pb);
-            av_log(NULL, AV_LOG_DEBUG, "pktnum:%d, pktct:%d\n", pktnum, pktct);
+            dprintf(s, "pktnum:%d, pktct:%d\n", pktnum, pktct);
 
             pos=s->data_offset + asf->packet_size*(int64_t)pktnum;
             index_pts=av_rescale(itime, i, 10000);
@@ -1016,6 +1176,104 @@ static void asf_build_simple_index(AVFor
     url_fseek(s->pb, current_pos, SEEK_SET);
 }
 
+/* Netgem: top-level Index */
+static void asf_build_top_level_index(AVFormatContext *s)
+{
+    GUID g;
+    ASFContext *asf = s->priv_data;
+    int64_t gsize, itime;
+    int64_t pos, current_pos, index_pts;
+    int i;
+    int pct,ict, stream_index;
+
+    if (asf->data_object_size == (uint64_t)-1) {
+        asf->index_read= 1;
+        return;
+    }
+
+    current_pos = url_ftell(s->pb);
+
+    url_fseek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);
+    get_guid(s->pb, &g);
+
+    if (!memcmp(&g, &Index_header, sizeof(GUID))) {
+        int itime, sct, bct;
+        int b, i, j;
+        int stn[128], idt[128];
+
+        get_le64(s->pb); // Object Size
+        itime = get_le32(s->pb); // Index Entry Time Interval (in ms)
+        sct = get_le16(s->pb); // Index Specifiers Count
+        bct = get_le32(s->pb); // Index Blocks Count
+        av_log(s, AV_LOG_DEBUG, "itime:%d sct:%d bct:%d\n",itime,sct,bct);
+
+        for (i=0 ; i<sct ; i++) { // Index Specifiers
+            int idt_tmp = 0;
+
+            stn[i] = get_le16(s->pb); // Stream Number
+            if (stn[i] < 1 || stn[i] > 127) {
+                av_log(s, AV_LOG_ERROR, "invalid stream number %d\n", stn[i]);
+                goto fail;
+            }
+            idt_tmp = get_le16(s->pb); // Index Type
+
+            switch (idt_tmp) {
+            case 1:
+                av_log(s, AV_LOG_DEBUG, "st:%d 'Nearest Past Data Packet'\n", stn[i]);
+                break;
+            case 2:
+                av_log(s, AV_LOG_DEBUG, "st:%d 'Nearest Past Media Object'\n", stn[i]);
+                break;
+            case 3:
+                av_log(s, AV_LOG_DEBUG, "st:%d 'Nearest Past Cleanpoint'\n", stn[i]);
+                break;
+            case 0xff:
+                av_log(s, AV_LOG_DEBUG, "st:%d 'Frame Number Offset'\n", stn[i]);
+                break;
+            default:
+                av_log(s, AV_LOG_ERROR, "unknown index type %d\n", idt_tmp);
+                goto fail;
+            }
+
+            idt[i] = idt_tmp;
+        }
+
+        for (b=0; b<bct ; b++) { // Index Blocks
+            int ict;
+            int64_t bpos[128];
+
+            ict = get_le32(s->pb); // Index Entry Count
+            av_log(s, AV_LOG_DEBUG, "block:%d ict:%d\n", b, ict);
+
+            for (i=0 ; i<sct ; i++) {
+                bpos[i] = get_le64(s->pb); // Block Positions
+                av_log(s, AV_LOG_DEBUG, "st:%d bpos:%lld\n", stn[i], bpos[i]);
+            }
+
+            for (i=0 ; i<ict ; i++) {
+                for (j=0 ; j<sct ; j++) {
+                    unsigned int offset = get_le32(s->pb); // Offsets
+                    stream_index = asf->asfid2avid[stn[j]];
+                    dprintf(s, "idx:%d st:%d(%d) offset:0x%x\n", i, stn[j], stream_index, offset);
+
+                    if (offset != 0xffffffff && stream_index >= 0) {
+                        pos = s->data_offset + bpos[j] + offset;
+                        index_pts = i * itime;
+                        av_add_index_entry(s->streams[stream_index],
+                                           pos, index_pts, asf->packet_size, 0,
+                                           AVINDEX_KEYFRAME);
+                    }
+                }
+            }
+        }
+        asf->index_read= 1;
+    }
+
+ fail:
+    url_fseek(s->pb, current_pos, SEEK_SET);
+}
+/* end Netgem */
+
 static int asf_read_seek(AVFormatContext *s, int stream_index, int64_t pts, int flags)
 {
     ASFContext *asf = s->priv_data;
Only in ./libavformat: asfcrypt.d
Only in ./libavformat: asfcrypt.o
Only in ./libavformat: asf.d
Only in ./libavformat: asf-enc.d
Only in ./libavformat: asf-enc.o
diff -ruwp ./libavformat/asf.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/asf.h
--- ./libavformat/asf.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/asf.h	2009-01-08 09:00:00.000000000 +0100
@@ -26,6 +26,16 @@
 
 #define PACKET_SIZE 3200
 
+typedef uint8_t GUID[16];
+
+/* Netgem: Payload extension */
+#define ASF_PAYLOAD_MAX (6)
+typedef struct {
+    GUID     guid;
+    uint16_t size;
+} ASFPayload;
+/* End Netgem */
+
 typedef struct {
     int num;
     unsigned char seq;
@@ -41,9 +51,10 @@ typedef struct {
 
     int64_t packet_pos;
 
-} ASFStream;
+    uint16_t   nb_payloads;              /**< Netgem: Payload extension count */
+    ASFPayload payload[ASF_PAYLOAD_MAX]; /**< Netgem: Payload extension systems */
 
-typedef uint8_t GUID[16];
+} ASFStream;
 
 typedef struct {
     GUID guid;                  ///< generated by client computer
@@ -219,12 +230,106 @@ static const GUID metadata_header = {
         0xea, 0xcb, 0xf8, 0xc5, 0xaf, 0x5b, 0x77, 0x48, 0x84, 0x67, 0xaa, 0x8c, 0x44, 0xfa, 0x4c, 0xca
 };
 
+static const GUID stream_bitrate_guid = { /* (http://get.to/sdp) */
+    0xce, 0x75, 0xf8, 0x7b, 0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2
+};
+
 /* I am not a number !!! This GUID is the one found on the PC used to
    generate the stream */
 static const GUID my_guid = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
+/* Netgem */
+#define GUID_REORDER(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) \
+x3, x2, x1, x0, x5, x4, x7, x6, x8, x9, x10, x11, x12, x13, x14, x15
+
+static const GUID Mutex_Bitrate_header = {
+    GUID_REORDER(0xd6, 0xe2, 0x2a, 0x01, 0x35, 0xda, 0x11, 0xd1, 0x90, 0x34, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xbe)
+};
+static const GUID Stream_Bitrate_Properties_header = {
+    GUID_REORDER(0x7b, 0xf8, 0x75, 0xce, 0x46, 0x8d, 0x11, 0xd1, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2)
+};
+static const GUID Encoded_Content_Encryption_header = {
+    GUID_REORDER(0x29, 0x8a, 0xe6, 0x14, 0x26, 0x22, 0x4c, 0x17, 0xb9, 0x35, 0xda, 0xe0, 0x7e, 0xe9, 0x28, 0x9c)
+};
+static const GUID Script_Command_header = {
+    GUID_REORDER(0x1e, 0xfb, 0x1a, 0x30, 0x0b, 0x62, 0x11, 0xd0, 0xa3, 0x9b, 0x00, 0xa0, 0xc9, 0x03, 0x48, 0xf6)
+};
+static const GUID Marker_header = {
+    GUID_REORDER(0xf4, 0x87, 0xcd, 0x01, 0xa9, 0x51, 0x11, 0xcf, 0x8e, 0xe6, 0x00, 0xc0, 0x0c, 0x20, 0x53, 0x65)
+};
+static const GUID Bitrate_Mutual_Exclusion_header = {
+    GUID_REORDER(0xd6, 0xe2, 0x29, 0xdc, 0x35, 0xda, 0x11, 0xd1, 0x90, 0x34, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xbe)
+};
+static const GUID Error_Correction_header = {
+    GUID_REORDER(0x75, 0xb2, 0x26, 0x35, 0x66, 0x8e, 0x11, 0xcf, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c)
+};
+static const GUID Padding_header = {
+    GUID_REORDER(0x18, 0x06, 0xd4, 0x74, 0xca, 0xdf, 0x45, 0x09, 0xa4, 0xba, 0x9a, 0xab, 0xcb, 0x96, 0xaa, 0xe8)
+};
+static const GUID Advanced_Mutual_Exclusion_header = {
+    GUID_REORDER(0xA0, 0x86, 0x49, 0xCF, 0x47, 0x75, 0x46, 0x70, 0x8A, 0x16, 0x6E, 0x35, 0x35, 0x75, 0x66, 0xCD)
+};
+static const GUID Group_Mutual_Exclusion_header = {
+    GUID_REORDER(0xD1, 0x46, 0x5A, 0x40, 0x5A, 0x79, 0x43, 0x38, 0xB7, 0x1B, 0xE3, 0x6B, 0x8F, 0xD6, 0xC2, 0x49)
+};
+static const GUID Stream_Prioritization_header = {
+    GUID_REORDER(0xD4, 0xFE, 0xD1, 0x5B, 0x88, 0xD3, 0x45, 0x4F, 0x81, 0xF0, 0xED, 0x5C, 0x45, 0x99, 0x9E, 0x24)
+};
+static const GUID Bandwidth_Sharing_header = {
+    GUID_REORDER(0xA6, 0x96, 0x09, 0xE6, 0x51, 0x7B, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9)
+};
+static const GUID Language_List_header = {
+    GUID_REORDER(0x7C, 0x43, 0x46, 0xA9, 0xEF, 0xE0, 0x4B, 0xFC, 0xB2, 0x29, 0x39, 0x3E, 0xDE, 0x41, 0x5C, 0x85)
+};
+static const GUID Metadata_Library_header = {
+    GUID_REORDER(0x44, 0x23, 0x1C, 0x94, 0x94, 0x98, 0x49, 0xD1, 0xA1, 0x41, 0x1D, 0x13, 0x4E, 0x45, 0x70, 0x54)
+};
+static const GUID Index_Parameters_header = {
+    GUID_REORDER(0xD6, 0xE2, 0x29, 0xDF, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE)
+};
+static const GUID Media_Object_Index_Parameters_header = {
+    GUID_REORDER(0x6B, 0x20, 0x3B, 0xAD, 0x3F, 0x11, 0x4E, 0x84, 0xAC, 0xA8, 0xD7, 0x61, 0x3D, 0xE2, 0xCF, 0xA7)
+};
+static const GUID Timecode_Index_Parameters_header = {
+    GUID_REORDER(0xF5, 0x5E, 0x49, 0x6D, 0x97, 0x97, 0x4B, 0x5D, 0x8C, 0x8B, 0x60, 0x4D, 0xFE, 0x9B, 0xFB, 0x24)
+};
+static const GUID Payload_Extension_System_Pixel_Aspect_Ratio_header = {
+    GUID_REORDER(0x1B, 0x1E, 0xE5, 0x54, 0xF9, 0xEA, 0x4B, 0xC8, 0x82, 0x1A, 0x37, 0x6B, 0x74, 0xE4, 0xC4, 0xB8)
+};
+static const GUID Payload_Extension_System_Encryption_Sample_header = {
+    GUID_REORDER(0x66, 0x98, 0xB8, 0x4E, 0x0A, 0xFA, 0x43, 0x30, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D)
+};
+static const GUID Payload_Extension_System_Timecode_header = {
+    GUID_REORDER(0x39, 0x95, 0x95, 0xEC, 0x86, 0x67, 0x4E, 0x2D, 0x8F, 0xDB, 0x98, 0x81, 0x4C, 0xE7, 0x6C, 0x1E)
+};
+static const GUID Payload_Extension_System_File_Name_header = {
+    GUID_REORDER(0xE1, 0x65, 0xEC, 0x0E, 0x19, 0xED, 0x45, 0xD7, 0xB4, 0xA7, 0x25, 0xCB, 0xD1, 0xE2, 0x8E, 0x9B)
+};
+static const GUID Payload_Extension_System_Content_Type_header = {
+    GUID_REORDER(0xD5, 0x90, 0xDC, 0x20, 0x07, 0xBC, 0x43, 0x6C, 0x9C, 0xF7, 0xF3, 0xBB, 0xFB, 0xF1, 0xA4, 0xDC)
+};
+static const GUID Payload_Extension_System_Sample_Duration_header = {
+    GUID_REORDER(0xC6, 0xBD, 0x94, 0x50, 0x86, 0x7F, 0x49, 0x07, 0x83, 0xA3, 0xC7, 0x79, 0x21, 0xB7, 0x33, 0xAD)
+};
+static const GUID Format_WaveFormatEx_header = {
+    GUID_REORDER(0x05, 0x58, 0x9f, 0x81, 0xc3, 0x56, 0x11, 0xce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)
+};
+static const GUID Content_Encryption_header = {
+    GUID_REORDER(0x22, 0x11, 0xb3, 0xfb, 0xbd, 0x23, 0x11, 0xd2, 0xb4, 0xb7, 0x00, 0xa0, 0xc9, 0x55, 0xfc, 0x6e)
+};
+static const GUID Extended_Content_Encryption_header = {
+    GUID_REORDER(0x29, 0x8a, 0xe6, 0x14, 0x26, 0x22, 0x4c, 0x17, 0xb9, 0x35, 0xda, 0xe0, 0x7e, 0xe9, 0x28, 0x9c)
+};
+static const GUID Digital_Signature_header = {
+    GUID_REORDER(0x22, 0x11, 0xb3, 0xfc, 0xbd, 0x23, 0x11, 0xd2, 0xb4, 0xb7, 0x00, 0xa0, 0xc9, 0x55, 0xfc, 0x6e)
+};
+static const GUID Index_header = {
+    GUID_REORDER(0xD6, 0xE2, 0x29, 0xD3, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE)
+};
+/* End Netgem */
+
 #define ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT 0x80 //1000 0000
 
 
Only in ./libavformat: asf.o
Only in ./libavformat: assdec.d
Only in ./libavformat: assdec.o
Only in ./libavformat: assenc.d
Only in ./libavformat: assenc.o
Only in ./libavformat: au.d
Only in ./libavformat: audiointerleave.d
Only in ./libavformat: audiointerleave.o
Only in ./libavformat: au.o
Only in ./libavformat: avc.d
Only in ./libavformat: avc.o
diff -ruwp ./libavformat/avformat.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avformat.h
--- ./libavformat/avformat.h	2009-02-21 10:47:57.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avformat.h	2009-01-08 09:00:00.000000000 +0100
@@ -311,6 +311,10 @@ typedef struct AVInputFormat {
        (RTSP). */
     int (*read_pause)(struct AVFormatContext *);
 
+    /** Netgem: send keep-alive - only meaningful if using a network-based format
+        (RTSP)  */
+    int (*read_keepalive)(struct AVFormatContext *s);
+
     const struct AVCodecTag * const *codec_tag;
 
     /* private fields */
@@ -538,6 +542,7 @@ typedef struct AVFormatContext {
 #define AVFMT_FLAG_GENPTS       0x0001 ///< Generate pts if missing even if it requires parsing future frames.
 #define AVFMT_FLAG_IGNIDX       0x0002 ///< Ignore index.
 #define AVFMT_FLAG_NONBLOCK     0x0004 ///< Do not block when reading packets from input.
+#define AVFMT_FLAG_SEEKLESS     0x0008 ///< Netgem: prevent seeking (if possible) when reading packets
 
     int loop_input;
     /** Decoding: size of data to probe; encoding: unused. */
@@ -589,6 +594,22 @@ typedef struct AVFormatContext {
      */
     unsigned int max_picture_buffer;
 
+    /* Netgem: callback private data */
+    void *callback_priv_data;
+
+    /* Netgem: DRM */
+    uint8_t *drm_data;
+    int drm_data_len;
+    /* args: callback_priv_data,data,len */
+    void (*drm_decrypt)(void*,uint8_t*,int);
+    /* End Netgem */
+
+    /* Netgem: special event reporting */
+#define AVFMT_EVENT_REDIRECT (1)
+    /* args: callback_priv_data,event,uri */
+    void (*event_report)(void*,int,const char*);
+    /* End Netgem */
+
     unsigned int nb_chapters;
     AVChapter **chapters;
 
@@ -654,7 +675,7 @@ enum CodecID av_guess_codec(AVOutputForm
  *
  * @see av_hex_dump_log, av_pkt_dump, av_pkt_dump_log
  */
-void av_hex_dump(FILE *f, uint8_t *buf, int size);
+void av_hex_dump(FILE *f, const uint8_t *buf, int size);
 
 /**
  * Send a nice hexadecimal dump of a buffer to the log.
@@ -668,7 +689,7 @@ void av_hex_dump(FILE *f, uint8_t *buf,
  *
  * @see av_hex_dump, av_pkt_dump, av_pkt_dump_log
  */
-void av_hex_dump_log(void *avcl, int level, uint8_t *buf, int size);
+void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size);
 
 /**
  * Send a nice dump of a packet to the specified file stream.
@@ -808,6 +829,9 @@ int av_seek_frame(AVFormatContext *s, in
 /**
  * Start playing a network based stream (e.g. RTSP stream) at the
  * current position.
+ * @return >= 0 on success or
+ *         AVERROR(ENOSYS) if not supported or
+ *         AVERROR(EACCES) if stream is broadcast
  */
 int av_read_play(AVFormatContext *s);
 
@@ -819,6 +843,11 @@ int av_read_play(AVFormatContext *s);
 int av_read_pause(AVFormatContext *s);
 
 /**
+ * Netgem - keep alive protocols (e.g. RTSP stream).
+ */
+int av_read_keepalive(AVFormatContext *s);
+
+/**
  * Free a AVFormatContext allocated by av_open_input_stream.
  * @param s context to free
  */
@@ -954,6 +983,16 @@ int av_set_parameters(AVFormatContext *s
 int av_write_header(AVFormatContext *s);
 
 /**
+ * Netgem
+ * Initialize stream PTS generation. Must be called if a stream is added to an
+ * output media file after the call to av_write_header().
+ *
+ * @param s media file handle
+ * @return 0 if OK. AVERROR_xxx if error.
+ */
+int av_init_pts_generation(AVStream *st);
+
+/**
  * Write a packet to an output media file.
  *
  * The packet shall contain one audio or video frame.
diff -ruwp ./libavformat/avidec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avidec.c
--- ./libavformat/avidec.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avidec.c	2009-01-08 09:00:00.000000000 +0100
@@ -151,7 +151,7 @@ static int read_braindead_odml_indx(AVFo
             return -1;
     }
 
-    for(i=0; i<entries_in_use; i++){
+    for(i=0; i<entries_in_use && !url_feof(pb)/*Netgem*/; i++){
         if(index_type){
             int64_t pos= get_le32(pb) + base - 8;
             int len    = get_le32(pb);
@@ -161,7 +161,7 @@ static int read_braindead_odml_indx(AVFo
 #ifdef DEBUG_SEEK
             av_log(s, AV_LOG_ERROR, "pos:%"PRId64", len:%X\n", pos, len);
 #endif
-            if(last_pos == pos || pos == base - 8)
+            if(last_pos == pos /* || pos == base - 8 Netgem: first entry not added and i movies became ni */)
                 avi->non_interleaved= 1;
             else
                 av_add_index_entry(st, pos, ast->cum_len / FFMAX(1, ast->sample_size), len, 0, key ? AVINDEX_KEYFRAME : 0);
@@ -692,6 +692,7 @@ resync:
         AVStream *st= s->streams[ avi->stream_index ];
         AVIStream *ast= st->priv_data;
         int size;
+        int err; /* Netgem */
 
         if(ast->sample_size <= 1) // minorityreport.AVI block_align=1024 sample_size=1 IMA-ADPCM
             size= INT_MAX;
@@ -703,13 +704,20 @@ resync:
         if(size > ast->remaining)
             size= ast->remaining;
         avi->last_pkt_pos= url_ftell(pb);
-        av_get_packet(pb, pkt, size);
+        av_free_packet(pkt); /* Netgem */
+        if ((err = av_get_packet(pb, pkt, size)) < 0)
+            return err; /* Netgem */
 
         if(ast->has_pal && pkt->data && pkt->size<(unsigned)INT_MAX/2){
+            uint8_t *p; /* Netgem */
             ast->has_pal=0;
             pkt->size += 4*256;
-            pkt->data = av_realloc(pkt->data, pkt->size + FF_INPUT_BUFFER_PADDING_SIZE);
-            if(pkt->data)
+            p = av_realloc(pkt->data, pkt->size + FF_INPUT_BUFFER_PADDING_SIZE);
+            if(!p) {
+                av_free_packet(pkt);
+                return AVERROR(ENOMEM);
+            }
+            pkt->data = p; /* Netgem */
                 memcpy(pkt->data + pkt->size - 4*256, ast->pal, 4*256);
         }
 
@@ -772,6 +780,11 @@ resync:
         if(i + size > avi->fsize || d[0]<0)
             continue;
 
+        /* Netgem: problem seen into CONT-1H.avi */
+        if (size < 0)
+            continue;
+        /* End Netgem */
+
         //parse ix##
         if(  (d[0] == 'i' && d[1] == 'x' && n < s->nb_streams)
         //parse JUNK
@@ -880,7 +893,7 @@ static int avi_read_idx1(AVFormatContext
         return -1;
 
     /* Read the entries and sort them in each stream component. */
-    for(i = 0; i < nb_index_entries; i++) {
+    for(i = 0; i < nb_index_entries && !url_feof(pb)/*Netgem*/; i++) {
         tag = get_le32(pb);
         flags = get_le32(pb);
         pos = get_le32(pb);
Only in ./libavformat: avidec.d
Only in ./libavformat: avidec.o
Only in ./libavformat: avienc.d
Only in ./libavformat: avienc.o
diff -ruwp ./libavformat/aviobuf.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/aviobuf.c
--- ./libavformat/aviobuf.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/aviobuf.c	2009-01-08 09:00:00.000000000 +0100
@@ -305,10 +305,13 @@ static void fill_buffer(ByteIOContext *s
         s->checksum_ptr= s->buffer;
     }
 
+ read_packet: /* Netgem */
     if(s->read_packet)
         len = s->read_packet(s->opaque, dst, len);
     else
         len = 0;
+    if (len == AVERROR(EAGAIN)) /* Netgem */
+        goto read_packet; /* Netgem */
     if (len <= 0) {
         /* do not modify buffer if EOF reached so that a seek back can
            be done without rereading data */
@@ -378,8 +381,11 @@ int get_buffer(ByteIOContext *s, unsigne
             len = size;
         if (len == 0) {
             if(size > s->buffer_size && !s->update_checksum){
+            read_packet:/* Netgem */
                 if(s->read_packet)
                     len = s->read_packet(s->opaque, buf, size);
+                if (len == AVERROR(EAGAIN)) /* Netgem */
+                    goto read_packet; /* Netgem */
                 if (len <= 0) {
                     /* do not modify buffer if EOF reached so that a seek back can
                     be done without rereading data */
@@ -552,6 +558,7 @@ int url_fdopen(ByteIOContext **s, URLCon
     if(h->prot) {
         (*s)->read_pause = (int (*)(void *, int))h->prot->url_read_pause;
         (*s)->read_seek  = (int64_t (*)(void *, int, int64_t, int))h->prot->url_read_seek;
+        (*s)->read_keepalive = (int (*)(void *))h->prot->url_read_keepalive; /* Netgem */
     }
     return 0;
 }
@@ -680,6 +687,15 @@ int64_t av_url_read_fseek(ByteIOContext
     return ret;
 }
 
+/* Netgem */
+int av_url_read_fkeepalive(ByteIOContext *s)
+{
+    if (!s->read_keepalive)
+        return AVERROR(ENOSYS);
+    return s->read_keepalive(s->opaque);
+}
+/* End Netgem */
+
 /* url_open_dyn_buf and url_close_dyn_buf are used in rtp.c to send a response
  * back to the server even if CONFIG_MUXERS is not set. */
 #if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
Only in ./libavformat: aviobuf.d
Only in ./libavformat: aviobuf.o
Only in ./libavformat: avio.d
diff -ruwp ./libavformat/avio.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avio.h
--- ./libavformat/avio.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/avio.h	2009-01-08 09:00:00.000000000 +0100
@@ -135,6 +135,7 @@ typedef struct URLProtocol {
     int (*url_read_pause)(URLContext *h, int pause);
     int64_t (*url_read_seek)(URLContext *h,
                          int stream_index, int64_t timestamp, int flags);
+    int (*url_read_keepalive)(URLContext *h); /* Netgem */
 } URLProtocol;
 
 extern URLProtocol *first_protocol;
@@ -172,6 +173,7 @@ typedef struct {
     int (*read_pause)(void *opaque, int pause);
     int64_t (*read_seek)(void *opaque,
                      int stream_index, int64_t timestamp, int flags);
+    int (*read_keepalive)(void *opaque); /* Netgem */
 } ByteIOContext;
 
 int init_put_byte(ByteIOContext *s,
@@ -240,6 +242,7 @@ int url_ferror(ByteIOContext *s);
 int av_url_read_fpause(ByteIOContext *h, int pause);
 int64_t av_url_read_fseek(ByteIOContext *h,
                       int stream_index, int64_t timestamp, int flags);
+int av_url_read_fkeepalive(ByteIOContext *h);
 
 #define URL_EOF (-1)
 /** @note return URL_EOF (-1) if EOF */
Only in ./libavformat: avio.o
Only in ./libavformat: avs.d
Only in ./libavformat: avs.o
Only in ./libavformat: bethsoftvid.d
Only in ./libavformat: bethsoftvid.o
Only in ./libavformat: bfi.d
Only in ./libavformat: bfi.o
Only in ./libavformat: c93.d
Only in ./libavformat: c93.o
Only in ./libavformat: crcenc.d
Only in ./libavformat: crcenc.o
Only in ./libavformat: cutils.d
Only in ./libavformat: cutils.o
Only in ./libavformat: daud.d
Only in ./libavformat: daud.o
Only in ./libavformat: dsicin.d
Only in ./libavformat: dsicin.o
Only in ./libavformat: dv.d
Only in ./libavformat: dvenc.d
Only in ./libavformat: dvenc.o
Only in ./libavformat: dv.o
Only in ./libavformat: dxa.d
Only in ./libavformat: dxa.o
Only in ./libavformat: eacdata.d
Only in ./libavformat: eacdata.o
Only in ./libavformat: electronicarts.d
Only in ./libavformat: electronicarts.o
Only in ./libavformat: ffmdec.d
Only in ./libavformat: ffmdec.o
Only in ./libavformat: ffmenc.d
Only in ./libavformat: ffmenc.o
Only in ./libavformat: file.d
Only in ./libavformat: file.o
Only in ./libavformat: flic.d
Only in ./libavformat: flic.o
diff -ruwp ./libavformat/flvdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/flvdec.c
--- ./libavformat/flvdec.c	2009-02-21 10:48:40.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/flvdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -23,8 +23,11 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
+//#define DEBUG
 #include "avformat.h"
 #include "flv.h"
+#include "libavcodec/mpeg4audio.h" /* Netgem */
+#include "libavcodec/mpegaudiodata.h" /* Netgem */
 
 typedef struct {
     int wrong_dts; ///< wrong dts due to negative cts
@@ -90,6 +93,7 @@ static int flv_set_video_codec(AVFormatC
             return 1; // 1 byte body size adjustment for flv_read_packet()
         case FLV_CODECID_H264:
             vcodec->codec_id = CODEC_ID_H264;
+            vstream->need_parsing = AVSTREAM_PARSE_HEADERS; /* Netgem */
             return 3; // not 4, reading packet type will consume one byte
         default:
             av_log(s, AV_LOG_INFO, "Unsupported video codec (%x)\n", flv_codecid);
@@ -209,6 +213,11 @@ static int amf_parse_object(AVFormatCont
                     }
                 }
             }
+            /* Netgem */
+            else if(!strcmp(key, "framerate") && vcodec && num_val > 0) {
+                vcodec->time_base = av_d2q(1/num_val, 60000);
+            }
+            /* End Netgem */
         }
     }
 
@@ -418,6 +427,21 @@ static int flv_read_packet(AVFormatConte
         if (type == 0) {
             if ((ret = flv_get_extradata(s, st, size)) < 0)
                 return ret;
+
+            /* Netgem */
+            if (st->codec->codec_id == CODEC_ID_AAC) {
+                MPEG4AudioConfig cfg;
+                ff_mpeg4audio_get_config(&cfg, st->codec->extradata,
+                                         st->codec->extradata_size);
+                if (cfg.chan_config > 7)
+                    return -1;
+                st->codec->channels = ff_mpeg4audio_channels[cfg.chan_config];
+                st->codec->sample_rate = cfg.sample_rate;
+                dprintf(s, "mp4a config channels %d sample rate %d\n",
+                        st->codec->channels, st->codec->sample_rate);
+            }
+            /* End Netgem */
+
             goto retry;
         }
     }
Only in ./libavformat: flvdec.d
Only in ./libavformat: flvdec.o
Only in ./libavformat: flvenc.d
Only in ./libavformat: flvenc.o
Only in ./libavformat: framecrcenc.d
Only in ./libavformat: framecrcenc.o
Only in ./libavformat: framehook.d
Only in ./libavformat: framehook.o
Only in ./libavformat: gif.d
Only in ./libavformat: gif.o
Only in ./libavformat: gopher.d
Only in ./libavformat: gopher.o
Only in ./libavformat: gxf.d
Only in ./libavformat: gxfenc.d
Only in ./libavformat: gxfenc.o
Only in ./libavformat: gxf.o
Only in ./libavformat: http.d
Only in ./libavformat: http.o
Only in ./libavformat: id3v2.d
Only in ./libavformat: id3v2.o
Only in ./libavformat: idcin.d
Only in ./libavformat: idcin.o
Only in ./libavformat: idroq.d
Only in ./libavformat: idroq.o
Only in ./libavformat: iff.d
Only in ./libavformat: iff.o
Only in ./libavformat: img2.d
Only in ./libavformat: img2.o
Only in ./libavformat: ipmovie.d
Only in ./libavformat: ipmovie.o
Only in ./libavformat: isom.d
Only in ./libavformat: isom.o
Only in ./libavformat: iss.d
Only in ./libavformat: iss.o
Only in ./libavformat: libavformat.a
Only in ./libavformat: libavformat.pc
Only in ./libavformat: libavformat-uninstalled.pc
Only in ./libavformat: lmlm4.d
Only in ./libavformat: lmlm4.o
Only in ./libavformat: Makefile
Only in ./libavformat: matroska.d
diff -ruwp ./libavformat/matroskadec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/matroskadec.c
--- ./libavformat/matroskadec.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/matroskadec.c	2009-01-08 09:00:00.000000000 +0100
@@ -618,13 +618,16 @@ static int ebml_read_ascii(ByteIOContext
 static int ebml_read_binary(ByteIOContext *pb, int length, EbmlBin *bin)
 {
     av_free(bin->data);
+    bin->size = 0; /* Netgem: reinit size */
     if (!(bin->data = av_malloc(length)))
         return AVERROR(ENOMEM);
 
-    bin->size = length;
     bin->pos  = url_ftell(pb);
-    if (get_buffer(pb, bin->data, length) != length)
+    if (get_buffer(pb, bin->data, length) != length) {
+        av_freep(&bin->data); /* Netgem: memory leak */
         return AVERROR(EIO);
+    }
+    bin->size = length; /* Netgem: moved len after read */
 
     return 0;
 }
@@ -1371,7 +1374,7 @@ static int matroska_read_header(AVFormat
     index_list = &matroska->index;
     index = index_list->elem;
     if (index_list->nb_elem
-        && index[0].time > 100000000000000/matroska->time_scale) {
+        && index[0].time > 100000000000000ULL/matroska->time_scale) {
         av_log(matroska->ctx, AV_LOG_WARNING, "Working around broken index.\n");
         index_scale = matroska->time_scale;
     }
@@ -1685,7 +1688,7 @@ static int matroska_parse_cluster(Matros
     blocks_list = &cluster.blocks;
     blocks = blocks_list->elem;
     for (i=0; i<blocks_list->nb_elem; i++)
-        if (blocks[i].bin.size > 0)
+        if (blocks[i].bin.data != NULL /* Netgem */ && blocks[i].bin.size > 0)
             res=matroska_parse_block(matroska,
                                      blocks[i].bin.data, blocks[i].bin.size,
                                      blocks[i].bin.pos,  cluster.timecode,
@@ -1742,7 +1745,7 @@ static int matroska_read_seek(AVFormatCo
             index_sub = av_index_search_timestamp(tracks[i].stream, st->index_entries[index].timestamp, AVSEEK_FLAG_BACKWARD);
             if (index_sub >= 0
                 && st->index_entries[index_sub].pos < st->index_entries[index_min].pos
-                && st->index_entries[index].timestamp - st->index_entries[index_sub].timestamp < 30000000000/matroska->time_scale)
+                && st->index_entries[index].timestamp - st->index_entries[index_sub].timestamp < 30000000000ULL/matroska->time_scale)
                 index_min = index_sub;
         }
     }
Only in ./libavformat: matroskadec.d
Only in ./libavformat: matroskadec.o
Only in ./libavformat: matroskaenc.d
Only in ./libavformat: matroskaenc.o
Only in ./libavformat: matroska.o
Only in ./libavformat: metadata_compat.d
Only in ./libavformat: metadata_compat.o
Only in ./libavformat: metadata.d
Only in ./libavformat: metadata.o
Only in ./libavformat: mm.d
Only in ./libavformat: mmf.d
Only in ./libavformat: mmf.o
Only in ./libavformat: mm.o
diff -ruwp ./libavformat/mov.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/mov.c
--- ./libavformat/mov.c	2009-02-21 10:54:27.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/mov.c	2009-01-08 09:00:00.000000000 +0100
@@ -242,8 +242,10 @@ static int mov_read_dref(MOVContext *c,
     entries = get_be32(pb);
     if (entries >= UINT_MAX / sizeof(*sc->drefs))
         return -1;
-    sc->drefs_count = entries;
     sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));
+    if (!sc->drefs) /* Netgem */
+        return AVERROR(ENOMEM); /* Netgem */
+    sc->drefs_count = entries; /* Netgem: after alloc */
 
     for (i = 0; i < sc->drefs_count; i++) {
         MOV_dref_t *dref = &sc->drefs[i];
@@ -657,10 +659,10 @@ static int mov_read_stco(MOVContext *c,
     if(entries >= UINT_MAX/sizeof(int64_t))
         return -1;
 
-    sc->chunk_count = entries;
     sc->chunk_offsets = av_malloc(entries * sizeof(int64_t));
     if (!sc->chunk_offsets)
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
+    sc->chunk_count = entries; /* Netgem: after alloc */
     if      (atom.type == MKTAG('s','t','c','o'))
         for(i=0; i<entries; i++)
             sc->chunk_offsets[i] = get_be32(pb);
@@ -1035,10 +1037,10 @@ static int mov_read_stsc(MOVContext *c,
 
     dprintf(c->fc, "track[%i].stsc.entries = %i\n", c->fc->nb_streams-1, entries);
 
-    sc->sample_to_chunk_sz = entries;
     sc->sample_to_chunk = av_malloc(entries * sizeof(MOV_stsc_t));
     if (!sc->sample_to_chunk)
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
+    sc->sample_to_chunk_sz = entries; /* Netgem: after alloc */
     for(i=0; i<entries; i++) {
         sc->sample_to_chunk[i].first = get_be32(pb);
         sc->sample_to_chunk[i].count = get_be32(pb);
@@ -1061,13 +1063,11 @@ static int mov_read_stss(MOVContext *c,
     if(entries >= UINT_MAX / sizeof(int))
         return -1;
 
-    sc->keyframe_count = entries;
-
-    dprintf(c->fc, "keyframe_count = %d\n", sc->keyframe_count);
-
     sc->keyframes = av_malloc(entries * sizeof(int));
     if (!sc->keyframes)
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
+    sc->keyframe_count = entries; /* Netgem: after alloc */
+    dprintf(c->fc, "keyframe_count = %d\n", sc->keyframe_count);
     for(i=0; i<entries; i++) {
         sc->keyframes[i] = get_be32(pb);
         //dprintf(c->fc, "keyframes[]=%d\n", sc->keyframes[i]);
@@ -1099,7 +1099,7 @@ static int mov_read_stsz(MOVContext *c,
 
     sc->sample_sizes = av_malloc(entries * sizeof(int));
     if (!sc->sample_sizes)
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
     for(i=0; i<entries; i++)
         sc->sample_sizes[i] = get_be32(pb);
     return 0;
@@ -1119,10 +1119,10 @@ static int mov_read_stts(MOVContext *c,
     if(entries >= UINT_MAX / sizeof(MOV_stts_t))
         return -1;
 
-    sc->stts_count = entries;
     sc->stts_data = av_malloc(entries * sizeof(MOV_stts_t));
     if (!sc->stts_data)
         return -1;
+    sc->stts_count = entries; /* Netgem: after alloc */
     dprintf(c->fc, "track[%i].stts.entries = %i\n", c->fc->nb_streams-1, entries);
 
     sc->time_rate=0;
@@ -1162,10 +1162,10 @@ static int mov_read_ctts(MOVContext *c,
     if(entries >= UINT_MAX / sizeof(MOV_stts_t))
         return -1;
 
-    sc->ctts_count = entries;
     sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));
     if (!sc->ctts_data)
         return -1;
+    sc->ctts_count = entries; /* Netgem: after alloc */
     dprintf(c->fc, "track[%i].ctts.entries = %i\n", c->fc->nb_streams-1, entries);
 
     for(i=0; i<entries; i++) {
@@ -1543,9 +1543,10 @@ static int mov_read_trex(MOVContext *c,
 
     if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))
         return -1;
-    c->trex_data = av_realloc(c->trex_data, (c->trex_count+1)*sizeof(*c->trex_data));
-    if (!c->trex_data)
+    trex = av_realloc(c->trex_data, (c->trex_count+1)*sizeof(*c->trex_data));
+    if (!trex)
         return AVERROR(ENOMEM);
+    c->trex_data = trex; /* Netgem */
     trex = &c->trex_data[c->trex_count++];
     get_byte(pb); /* version */
     get_be24(pb); /* flags */
@@ -1581,12 +1582,14 @@ static int mov_read_trun(MOVContext *c,
     if (flags & 0x001) data_offset        = get_be32(pb);
     if (flags & 0x004) first_sample_flags = get_be32(pb);
     if (flags & 0x800) {
+        MOV_stts_t *ctts_data; /* Netgem */
         if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))
             return -1;
-        sc->ctts_data = av_realloc(sc->ctts_data,
+        ctts_data = av_realloc(sc->ctts_data,
                                    (entries+sc->ctts_count)*sizeof(*sc->ctts_data));
-        if (!sc->ctts_data)
+        if (!ctts_data)
             return AVERROR(ENOMEM);
+        sc->ctts_data = ctts_data; /* Netgem */
     }
     dts = st->duration;
     offset = frag->base_data_offset + data_offset;
@@ -1673,11 +1676,11 @@ static int mov_read_cmov(MOVContext *c,
 
     cmov_data = av_malloc(cmov_len);
     if (!cmov_data)
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
     moov_data = av_malloc(moov_len);
     if (!moov_data) {
         av_free(cmov_data);
-        return -1;
+        return AVERROR(ENOMEM); /* Netgem */
     }
     get_buffer(pb, cmov_data, cmov_len);
     if(uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)
@@ -1724,6 +1727,55 @@ static int mov_read_elst(MOVContext *c,
     return 0;
 }
 
+/* Netgem: mov redirection */
+static int mov_read_rdrf(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
+{
+    int len;
+
+    if (atom.size < 12) {
+        url_fskip(pb, atom.size);
+        return 0; /* continue */
+    }
+    if (get_be32(pb) != 0) { /* 0 sized url atom... use the 'wide' atom size */
+        url_fskip(pb, atom.size - 4);
+        return 0;
+    }
+    atom.type = get_le32(pb);
+    atom.offset += 8;
+    atom.size -= 8;
+    if (atom.type != MKTAG('u', 'r', 'l', ' ')) {
+        url_fskip(pb, atom.size);
+        return 0;
+    }
+
+    len = get_be32(pb); /* url len */
+    atom.offset += 4;
+    atom.size -= 4;
+    if (len > atom.size) {
+        url_fskip(pb, atom.size);
+        av_log(c->fc, AV_LOG_WARNING, "invalid url length\n");
+        return 0;
+    }
+
+    if (c->fc->event_report) {
+        char *reference;
+        reference = av_mallocz(len+1);
+        if (!reference)
+            return AVERROR(ENOMEM); /* Netgem */
+        get_buffer(pb, reference, len);
+        atom.offset += len;
+        atom.size -= len;
+        c->fc->event_report(c->fc->callback_priv_data,
+                            AVFMT_EVENT_REDIRECT,
+                            reference);
+        av_free(reference);
+    }
+
+    url_fskip(pb, atom.size);
+    return 0;
+}
+/* End Netgem */
+
 static const MOVParseTableEntry mov_default_parse_table[] = {
 { MKTAG('a','v','s','s'), mov_read_extradata },
 { MKTAG('c','o','6','4'), mov_read_stco },
@@ -1770,6 +1822,11 @@ static const MOVParseTableEntry mov_defa
 { MKTAG('e','s','d','s'), mov_read_esds },
 { MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */
 { MKTAG('c','m','o','v'), mov_read_cmov },
+/* Netgem: mov redirection */
+{ MKTAG('r','m','r','a'), mov_read_default },
+{ MKTAG('r','m','d','a'), mov_read_default },
+{ MKTAG('r','d','r','f'), mov_read_rdrf },
+/* End Netgem */
 { MKTAG(0xa9,'n','a','m'), mov_read_udta_string },
 { MKTAG(0xa9,'w','r','t'), mov_read_udta_string },
 { MKTAG(0xa9,'c','p','y'), mov_read_udta_string },
@@ -1861,6 +1918,7 @@ static int mov_read_packet(AVFormatConte
     AVIndexEntry *sample = 0;
     int64_t best_dts = INT64_MAX;
     int i;
+    int err; /* Netgem */
  retry:
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
@@ -1871,7 +1929,9 @@ static int mov_read_packet(AVFormatConte
                                      AV_TIME_BASE, msc->time_scale);
             dprintf(s, "stream %d, sample %d, dts %"PRId64"\n", i, msc->current_sample, dts);
             if (!sample || (url_is_streamed(s->pb) && current_sample->pos < sample->pos) ||
+                ((s->flags & AVFMT_FLAG_SEEKLESS) && current_sample->pos < sample->pos) || /* Netgem: do not seek if possible! */
                 (!url_is_streamed(s->pb) &&
+                 !(s->flags & AVFMT_FLAG_SEEKLESS) && /* Netgem: do not seek if possible! */
                  ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&
                  ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||
                   (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {
@@ -1897,7 +1957,9 @@ static int mov_read_packet(AVFormatConte
                sc->ffindex, sample->pos);
         return -1;
     }
-    av_get_packet(sc->pb, pkt, sample->size);
+    err = av_get_packet(sc->pb, pkt, sample->size);
+    if (err < 0) /* Netgem */
+        return err; /* Netgem */
 #ifdef CONFIG_DV_DEMUXER
     if (mov->dv_demux && sc->dv_audio_container) {
         dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size);
Only in ./libavformat: mov.d
Only in ./libavformat: movenc.d
Only in ./libavformat: movenc.o
Only in ./libavformat: mov.o
Only in ./libavformat: mp3.d
Only in ./libavformat: mp3.o
Only in ./libavformat: mpc8.d
Only in ./libavformat: mpc8.o
Only in ./libavformat: mpc.d
Only in ./libavformat: mpc.o
Only in ./libavformat: mpeg.d
Only in ./libavformat: mpegenc.d
Only in ./libavformat: mpegenc.o
Only in ./libavformat: mpeg.o
diff -ruwp ./libavformat/mpegts.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/mpegts.c
--- ./libavformat/mpegts.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/mpegts.c	2009-01-08 09:00:00.000000000 +0100
@@ -48,7 +48,7 @@ enum MpegTSFilterType {
 
 typedef struct MpegTSFilter MpegTSFilter;
 
-typedef void PESCallback(MpegTSFilter *f, const uint8_t *buf, int len, int is_start);
+typedef int PESCallback(MpegTSFilter *f, const uint8_t *buf, int len, int is_start);
 
 typedef struct MpegTSPESFilter {
     PESCallback *pes_cb;
@@ -809,7 +809,7 @@ static int64_t get_pts(const uint8_t *p)
 }
 
 /* return non zero if a packet could be constructed */
-static void mpegts_push_data(MpegTSFilter *filter,
+static int mpegts_push_data(MpegTSFilter *filter,
                              const uint8_t *buf, int buf_size, int is_start)
 {
     PESContext *pes = filter->u.pes_filter.opaque;
@@ -818,7 +818,7 @@ static void mpegts_push_data(MpegTSFilte
     int len, code;
 
     if(!ts->pkt)
-        return;
+        return 0;
 
     if (is_start) {
         pes->state = MPEGTS_HEADER;
@@ -910,7 +910,9 @@ static void mpegts_push_data(MpegTSFilte
             }
             if (len > 0) {
                 AVPacket *pkt = ts->pkt;
-                if (pes->st && av_new_packet(pkt, len) == 0) {
+                if (pes->st) {
+                    if (av_new_packet(pkt, len) != 0)
+                        return AVERROR(ENOMEM); /* Netgem: memory management */
                     memcpy(pkt->data, p, len);
                     pkt->stream_index = pes->st->index;
                     pkt->pts = pes->pts;
@@ -919,7 +921,7 @@ static void mpegts_push_data(MpegTSFilte
                     pes->pts = AV_NOPTS_VALUE;
                     pes->dts = AV_NOPTS_VALUE;
                     ts->stop_parse = 1;
-                    return;
+                    return 0;
                 }
             }
             buf_size = 0;
@@ -929,6 +931,7 @@ static void mpegts_push_data(MpegTSFilte
             break;
         }
     }
+    return 0;
 }
 
 static AVStream* new_pes_av_stream(PESContext *pes, uint32_t code)
@@ -1030,7 +1033,7 @@ static PESContext *add_pes_stream(MpegTS
 }
 
 /* handle one TS packet */
-static void handle_packet(MpegTSContext *ts, const uint8_t *packet)
+static int handle_packet(MpegTSContext *ts, const uint8_t *packet)
 {
     AVFormatContext *s = ts->stream;
     MpegTSFilter *tss;
@@ -1039,15 +1042,22 @@ static void handle_packet(MpegTSContext
 
     pid = AV_RB16(packet + 1) & 0x1fff;
     if(pid && discard_pid(ts, pid))
-        return;
+        return 0;
     is_start = packet[1] & 0x40;
     tss = ts->pids[pid];
     if (ts->auto_guess && tss == NULL && is_start) {
+        PESContext *pes = /* Netgem: Memory leak */
         add_pes_stream(ts, pid, -1, 0);
+
+        /* Netgem: add a fake stream to give a chance to free pes at the end */
+        if (pes)
+            new_pes_av_stream(pes, 0);
+        /* End Netgem */
+
         tss = ts->pids[pid];
     }
     if (!tss)
-        return;
+        return 0;
 
     /* continuity check (currently not used) */
     cc = (packet[3] & 0xf);
@@ -1058,9 +1068,9 @@ static void handle_packet(MpegTSContext
     afc = (packet[3] >> 4) & 3;
     p = packet + 4;
     if (afc == 0) /* reserved value */
-        return;
+        return 0;
     if (afc == 2) /* adaptation field only */
-        return;
+        return 0;
     if (afc == 3) {
         /* skip adapation field */
         p += p[0] + 1;
@@ -1068,7 +1078,7 @@ static void handle_packet(MpegTSContext
     /* if past the end of packet, ignore */
     p_end = packet + TS_PACKET_SIZE;
     if (p >= p_end)
-        return;
+        return 0;
 
     ts->pos47= url_ftell(ts->stream->pb) % ts->raw_packet_size;
 
@@ -1077,14 +1087,14 @@ static void handle_packet(MpegTSContext
             /* pointer field present */
             len = *p++;
             if (p + len > p_end)
-                return;
+                return 0;
             if (len && cc_ok) {
                 /* write remaining section bytes */
                 write_section_data(s, tss,
                                    p, len, 0);
                 /* check whether filter has been closed */
                 if (!ts->pids[pid])
-                    return;
+                    return 0;
             }
             p += len;
             if (p < p_end) {
@@ -1098,9 +1108,13 @@ static void handle_packet(MpegTSContext
             }
         }
     } else {
+        int ret = /* Netgem: memory management */
         tss->u.pes_filter.pes_cb(tss,
                                  p, p_end - p, is_start);
+        if (ret != 0)
+            return ret;
     }
+    return 0;
 }
 
 /* XXX: try to find a better synchro over several packets (use
@@ -1167,7 +1181,10 @@ static int handle_packets(MpegTSContext
         ret = read_packet(pb, packet, ts->raw_packet_size);
         if (ret != 0)
             return ret;
+        ret = /* Netgem: memory management */
         handle_packet(ts, packet);
+        if (ret != 0) /* Netgem: memory management */
+            return ret; /* Netgem: memory management */
     }
     return 0;
 }
@@ -1238,6 +1255,7 @@ static int mpegts_read_header(AVFormatCo
     uint8_t buf[1024];
     int len;
     int64_t pos;
+    int ret;
 
     if (ap) {
         ts->mpeg2ts_compute_pcr = ap->mpeg2ts_compute_pcr;
@@ -1267,7 +1285,10 @@ static int mpegts_read_header(AVFormatCo
 
         mpegts_set_service(ts);
 
+        ret = /* Netgem: memory management */
         handle_packets(ts, s->probesize);
+        if (ret != 0) /* Netgem: memory management */
+            goto fail; /* Netgem: memory management */
         /* if could not find service, enable auto_guess */
 
         ts->auto_guess = 1;
@@ -1498,7 +1519,10 @@ int mpegts_parse_packet(MpegTSContext *t
             buf++;
             len--;
         } else {
+            int ret = /* Netgem: memory management */
             handle_packet(ts, buf);
+            if (ret != 0) /* Netgem: memory management */
+                return ret; /* Netgem: memory management */
             buf += TS_PACKET_SIZE;
             len -= TS_PACKET_SIZE;
         }
Only in ./libavformat: mpegts.d
Only in ./libavformat: mpegtsenc.d
Only in ./libavformat: mpegtsenc.o
Only in ./libavformat: mpegts.o
Only in ./libavformat: mpjpeg.d
Only in ./libavformat: mpjpeg.o
Only in ./libavformat: msnwc_tcp.d
Only in ./libavformat: msnwc_tcp.o
Only in ./libavformat: mtv.d
Only in ./libavformat: mtv.o
Only in ./libavformat: mvi.d
Only in ./libavformat: mvi.o
Only in ./libavformat: mxf.d
Only in ./libavformat: mxfdec.d
Only in ./libavformat: mxfdec.o
Only in ./libavformat: mxfenc.d
Only in ./libavformat: mxfenc.o
Only in ./libavformat: mxf.o
Only in ./libavformat: ncdec.d
Only in ./libavformat: ncdec.o
Only in ./libavformat: nsvdec.d
Only in ./libavformat: nsvdec.o
Only in ./libavformat: nut.d
Only in ./libavformat: nutdec.d
Only in ./libavformat: nutdec.o
Only in ./libavformat: nutenc.d
Only in ./libavformat: nutenc.o
Only in ./libavformat: nut.o
Only in ./libavformat: nuv.d
Only in ./libavformat: nuv.o
diff -ruwp ./libavformat/oggdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggdec.c
--- ./libavformat/oggdec.c	2009-02-21 10:46:43.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -512,6 +512,7 @@ ogg_read_packet (AVFormatContext * s, AV
     if (av_new_packet (pkt, psize) < 0)
         return AVERROR(EIO);
     pkt->stream_index = idx;
+    pkt->duration = os->duration; /* Netgem: subtitle support */
     memcpy (pkt->data, os->buf + pstart, psize);
     if (os->lastgp != -1LL){
         pkt->pts = ogg_gptopts (s, idx, os->lastgp);
@@ -528,10 +529,16 @@ static int
 ogg_read_close (AVFormatContext * s)
 {
     struct ogg *ogg = s->priv_data;
+    struct ogg_stream *os; /* Netgem */
     int i;
 
     for (i = 0; i < ogg->nstreams; i++){
         av_free (ogg->streams[i].buf);
+        /* Netgem: memory leak */
+        os = ogg->streams + i;
+        if (os->codec && os->codec->trailer)
+            os->codec->trailer(s, i);
+        /* End Netgem */
         av_free (ogg->streams[i].private);
     }
     av_free (ogg->streams);
Only in ./libavformat: oggdec.c.orig
Only in ./libavformat: oggdec.c.rej
Only in ./libavformat: oggdec.d
diff -ruwp ./libavformat/oggdec.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggdec.h
--- ./libavformat/oggdec.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggdec.h	2009-01-08 09:00:00.000000000 +0100
@@ -34,6 +34,7 @@ struct ogg_codec {
     int (*header)(AVFormatContext *, int);
     int (*packet)(AVFormatContext *, int);
     uint64_t (*gptopts)(AVFormatContext *, int, uint64_t);
+    void (*trailer)(AVFormatContext *, int); /* Netgem: memory leak */
 };
 
 struct ogg_stream {
@@ -47,11 +48,12 @@ struct ogg_stream {
     uint32_t seq;
     uint64_t granule, lastgp;
     int flags;
-    struct ogg_codec *codec;
+    const struct ogg_codec *codec;
     int header;
     int nsegs, segp;
     uint8_t segments[255];
     void *private;
+    int duration; /* Netgem: subtitle support */
 };
 
 struct ogg_state {
Only in ./libavformat: oggdec.o
Only in ./libavformat: oggenc.d
Only in ./libavformat: oggenc.o
Only in ./libavformat: oggparseflac.d
Only in ./libavformat: oggparseflac.o
diff -ruwp ./libavformat/oggparseogm.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggparseogm.c
--- ./libavformat/oggparseogm.c	2008-12-18 22:24:43.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggparseogm.c	2009-01-08 09:00:00.000000000 +0100
@@ -138,11 +138,20 @@ ogm_packet(AVFormatContext *s, int idx)
     struct ogg_stream *os = ogg->streams + idx;
     uint8_t *p = os->buf + os->pstart;
     int lb;
+    int i;
 
     if(*p & 8)
         os->pflags |= PKT_FLAG_KEY;
 
     lb = ((*p & 2) << 1) | ((*p >> 6) & 3);
+
+    /* Netgem: subtitle support */
+    for(i=0, os->duration=0 ; i<lb ; i++) {
+        os->duration <<= 8;
+        os->duration += *(p + lb - i);
+    }
+    /* End Netgem */
+
     os->pstart += lb + 1;
     os->psize -= lb + 1;
 
Only in ./libavformat: oggparseogm.d
Only in ./libavformat: oggparseogm.o
Only in ./libavformat: oggparsespeex.d
Only in ./libavformat: oggparsespeex.o
Only in ./libavformat: oggparsetheora.d
Only in ./libavformat: oggparsetheora.o
diff -ruwp ./libavformat/oggparsevorbis.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggparsevorbis.c
--- ./libavformat/oggparsevorbis.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/oggparsevorbis.c	2009-01-08 09:00:00.000000000 +0100
@@ -174,6 +174,8 @@ vorbis_header (AVFormatContext * s, int
     priv = os->private;
     priv->len[os->seq] = os->psize;
     priv->packet[os->seq] = av_mallocz(os->psize);
+    if (!priv->packet[os->seq]) /* Netgem */
+        return -1;
     memcpy(priv->packet[os->seq], os->buf + os->pstart, os->psize);
     if (os->buf[os->pstart] == 1) {
         const uint8_t *p = os->buf + os->pstart + 7; /* skip "\001vorbis" tag */
@@ -219,8 +221,23 @@ vorbis_header (AVFormatContext * s, int
     return os->seq < 3;
 }
 
+/* Netgem: memory leak */
+void vorbis_trailer(AVFormatContext * s, int idx)
+{
+    struct ogg *ogg = s->priv_data;
+    struct ogg_stream *os = ogg->streams + idx;
+    struct oggvorbis_private *priv = os->private;
+    int i;
+
+    for (i=0 ; i<3 ; i++) {
+        av_freep(&priv->packet[i]);
+    }
+}
+/* End Netgem */
+
 const struct ogg_codec ff_vorbis_codec = {
     .magic = "\001vorbis",
     .magicsize = 7,
-    .header = vorbis_header
+    .header = vorbis_header,
+    .trailer = vorbis_trailer, /* Netgem: memory leak */
 };
Only in ./libavformat: oggparsevorbis.d
Only in ./libavformat: oggparsevorbis.o
Only in ./libavformat: oma.d
Only in ./libavformat: oma.o
Only in ./libavformat: options.d
Only in ./libavformat: options.o
Only in ./libavformat: os_support.d
Only in ./libavformat: os_support.o
Only in ./libavformat: psxstr.d
Only in ./libavformat: psxstr.o
Only in ./libavformat: pva.d
Only in ./libavformat: pva.o
Only in ./libavformat: r3d.d
Only in ./libavformat: r3d.o
diff -ruwp ./libavformat/raw.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/raw.c
--- ./libavformat/raw.c	2009-02-21 10:54:27.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/raw.c	2009-01-08 09:00:00.000000000 +0100
@@ -27,6 +27,7 @@
 #include "avformat.h"
 #include "raw.h"
 
+
 /* simple formats */
 #ifdef CONFIG_FLAC_MUXER
 static int flac_write_header(struct AVFormatContext *s)
Only in ./libavformat: raw.d
Only in ./libavformat: raw.o
diff -ruwp ./libavformat/rdt.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rdt.c
--- ./libavformat/rdt.c	2009-02-21 10:58:34.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rdt.c	2009-01-08 09:00:00.000000000 +0100
@@ -284,14 +284,17 @@ rdt_parse_packet (PayloadContext *rdt, A
     int seq = 1, res;
     ByteIOContext pb;
     RMContext *rm = rdt->rmctx->priv_data;
+    int64_t timestamp2; /* Netgem */
 
     if (rm->audio_pkt_cnt == 0) {
         int pos;
 
         init_put_byte(&pb, buf, len, 0, NULL, NULL, NULL, NULL);
         flags = (flags & PKT_FLAG_KEY) ? 2 : 0;
+        timestamp2 = *timestamp; /* Netgem */
         res = ff_rm_parse_packet (rdt->rmctx, &pb, st, len, pkt,
-                                  &seq, &flags, timestamp);
+                                  &seq, &flags, &timestamp2);
+        *timestamp = timestamp2; /* Netgem */
         pos = url_ftell(&pb);
         if (res < 0)
             return res;
Only in ./libavformat: rdt.d
Only in ./libavformat: rdt.o
Only in ./libavformat: riff.d
Only in ./libavformat: riff.o
Only in ./libavformat: rl2.d
Only in ./libavformat: rl2.o
Only in ./libavformat: rm.d
diff -ruwp ./libavformat/rmdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rmdec.c
--- ./libavformat/rmdec.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rmdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -395,7 +395,7 @@ static int get_num(ByteIOContext *pb, in
 /* multiple of 20 bytes for ra144 (ugly) */
 #define RAW_PACKET_SIZE 1000
 
-static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){
+static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){
     RMContext *rm = s->priv_data;
     ByteIOContext *pb = s->pb;
     int len, num, res, i;
@@ -711,7 +711,7 @@ static int rm_read_packet(AVFormatContex
     } else {
         int seq=1;
 resync:
-        len=sync(s, &timestamp, &flags, &i, &pos);
+        len=rm_sync(s, &timestamp, &flags, &i, &pos);
         if(len<0)
             return AVERROR(EIO);
         st = s->streams[i];
@@ -766,7 +766,7 @@ static int64_t rm_read_dts(AVFormatConte
         int seq=1;
         AVStream *st;
 
-        len=sync(s, &dts, &flags, &stream_index2, &pos);
+        len=rm_sync(s, &dts, &flags, &stream_index2, &pos);
         if(len<0)
             return AV_NOPTS_VALUE;
 
Only in ./libavformat: rmdec.d
Only in ./libavformat: rmdec.o
Only in ./libavformat: rmenc.d
Only in ./libavformat: rmenc.o
Only in ./libavformat: rm.o
Only in ./libavformat: rpl.d
Only in ./libavformat: rpl.o
Only in ./libavformat: rtp_aac.d
Only in ./libavformat: rtp_aac.o
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_amr.c
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_amr.h
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_asf.c
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_asf.h
Only in ./libavformat: rtp.d
diff -ruwp ./libavformat/rtpdec.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtpdec.c
--- ./libavformat/rtpdec.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtpdec.c	2009-01-08 09:00:00.000000000 +0100
@@ -19,20 +19,25 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+//#define DEBUG
+
 /* needed for gethostname() */
 #define _XOPEN_SOURCE 600
 
 #include "libavcodec/bitstream.h"
 #include "avformat.h"
 #include "mpegts.h"
+#include "rtsp.h"
 
 #include <unistd.h>
 #include "network.h"
 
+#include "rtsp_internal.h"
 #include "rtp_internal.h"
 #include "rtp_h264.h"
-
-//#define DEBUG
+#include "rtp_asf.h" /* Netgem: rtsp asf support */
+#include "rtp_h263.h" /* Netgem: rtp h263 support */
+#include "rtp_amr.h" /* Netgem: rtp amr support */
 
 /* TODO: - add RTCP statistics reporting (should be optional).
 
@@ -43,11 +48,29 @@
          'url_open_dyn_packet_buf')
 */
 
+
+static int mpeg4_generic_parse_packet(PayloadContext *data,
+                                      AVStream *st,
+                                      AVPacket * pkt,
+                                      uint32_t * timestamp,
+                                      const uint8_t * buf,
+                                      int len, int flags);
+
+
 /* statistics functions */
 RTPDynamicProtocolHandler *RTPFirstDynamicPayloadHandler= NULL;
 
-static RTPDynamicProtocolHandler mp4v_es_handler= {"MP4V-ES", CODEC_TYPE_VIDEO, CODEC_ID_MPEG4};
-static RTPDynamicProtocolHandler mpeg4_generic_handler= {"mpeg4-generic", CODEC_TYPE_AUDIO, CODEC_ID_AAC};
+static RTPDynamicProtocolHandler mp4v_es_handler= {
+    "MP4V-ES",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEG4
+};
+static RTPDynamicProtocolHandler mpeg4_generic_handler= {
+    "mpeg4-generic",
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_AAC,
+    .parse_packet = mpeg4_generic_parse_packet
+};
 
 void ff_register_dynamic_payload_handler(RTPDynamicProtocolHandler *handler)
 {
@@ -60,6 +83,21 @@ void av_register_rtp_dynamic_payload_han
     ff_register_dynamic_payload_handler(&mp4v_es_handler);
     ff_register_dynamic_payload_handler(&mpeg4_generic_handler);
     ff_register_dynamic_payload_handler(&ff_h264_dynamic_handler);
+
+    /* Netgem: rtsp asf support */
+    ff_register_dynamic_payload_handler(&ff_asfvideo_dynamic_handler);
+    ff_register_dynamic_payload_handler(&ff_asfaudio_dynamic_handler);
+    /* End Netgem */
+
+    /* Netgem: rtp h263 support */
+    ff_register_dynamic_payload_handler(&ff_h263_1998_dynamic_handler);
+    //ff_register_dynamic_payload_handler(&ff_h263_2000_dynamic_handler);
+    /* End Netgem */
+
+    /* Netgem: rtp amr support */
+    ff_register_dynamic_payload_handler(&ff_amrnb_dynamic_handler);
+    ff_register_dynamic_payload_handler(&ff_amrwb_dynamic_handler);
+    /* End Netgem */
 }
 
 static int rtcp_parse_packet(RTPDemuxContext *s, const unsigned char *buf, int len)
@@ -288,7 +326,7 @@ RTPDemuxContext *rtp_parse_open(AVFormat
             return NULL;
         }
     } else {
-        av_set_pts_info(st, 32, 1, 90000);
+/* Netgem        av_set_pts_info(st, 32, 1, 90000); */
         switch(st->codec->codec_id) {
         case CODEC_ID_MPEG1VIDEO:
         case CODEC_ID_MPEG2VIDEO:
@@ -299,9 +337,9 @@ RTPDemuxContext *rtp_parse_open(AVFormat
             st->need_parsing = AVSTREAM_PARSE_FULL;
             break;
         default:
-            if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
-                av_set_pts_info(st, 32, 1, st->codec->sample_rate);
-            }
+/* Netgem            if (st->codec->codec_type == CODEC_TYPE_AUDIO) { */
+/* Netgem                av_set_pts_info(st, 32, 1, st->codec->sample_rate); */
+/* Netgem            } */
             break;
         }
     }
@@ -344,44 +382,150 @@ static int rtp_parse_mp4_au(RTPDemuxCont
 
     init_get_bits(&getbitcontext, buf, infos->au_headers_length_bytes * 8);
 
-    /* XXX: Wrong if optionnal additional sections are present (cts, dts etc...) */
-    au_header_size = infos->sizelength + infos->indexlength;
-    if (au_header_size <= 0 || (au_headers_length % au_header_size != 0))
-        return -1;
+    infos->nb_au_headers = 0;
+    au_header_size = 0;
+
+    while (au_header_size < au_headers_length) {
+        struct AUHeaders *h;
+
+        i = infos->nb_au_headers;
+        infos->nb_au_headers++;
+        infos->au_headers = av_fast_realloc(infos->au_headers, &infos->au_headers_size,
+                                            infos->nb_au_headers * sizeof(struct AUHeaders));
+        h = &infos->au_headers[i];
+        memset(h, 0, sizeof(struct AUHeaders));
 
-    infos->nb_au_headers = au_headers_length / au_header_size;
-    infos->au_headers = av_malloc(sizeof(struct AUHeaders) * infos->nb_au_headers);
+        /* size */
+        h->size = get_bits_long(&getbitcontext, infos->sizelength);
+        au_header_size += infos->sizelength;
 
-    /* XXX: We handle multiple AU Section as only one (need to fix this for interleaving)
-       In my test, the FAAD decoder does not behave correctly when sending each AU one by one
-       but does when sending the whole as one big packet...  */
-    infos->au_headers[0].size = 0;
-    infos->au_headers[0].index = 0;
-    for (i = 0; i < infos->nb_au_headers; ++i) {
-        infos->au_headers[0].size += get_bits_long(&getbitcontext, infos->sizelength);
-        infos->au_headers[0].index = get_bits_long(&getbitcontext, infos->indexlength);
+        /* index */
+        if (i == 0) {
+            h->index = get_bits_long(&getbitcontext, infos->indexlength);
+            au_header_size += infos->indexlength;
+        }
+        else {
+            h->index = infos->au_headers[i-1].index +
+                get_bits_long(&getbitcontext, infos->indexdeltalength) + 1;
+            au_header_size += infos->indexdeltalength;
     }
 
-    infos->nb_au_headers = 1;
+        /* CTS */
+        if (infos->ctsdeltalength) {
+            h->cts_flag = get_bits_long(&getbitcontext, 1);
+            au_header_size += 1;
+        }
+        if (h->cts_flag) {
+            h->cts = get_bits_long(&getbitcontext, infos->ctsdeltalength);
+            au_header_size += infos->ctsdeltalength;
+        }
+
+        /* DTS */
+        if (infos->dtsdeltalength) {
+            h->dts_flag = get_bits_long(&getbitcontext, 1);
+            au_header_size += 1;
+        }
+        if (h->dts_flag) {
+            h->dts = get_bits_long(&getbitcontext, infos->dtsdeltalength);
+            au_header_size += infos->dtsdeltalength;
+        }
+
+        /* RAP */
+        if (infos->randomaccessindication) {
+            h->rap_flag = get_bits_long(&getbitcontext, 1);
+            au_header_size += 1;
+        }
+
+        /* Stream state */
+        if (infos->streamstateindication) {
+            h->streamstate = get_bits_long(&getbitcontext, infos->streamstateindication);
+            au_header_size += infos->streamstateindication;
+        }
+
+        dprintf(NULL, "rtp_parse_mp4_au i=%d size=%d index=%d cts=%d dts=%d rap=%d state=%d\n", i, 
+                h->size, h->index, h->cts, h->dts, h->rap_flag, h->streamstate);
+    }
+
+    /* TODO: Auxiliary section */
 
     return 0;
 }
 
+
+/* Netgem */
+// return 0 on packet, no more left, 1 on packet, 1 on partial packet...
+static int mpeg4_generic_parse_packet(PayloadContext *data,
+                                      AVStream *st,
+                                      AVPacket * pkt,
+                                      uint32_t * timestamp,
+                                      const uint8_t * buf,
+                                      int len, int flags)
+{
+    RTSPStream *rtsp_st = st->priv_data;
+    RTPDemuxContext *rtp_ctx = rtsp_st->tx_ctx;
+    rtp_payload_data_t *infos = &rtsp_st->rtp_payload_data;
+    int rv;
+
+    if (!buf) {
+        buf = rtp_ctx->buf + rtp_ctx->read_buf_index;
+    }
+    else {
+        if (rtp_parse_mp4_au(rtp_ctx, buf))
+            return -1;
+        buf += infos->au_headers_length_bytes + 2;
+        len -= infos->au_headers_length_bytes + 2;
+
+        memcpy(rtp_ctx->buf, buf, len);
+        rtp_ctx->read_buf_size = len;
+        rtp_ctx->read_buf_index = 0;
+        infos->cur_au_index = 0;
+    }
+
+    len = FFMIN(infos->au_headers[infos->cur_au_index].size,
+                rtp_ctx->read_buf_size - rtp_ctx->read_buf_index);
+    av_new_packet(pkt, len);
+    memcpy(pkt->data, buf, len);
+    rtp_ctx->read_buf_index += len;
+
+    /* an AAC frame stores 1024 samples wathever its sample rate */
+    *timestamp = rtp_ctx->cur_timestamp + (1024 * infos->cur_au_index);
+
+    infos->cur_au_index++;
+    if (infos->cur_au_index < infos->nb_au_headers &&
+        rtp_ctx->read_buf_index < rtp_ctx->read_buf_size) {
+        rv= 1;
+    }
+    else {
+        rv= 0;
+    }
+
+    dprintf(NULL, "mpeg4_generic_parse_packet index=%d size=%d ret=%d\n",
+            infos->cur_au_index-1, pkt->size, rv);
+
+    return rv;
+}
+/* End Netgem */
+
 /**
  * This was the second switch in rtp_parse packet.  Normalizes time, if required, sets stream_index, etc.
  */
 static void finalize_packet(RTPDemuxContext *s, AVPacket *pkt, uint32_t timestamp)
 {
+#if 0 /* Netgem: use timestamp directly */
     if (s->last_rtcp_ntp_time != AV_NOPTS_VALUE) {
         int64_t addend;
         int delta_timestamp;
 
         /* compute pts from timestamp with received ntp_time */
         delta_timestamp = timestamp - s->last_rtcp_timestamp;
+        delta_timestamp += s->base_timestamp; /* Netgem: is this correct? we don't care, our method is different */
         /* convert to the PTS timebase */
         addend = av_rescale(s->last_rtcp_ntp_time - s->first_rtcp_ntp_time, s->st->time_base.den, (uint64_t)s->st->time_base.num << 32);
         pkt->pts = addend + delta_timestamp;
     }
+#else /* Netgem */
+    pkt->pts = timestamp; /* Netgem */
+#endif /* Netgem */
     pkt->stream_index = s->st->index;
 }
 
@@ -443,6 +587,26 @@ int rtp_parse_packet(RTPDemuxContext *s,
     /* store the ssrc in the RTPDemuxContext */
     s->ssrc = ssrc;
 
+    /* Netgem: random first timestamp */
+    if (!s->base_initialized) {
+        s->base_timestamp = timestamp;
+        s->base_initialized = 1;
+    }
+    if (!s->seq_initialized) {
+        rtp_init_sequence(&s->statistics, s->seq);
+        s->seq_initialized = 1;
+    }
+    if (timestamp > s->base_timestamp)
+        s->cur_timestamp = timestamp - s->base_timestamp;
+    else
+        s->cur_timestamp = 0;
+
+    dprintf(NULL, "RTP: PT=%02x: cseq=%5d len=%5d base=%10u ts=%10u cur=%10u\n",
+            payload_type, seq, len, s->base_timestamp, timestamp, s->cur_timestamp);
+
+    timestamp = s->cur_timestamp;
+    /* End Netgem */
+
     /* NOTE: we can handle only one payload type */
     if (s->payload_type != payload_type)
         return -1;
@@ -474,6 +638,7 @@ int rtp_parse_packet(RTPDemuxContext *s,
     } else if (s->parse_packet) {
         rv = s->parse_packet(s->dynamic_protocol_context,
                              s->st, pkt, &timestamp, buf, len, flags);
+        finalize_packet(s, pkt, timestamp); /* Netgem */
     } else {
         // at this point, the RTP header has been stripped;  This is ASSUMING that there is only 1 CSRC, which in't wise.
         switch(st->codec->codec_id) {
@@ -505,29 +670,8 @@ int rtp_parse_packet(RTPDemuxContext *s,
             av_new_packet(pkt, len);
             memcpy(pkt->data, buf, len);
             break;
-            // moved from below, verbatim.  this is because this section handles packets, and the lower switch handles
-            // timestamps.
-            // TODO: Put this into a dynamic packet handler...
         case CODEC_ID_AAC:
-            if (rtp_parse_mp4_au(s, buf))
-                return -1;
-            {
-                rtp_payload_data_t *infos = s->rtp_payload_data;
-                if (infos == NULL)
-                    return -1;
-                buf += infos->au_headers_length_bytes + 2;
-                len -= infos->au_headers_length_bytes + 2;
-
-                /* XXX: Fixme we only handle the case where rtp_parse_mp4_au define
-                    one au_header */
-                av_new_packet(pkt, infos->au_headers[0].size);
-                memcpy(pkt->data, buf, infos->au_headers[0].size);
-                buf += infos->au_headers[0].size;
-                len -= infos->au_headers[0].size;
-            }
-            s->read_buf_size = len;
-            rv= 0;
-            break;
+            /* Moved to mpeg4_generic_handler() */
         default:
             av_new_packet(pkt, len);
             memcpy(pkt->data, buf, len);
Only in ./libavformat: rtpdec.d
Only in ./libavformat: rtpdec.o
Only in ./libavformat: rtpenc.d
Only in ./libavformat: rtpenc_h264.d
Only in ./libavformat: rtpenc_h264.o
Only in ./libavformat: rtpenc.o
diff -ruwp ./libavformat/rtp.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp.h
--- ./libavformat/rtp.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp.h	2009-01-08 09:00:00.000000000 +0100
@@ -69,6 +69,15 @@ typedef struct rtp_payload_data_s
     int sizelength;
     int indexlength;
     int indexdeltalength;
+
+    /* Netgem: better MP4-audio parsing */
+    int ctsdeltalength;
+    int dtsdeltalength;
+    int randomaccessindication;
+    int streamstateindication;
+    int auxiliarydatasizelength;
+    /* End Netgem */
+
     int profile_level_id;
     int streamtype;
     int objecttype;
@@ -85,6 +94,7 @@ typedef struct rtp_payload_data_s
         int rap_flag;
         int streamstate;
     } *au_headers;
+    int au_headers_size; /* Netgem: for fast_realloc(au_headers) */
     int nb_au_headers;
     int au_headers_length_bytes;
     int cur_au_index;
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_h263.c
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtp_h263.h
diff -ruwp ./libavformat/rtp_h264.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp_h264.c
--- ./libavformat/rtp_h264.c	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp_h264.c	2009-01-08 09:00:00.000000000 +0100
@@ -113,7 +113,7 @@ static void sdp_parse_fmtp_config_h264(A
             h264_data->level_idc = level_idc;
         }
     } else  if (!strcmp(attr, "sprop-parameter-sets")) {
-        uint8_t start_sequence[]= { 0, 0, 1 };
+        uint8_t start_sequence[]= { 0, 0, 0, 1 };
         codec->extradata_size= 0;
         codec->extradata= NULL;
 
@@ -154,7 +154,7 @@ static void sdp_parse_fmtp_config_h264(A
                 }
             }
         }
-        av_log(NULL, AV_LOG_DEBUG, "H.264/RTP Extradata set to %p (size: %d)!", codec->extradata, codec->extradata_size);
+        av_log(NULL, AV_LOG_DEBUG, "H.264/RTP Extradata set to %p (size: %d)\n", codec->extradata, codec->extradata_size);
     }
 }
 
@@ -169,7 +169,7 @@ static int h264_handle_packet(PayloadCon
     uint8_t nal = buf[0];
     uint8_t type = (nal & 0x1f);
     int result= 0;
-    uint8_t start_sequence[]= {0, 0, 1};
+    uint8_t start_sequence[]= {0, 0, 0, 1};
 
 #ifdef DEBUG
     assert(data);
@@ -356,25 +356,7 @@ static int parse_h264_sdp_line(AVStream
 
     assert(h264_data->cookie == MAGIC_COOKIE);
 
-    if (av_strstart(p, "framesize:", &p)) {
-        char buf1[50];
-        char *dst = buf1;
-
-        // remove the protocol identifier..
-        while (*p && *p == ' ') p++; // strip spaces.
-        while (*p && *p != ' ') p++; // eat protocol identifier
-        while (*p && *p == ' ') p++; // strip trailing spaces.
-        while (*p && *p != '-' && (buf1 - dst) < sizeof(buf1) - 1) {
-            *dst++ = *p++;
-        }
-        *dst = '\0';
-
-        // a='framesize:96 320-240'
-        // set our parameters..
-        codec->width = atoi(buf1);
-        codec->height = atoi(p + 1); // skip the -
-        codec->pix_fmt = PIX_FMT_YUV420P;
-    } else if (av_strstart(p, "fmtp:", &p)) {
+    if (av_strstart(p, "fmtp:", &p)) {
         char attr[256];
         char value[4096];
 
@@ -389,12 +371,8 @@ static int parse_h264_sdp_line(AVStream
             /* grab the codec extra_data from the config parameter of the fmtp line */
             sdp_parse_fmtp_config_h264(stream, h264_data, attr, value);
         }
-    } else if (av_strstart(p, "cliprect:", &p)) {
-        // could use this if we wanted.
     }
 
-    av_set_pts_info(stream, 33, 1, 90000);      // 33 should be right, because the pts is 64 bit? (done elsewhere; this is a one time thing)
-
     return 0;                   // keep processing it the normal way...
 }
 
Only in ./libavformat: rtp_h264.d
Only in ./libavformat: rtp_h264.o
diff -ruwp ./libavformat/rtp_internal.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp_internal.h
--- ./libavformat/rtp_internal.h	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtp_internal.h	2009-01-08 09:00:00.000000000 +0100
@@ -61,7 +61,7 @@ typedef int (*DynamicPayloadPacketHandle
 
 struct RTPDynamicProtocolHandler_s {
     // fields from AVRtpDynamicPayloadType_s
-    const char enc_name[50];    /* XXX: still why 50 ? ;-) */
+    const char *enc_name;
     enum CodecType codec_type;
     enum CodecID codec_id;
 
@@ -69,8 +69,8 @@ struct RTPDynamicProtocolHandler_s {
     int (*parse_sdp_a_line) (AVStream * stream,
                              PayloadContext *priv_data,
                              const char *line); ///< Parse the a= line from the sdp field
-    PayloadContext *(*open) (); ///< allocate any data needed by the rtp parsing for this dynamic data.
-    void (*close)(PayloadContext *protocol_data); ///< free any data needed by the rtp parsing for this dynamic data.
+    PayloadContext *(*rtp_open) (void); ///< allocate any data needed by the rtp parsing for this dynamic data.
+    void (*rtp_close)(PayloadContext *protocol_data); ///< free any data needed by the rtp parsing for this dynamic data.
     DynamicPayloadPacketHandlerProc parse_packet; ///< parse handler for this dynamic packet.
 
     struct RTPDynamicProtocolHandler_s *next;
@@ -83,8 +83,10 @@ struct RTPDemuxContext {
     int payload_type;
     uint32_t ssrc;
     uint16_t seq;
+    int seq_initialized; /* Netgem */
     uint32_t timestamp;
     uint32_t base_timestamp;
+    int base_initialized; /* Netgem */
     uint32_t cur_timestamp;
     int max_payload_size;
     struct MpegTSContext *ts;   /* only used for MP2T payloads */
Only in ./libavformat: rtp_mpv.d
Only in ./libavformat: rtp_mpv.o
Only in ./libavformat: rtp.o
Only in ./libavformat: rtpproto.d
Only in ./libavformat: rtpproto.o
diff -ruwp ./libavformat/rtsp.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtsp.c
--- ./libavformat/rtsp.c	2009-02-21 10:54:27.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtsp.c	2009-01-08 09:00:00.000000000 +0100
@@ -19,6 +19,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+//#define DEBUG
+//#define DEBUG_RTP_TCP
+
 /* needed by inet_aton() */
 #define _SVID_SOURCE
 
@@ -35,14 +38,14 @@
 
 #include "rtp_internal.h"
 #include "rdt.h"
-
-//#define DEBUG
-//#define DEBUG_RTP_TCP
+#include "rtsp_internal.h"
+#include "rtp_asf.h" /* Netgem: rtsp asf support */
 
 enum RTSPClientState {
     RTSP_STATE_IDLE,
     RTSP_STATE_PLAYING,
     RTSP_STATE_PAUSED,
+    RTSP_STATE_EOS, /* Netgem */
 };
 
 enum RTSPServerType {
@@ -75,25 +78,25 @@ typedef struct RTSPState {
     char last_reply[2048]; /* XXX: allocate ? */
     void *cur_tx;
     int need_subscription;
-} RTSPState;
 
-typedef struct RTSPStream {
-    URLContext *rtp_handle; /* RTP stream handle */
-    void *tx_ctx; /* RTP/RDT parse context */
-
-    int stream_index; /* corresponding stream index, if any. -1 if none (MPEG2TS case) */
-    int interleaved_min, interleaved_max;  /* interleave ids, if TCP transport */
-    char control_url[1024]; /* url for this stream (from SDP) */
-
-    int sdp_port; /* port (from SDP content - not used in RTSP) */
-    struct in_addr sdp_ip; /* IP address  (from SDP content - not used in RTSP) */
-    int sdp_ttl;  /* IP TTL (from SDP content - not used in RTSP) */
-    int sdp_payload_type; /* payload type - only used in SDP */
-    rtp_payload_data_t rtp_payload_data; /* rtp payload parsing infos from SDP */
-
-    RTPDynamicProtocolHandler *dynamic_handler; ///< Only valid if it's a dynamic protocol. (This is the handler structure)
-    PayloadContext *dynamic_protocol_context; ///< Only valid if it's a dynamic protocol. (This is any private data associated with the dynamic protocol)
-} RTSPStream;
+    /* Netgem: keepalive support */
+    int timeout; /* RTSP GET_PARAMETER timeout */
+    int64_t prev_timeout;
+    /* End Netgem */
+
+    /* Netgem: SETUP at play() */
+    int lower_transport_mask;
+    char host[1024];
+    int port;
+    /* End Netgem */
+
+    char default_control_url[1024]; /* Netgem: url for this stream (from SDP) */
+    struct RTPAsfContext *asf; /* Netgem: rtsp asf support */
+
+    int methods; /* Netgem: supported methods */
+    char real_challenge[64];
+
+} RTSPState;
 
 static int rtsp_read_play(AVFormatContext *s);
 
@@ -166,12 +169,14 @@ static void get_word(char *buf, int buf_
 
 /* parse the rtpmap description: <codec_name>/<clock_rate>[/<other
    params>] */
-static int sdp_parse_rtpmap(AVCodecContext *codec, RTSPStream *rtsp_st, int payload_type, const char *p)
+static int sdp_parse_rtpmap(AVStream *st, RTSPStream *rtsp_st, int payload_type, const char *p)
 {
     char buf[256];
     int i;
     AVCodec *c;
     const char *c_name;
+    AVCodecContext *codec = st->codec;
+    char c_name2[256];
 
     /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and
        see if we can handle this kind of payload */
@@ -182,8 +187,8 @@ static int sdp_parse_rtpmap(AVCodecConte
             if (!strcmp(buf, handler->enc_name) && (codec->codec_type == handler->codec_type)) {
                 codec->codec_id = handler->codec_id;
                 rtsp_st->dynamic_handler= handler;
-                if(handler->open) {
-                    rtsp_st->dynamic_protocol_context= handler->open();
+                if(handler->rtp_open) {
+                    rtsp_st->dynamic_protocol_context= handler->rtp_open();
                 }
                 break;
             }
@@ -201,13 +206,27 @@ static int sdp_parse_rtpmap(AVCodecConte
     else
         c_name = (char *)NULL;
 
+    /* Netgem: create a default name */
+    if (!c_name) {
+        snprintf(c_name2, sizeof(c_name2), "id=%d", codec->codec_id);
+        c_name = c_name2;
+    }
+    /* End Netgem */
+
+    /* Netgem: discard unknown codec */
+    if (codec->codec_id == CODEC_ID_NONE) {
+        st->discard = AVDISCARD_ALL;
+    }
+
     if (c_name) {
         get_word_sep(buf, sizeof(buf), "/", &p);
         i = atoi(buf);
         switch (codec->codec_type) {
             case CODEC_TYPE_AUDIO:
                 av_log(codec, AV_LOG_DEBUG, " audio codec set to : %s\n", c_name);
+                if (codec->sample_rate < 0)
                 codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;
+                if (codec->channels < 0)
                 codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;
                 if (i > 0) {
                     codec->sample_rate = i;
@@ -218,11 +237,21 @@ static int sdp_parse_rtpmap(AVCodecConte
                     // TODO: there is a bug here; if it is a mono stream, and less than 22000Hz, faad upconverts to stereo and twice the
                     //  frequency.  No problem, but the sample rate is being set here by the sdp line.  Upcoming patch forthcoming. (rdm)
                 }
+                av_set_pts_info(st, 32, 1, codec->sample_rate); /* Netgem */
                 av_log(codec, AV_LOG_DEBUG, " audio samplerate set to : %i\n", codec->sample_rate);
                 av_log(codec, AV_LOG_DEBUG, " audio channels set to : %i\n", codec->channels);
                 break;
             case CODEC_TYPE_VIDEO:
                 av_log(codec, AV_LOG_DEBUG, " video codec set to : %s\n", c_name);
+
+                /* Netgem */
+                if (codec->sample_rate < 0)
+                    codec->sample_rate = 90000;
+                if (i > 0)
+                    codec->sample_rate = i;
+                av_set_pts_info(st, 32, 1, codec->sample_rate);
+                /* End Netgem */
+
                 break;
             default:
                 break;
@@ -298,6 +327,15 @@ static const attrname_map_t attr_names[]
     {"SizeLength",       ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, sizelength)},
     {"IndexLength",      ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, indexlength)},
     {"IndexDeltaLength", ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, indexdeltalength)},
+
+    /* better MP4-audio parsing */
+    {"CTSDeltaLength",   ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, ctsdeltalength)},
+    {"DTSDeltaLength",   ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, dtsdeltalength)},
+    {"randomAccessIndication",  ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, randomaccessindication)},
+    {"streamStateIndication",   ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, streamstateindication)},
+    {"auxiliaryDataSizeLength", ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, auxiliarydatasizelength)},
+    /* End Netgem */
+
     {"profile-level-id", ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, profile_level_id)},
     {"StreamType",       ATTR_NAME_TYPE_INT, offsetof(rtp_payload_data_t, streamtype)},
     {"mode",             ATTR_NAME_TYPE_STR, offsetof(rtp_payload_data_t, mode)},
@@ -351,6 +389,27 @@ static void sdp_parse_fmtp(AVStream *st,
     }
 }
 
+/* parse a SDP line and save stream size */
+static void sdp_parse_framesize(AVStream *st, const char *p)
+{
+    AVCodecContext *codec = st->codec;
+    char buf1[50];
+    char *dst = buf1;
+
+    while (*p && *p == ' ') p++; // strip trailing spaces.
+    while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1) {
+        *dst++ = *p++;
+    }
+    *dst = '\0';
+
+    // a='framesize:96 320-240'
+    // set our parameters..
+    codec->width = atoi(buf1);
+    codec->height = atoi(p + 1); // skip the -
+
+    av_log(NULL, AV_LOG_DEBUG, "video size set to %d/%d\n", codec->width, codec->height);
+}
+
 /** Parse a string \p in the form of Range:npt=xx-xx, and determine the start
  *  and end time.
  *  Used for seeking in the rtp stream.
@@ -396,9 +455,7 @@ static void sdp_parse_line(AVFormatConte
     struct in_addr sdp_ip;
     int ttl;
 
-#ifdef DEBUG
-    printf("sdp: %c='%s'\n", letter, buf);
-#endif
+    dprintf(s, "sdp: %c='%s'\n", letter, buf);
 
     p = buf;
     switch(letter) {
@@ -445,7 +502,7 @@ static void sdp_parse_line(AVFormatConte
         } else if (!strcmp(st_type, "video")) {
             codec_type = CODEC_TYPE_VIDEO;
         } else {
-            return;
+            codec_type = CODEC_TYPE_UNKNOWN; /* Netgem: every streams are supported */
         }
         rtsp_st = av_mallocz(sizeof(RTSPStream));
         if (!rtsp_st)
@@ -480,11 +537,16 @@ static void sdp_parse_line(AVFormatConte
             }
         }
         /* put a default control url */
+        if (rt->default_control_url[0])
+            av_strlcpy(rtsp_st->control_url, rt->default_control_url, sizeof(rtsp_st->control_url));
+        else
         av_strlcpy(rtsp_st->control_url, s->filename, sizeof(rtsp_st->control_url));
         break;
     case 'a':
-        if (av_strstart(p, "control:", &p) && s->nb_streams > 0) {
+        if (av_strstart(p, "control:", &p)) {
             char proto[32];
+
+            if (s->nb_streams > 0) {
             /* get the control url */
             st = s->streams[s->nb_streams - 1];
             rtsp_st = st->priv_data;
@@ -493,29 +555,39 @@ static void sdp_parse_line(AVFormatConte
             url_split(proto, sizeof(proto), NULL, 0, NULL, 0, NULL, NULL, 0, p);
             if (proto[0] == '\0') {
                 /* relative control URL */
+                    int len = strlen(rtsp_st->control_url);
+                    if (len == 0 || rtsp_st->control_url[len-1] != '/')
                 av_strlcat(rtsp_st->control_url, "/", sizeof(rtsp_st->control_url));
                 av_strlcat(rtsp_st->control_url, p,   sizeof(rtsp_st->control_url));
+                    av_strlcpy(rtsp_st->control_id,  p,   sizeof(rtsp_st->control_id)); /* Netgem */
             } else {
                 av_strlcpy(rtsp_st->control_url, p,   sizeof(rtsp_st->control_url));
             }
-        } else if (av_strstart(p, "rtpmap:", &p)) {
+            }
+            else {
+                if (strcmp(p, "*") != 0) {
+                    av_strlcpy(rt->default_control_url, p, sizeof(rt->default_control_url));
+                }
+            }
+        } else if (av_strstart(p, "rtpmap:", &p) && s->nb_streams > 0) {
+            /* get the control url */
+            st = s->streams[s->nb_streams - 1];
+            rtsp_st = st->priv_data;
+
             /* NOTE: rtpmap is only supported AFTER the 'm=' tag */
             get_word(buf1, sizeof(buf1), &p);
             payload_type = atoi(buf1);
-            for(i = 0; i < s->nb_streams;i++) {
-                st = s->streams[i];
-                rtsp_st = st->priv_data;
                 if (rtsp_st->sdp_payload_type == payload_type) {
-                    sdp_parse_rtpmap(st->codec, rtsp_st, payload_type, p);
+                sdp_parse_rtpmap(st, rtsp_st, payload_type, p);
                 }
-            }
-        } else if (av_strstart(p, "fmtp:", &p)) {
+        } else if (av_strstart(p, "fmtp:", &p) && s->nb_streams > 0) {
+            /* get the control url */
+            st = s->streams[s->nb_streams - 1];
+            rtsp_st = st->priv_data;
+
             /* NOTE: fmtp is only supported AFTER the 'a=rtpmap:xxx' tag */
             get_word(buf1, sizeof(buf1), &p);
             payload_type = atoi(buf1);
-            for(i = 0; i < s->nb_streams;i++) {
-                st = s->streams[i];
-                rtsp_st = st->priv_data;
                 if (rtsp_st->sdp_payload_type == payload_type) {
                     if(rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) {
                         if(!rtsp_st->dynamic_handler->parse_sdp_a_line(st, rtsp_st->dynamic_protocol_context, buf)) {
@@ -525,18 +597,21 @@ static void sdp_parse_line(AVFormatConte
                         sdp_parse_fmtp(st, p);
                     }
                 }
-            }
-        } else if(av_strstart(p, "framesize:", &p)) {
+        } else if(av_strstart(p, "framesize:", &p) && s->nb_streams > 0) {
+            /* get the control url */
+            st = s->streams[s->nb_streams - 1];
+            rtsp_st = st->priv_data;
+
             // let dynamic protocol handlers have a stab at the line.
             get_word(buf1, sizeof(buf1), &p);
             payload_type = atoi(buf1);
-            for(i = 0; i < s->nb_streams;i++) {
-                st = s->streams[i];
-                rtsp_st = st->priv_data;
                 if (rtsp_st->sdp_payload_type == payload_type) {
                     if(rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) {
-                        rtsp_st->dynamic_handler->parse_sdp_a_line(st, rtsp_st->dynamic_protocol_context, buf);
+                    if (!rtsp_st->dynamic_handler->parse_sdp_a_line(st, rtsp_st->dynamic_protocol_context, buf)) {
+                        sdp_parse_framesize(st, p);
                     }
+                } else {
+                    sdp_parse_framesize(st, p);
                 }
             }
         } else if(av_strstart(p, "range:", &p)) {
@@ -546,6 +621,13 @@ static void sdp_parse_line(AVFormatConte
             rtsp_parse_range_npt(p, &start, &end);
             s->start_time= start;
             s->duration= (end==AV_NOPTS_VALUE)?AV_NOPTS_VALUE:end-start; // AV_NOPTS_VALUE means live broadcast (and can't seek)
+
+            /* Netgem: rtsp asf support */
+        } else if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {
+            if (!rt->asf)
+                rt->asf = rtp_asf_init(p);
+            /* End Netgem */
+
         } else if (av_strstart(p, "IsRealDataType:integer;",&p)) {
             if (atoi(p) == 1)
                 rt->transport = RTSP_TRANSPORT_RDT;
@@ -562,9 +644,10 @@ static void sdp_parse_line(AVFormatConte
 
 static int sdp_parse(AVFormatContext *s, const char *content)
 {
+#define SDP_MAXBUF_LEN (16*1024)
     const char *p;
     int letter;
-    char buf[2048], *q;
+    char buf[SDP_MAXBUF_LEN], *q;
     SDPParseState sdp_parse_state, *s1 = &sdp_parse_state;
 
     memset(s1, 0, sizeof(SDPParseState));
@@ -719,6 +802,99 @@ static void rtsp_parse_transport(RTSPHea
     }
 }
 
+/* Netgem: better MP4-audio parsing */
+/* parse the RTP-Info:
+    url=[control];seq=[seq];rtptime=[rtptime],... */
+static void rtsp_parse_rtpinfo(RTSPHeader *reply, const char *p)
+{
+    char buf[1024];
+    char parameter[16];
+    RTPInfoField *info = NULL;
+    int num = 0;
+
+    for(;;) {
+        skip_spaces(&p);
+        if (*p == '\0')
+            break;
+        get_word_sep(parameter, sizeof(parameter), "=;,", &p);
+
+        if (!strcmp(parameter, "url")) {
+            if (num == MAX_STREAMS) {
+                av_log(NULL, AV_LOG_ERROR, "Too many RTPInfo\n");
+                return;                
+            }
+            reply->rtp_info[num] = av_mallocz(sizeof(RTPInfoField));
+            info = reply->rtp_info[num];
+            if (info == NULL) {
+                av_log(NULL, AV_LOG_ERROR, "Cannot allocate RTPInfo\n");
+                return;
+            }
+            num++;
+
+            if (*p == '=') {
+                p++;
+                get_word_sep(buf, sizeof(buf), ";,", &p);
+                strcpy(info->url, buf);
+            }
+        }
+
+        if (!strcmp(parameter, "seq")) {
+            if (!info) {
+                av_log(NULL, AV_LOG_DEBUG, "invalid RTP-Info header\n");
+                break;
+            }
+            if (*p == '=') {
+                p++;
+                get_word_sep(buf, sizeof(buf), ";,", &p);
+                info->seq = strtoul(buf, NULL, 10);
+            }
+        }
+
+        if (!strcmp(parameter, "rtptime")) {
+            if (!info) {
+                av_log(NULL, AV_LOG_DEBUG, "invalid RTP-Info header\n");
+                break;
+            }
+            if (*p == '=') {
+                p++;
+                get_word_sep(buf, sizeof(buf), ";,", &p);
+                info->rtptime = strtoul(buf, NULL, 10);
+            }
+        }
+
+        while (*p != ';' && *p != '\0' && *p != ',')
+            p++;
+        while (*p == ';' || *p == ',')
+            p++;
+    }
+}
+/* End Netgem */
+
+/* Netgem: public methods */
+static void rtsp_parse_public(RTSPHeader *reply, const char *p)
+{
+    char parameter[32];
+
+    for(;;) {
+        skip_spaces(&p);
+        if (*p == '\0')
+            break;
+        get_word_sep(parameter, sizeof(parameter), ",", &p);
+
+        if (!strcmp(parameter, "GET_PARAMETER")) {
+            reply->methods |= RTSP_METHOD_GET_PARAMETER;
+        }
+        else if (!strcmp(parameter, "PAUSE")) {
+            reply->methods |= RTSP_METHOD_PAUSE;
+        }
+
+        while (*p != '\0' && *p != ',')
+            p++;
+        while (*p == ',')
+            p++;
+    }
+}
+
 void rtsp_parse_line(RTSPHeader *reply, const char *buf)
 {
     const char *p;
@@ -727,12 +903,52 @@ void rtsp_parse_line(RTSPHeader *reply,
     p = buf;
     if (av_stristart(p, "Session:", &p)) {
         get_word_sep(reply->session_id, sizeof(reply->session_id), ";", &p);
+
+        /* Netgem: keepalive support */
+        if (av_stristart(p, ";timeout=", &p)) {
+            reply->timeout = strtol(p, NULL, 10);
+        }
+        /* End Netgem */
+
     } else if (av_stristart(p, "Content-Length:", &p)) {
         reply->content_length = strtol(p, NULL, 10);
     } else if (av_stristart(p, "Transport:", &p)) {
         rtsp_parse_transport(reply, p);
     } else if (av_stristart(p, "CSeq:", &p)) {
         reply->seq = strtol(p, NULL, 10);
+
+        /* Netgem: use dynamic rtp packet length */
+    } else if (av_stristart(p, "Blocksize:", &p)) {
+        reply->blocksize = strtol(p, NULL, 10);
+        /* End Netgem */
+
+        /* Netgem: EOS support */
+    } else if (av_stristart(p, "X-Notice:", &p)) {
+        reply->notice = strtol(p, NULL, 10);
+    } else if (av_stristart(p, "Notice:", &p)) {
+        reply->notice = strtol(p, NULL, 10);
+        /* End Netgem */
+
+        /* Netgem: better MP4-audio parsing */
+    } else if (av_stristart(p, "RTP-Info:", &p)) {
+        rtsp_parse_rtpinfo(reply, p);
+        /* End Netgem */
+
+        /* Netgem: base URI for control */
+    } else if (av_stristart(p, "Content-Base:", &p)) {
+        get_word(reply->content_base, sizeof(reply->content_base), &p);
+        /* End Netgem */
+
+        /* Netgem: mime-type */
+    } else if (av_stristart(p, "Content-Type:", &p)) {
+        get_word(reply->content_type, sizeof(reply->content_type), &p);
+        /* End Netgem */
+
+        /* Netgem: public methods */
+    } else if (av_stristart(p, "Public:", &p)) {
+        rtsp_parse_public(reply, p);
+        /* End Netgem */
+
     } else if (av_stristart(p, "Range:", &p)) {
         rtsp_parse_range_npt(p, &reply->range_start, &reply->range_end);
     } else if (av_stristart(p, "RealChallenge1:", &p)) {
@@ -748,10 +964,25 @@ static int url_readbuf(URLContext *h, un
     len = 0;
     while (len < size) {
         ret = url_read(h, buf+len, size-len);
-        if (ret < 1)
+        /* Netgem: timeout on read */
+        if (ret < 1) {
+            if (ret != AVERROR(EAGAIN)) {
+                if (len == 0)
             return ret;
+                else
+                    return len;
+            }
+            else {
+                struct timespec ts = {.tv_sec= 0,
+                                      .tv_nsec= 100 * 1000 * 1000 };
+                nanosleep(&ts, NULL);
+            }
+        }
+        else {
         len += ret;
     }
+        /* End Netgem */
+    }
     return len;
 }
 
@@ -766,9 +997,7 @@ static void rtsp_skip_packet(AVFormatCon
     if (ret != 3)
         return;
     len = AV_RB16(buf + 1);
-#ifdef DEBUG
-    printf("skipping RTP packet len=%d\n", len);
-#endif
+    dprintf(s, "skipping RTP packet len=%d\n", len);
     /* skip payload */
     while (len > 0) {
         len1 = len;
@@ -781,33 +1010,74 @@ static void rtsp_skip_packet(AVFormatCon
     }
 }
 
+static void rtsp_parse_reply(AVFormatContext *s, RTSPHeader *reply,
+                             unsigned char **content_ptr);
+static void rtsp_free_reply(RTSPHeader *reply);
+
 static void rtsp_send_cmd(AVFormatContext *s,
-                          const char *cmd, RTSPHeader *reply,
+                          const char *cmd, const char *data, RTSPHeader *reply,
                           unsigned char **content_ptr)
 {
     RTSPState *rt = s->priv_data;
-    char buf[4096], buf1[1024], *q;
-    unsigned char ch;
-    const char *p;
-    int content_length, line_count;
-    unsigned char *content = NULL;
-
-    memset(reply, 0, sizeof(RTSPHeader));
+    char buf[4096], buf1[1024];
+    int datalen=0;
 
     rt->seq++;
     av_strlcpy(buf, cmd, sizeof(buf));
     snprintf(buf1, sizeof(buf1), "CSeq: %d\r\n", rt->seq);
     av_strlcat(buf, buf1, sizeof(buf));
+    av_strlcat(buf, "User-Agent: Netgem RTSP 1.0\r\n", sizeof(buf)); /* Netgem */
     if (rt->session_id[0] != '\0' && !strstr(cmd, "\nIf-Match:")) {
         snprintf(buf1, sizeof(buf1), "Session: %s\r\n", rt->session_id);
         av_strlcat(buf, buf1, sizeof(buf));
     }
+    if (data) {
+        datalen=strlen(data);
+    }
+    snprintf(buf1, sizeof(buf1), "Content-Length: %d\r\n", datalen);
+    av_strlcat(buf, buf1, sizeof(buf));
     av_strlcat(buf, "\r\n", sizeof(buf));
-#ifdef DEBUG
-    printf("Sending:\n%s--\n", buf);
-#endif
+    if (data) {
+        av_strlcat(buf, data, sizeof(buf));
+    }
+    dprintf(s, "\n--\nSending:\n%s--\n", buf);
     url_write(rt->rtsp_hd, buf, strlen(buf));
 
+    if (reply) { /* Netgem: wait for reply */
+
+        rtsp_parse_reply(s, reply, content_ptr);
+
+        /* Netgem */
+        if (rt->timeout == 0) {
+            rt->timeout = reply->timeout;
+            rt->prev_timeout = -1;
+        }
+        /* End Netgem */
+
+    } /* End Netgem */
+}
+
+/* Netgem: EOS support */
+static void rtsp_parse_reply(AVFormatContext *s, RTSPHeader *reply_ptr,
+                             unsigned char **content_ptr)
+{
+    RTSPState *rt = s->priv_data;
+    char buf[4096], buf1[1024], *q;
+    unsigned char ch;
+    const char *p;
+    int content_length, line_count;
+    RTSPHeader reply1, *reply;
+    unsigned char *content = NULL;
+
+    if (!reply_ptr) {
+        reply = &reply1;
+    }
+    else {
+        reply = reply_ptr;
+    }
+
+    memset(reply, 0, sizeof(*reply));
+
     /* parse reply (XXX: use buffers) */
     line_count = 0;
     rt->last_reply[0] = '\0';
@@ -827,9 +1097,7 @@ static void rtsp_send_cmd(AVFormatContex
             }
         }
         *q = '\0';
-#ifdef DEBUG
-        printf("line='%s'\n", buf);
-#endif
+        dprintf(s, "line='%s'\n", buf);
         /* test if last line */
         if (buf[0] == '\0')
             break;
@@ -856,13 +1124,41 @@ static void rtsp_send_cmd(AVFormatContex
         content = av_malloc(content_length + 1);
         (void)url_readbuf(rt->rtsp_hd, content, content_length);
         content[content_length] = '\0';
+        dprintf(s, "content='%s'\n", content);
     }
     if (content_ptr)
         *content_ptr = content;
     else
         av_free(content);
+
+    /* from http://www.ietf.org/internet-drafts/draft-stiemerling-rtsp-announce-00.txt */
+    switch (reply->notice) {
+    case 2101: /* "End-of-Stream Reached" (Content terminated) */
+    case 2104: /* "Start-of-Stream Reached" (Returned to the initial content) */
+    case 2306: /* "Continuous Feed Terminated" (Live finished) */
+        rt->state = RTSP_STATE_EOS;
+        break;
+    default:
+        break;
+    }
+
+    if (!reply_ptr) {
+        rtsp_free_reply(reply);
+    }
+
 }
+/* End Netgem */
 
+/* Netgem */
+static void rtsp_free_reply(RTSPHeader *reply)
+{
+    RTPInfoField **info = reply->rtp_info;
+    while (*info) {
+        av_freep(info);
+        info++;
+    }
+}
+/* End Netgem */
 
 /* close and free RTSP streams */
 static void rtsp_close_streams(RTSPState *rt)
@@ -881,11 +1177,22 @@ static void rtsp_close_streams(RTSPState
             }
             if (rtsp_st->rtp_handle)
                 url_close(rtsp_st->rtp_handle);
+            rtsp_st->rtp_handle = NULL;
             if (rtsp_st->dynamic_handler && rtsp_st->dynamic_protocol_context)
-                rtsp_st->dynamic_handler->close(rtsp_st->dynamic_protocol_context);
+                rtsp_st->dynamic_handler->rtp_close(rtsp_st->dynamic_protocol_context);
+            av_free(rtsp_st->rtp_payload_data.mode); /* Netgem: Memory leak */
+            av_free(rtsp_st->rtp_payload_data.au_headers); /* Netgem: Memory leak */
+            av_free(rtsp_st->rtp_packet); /* Netgem: dynamic rtp packet */
         }
     }
-    av_free(rt->rtsp_streams);
+    av_freep(&rt->rtsp_streams);
+    rt->nb_rtsp_streams = 0;
+
+    /* Netgem: rtsp asf support */
+    if (rt->asf)
+        rtp_asf_close(rt->asf);
+    rt->asf = NULL;
+    /* End Netgem */
 }
 
 static int
@@ -926,16 +1233,22 @@ rtsp_open_transport_ctx(AVFormatContext
  * @returns 0 on success, <0 on error, 1 if protocol is unavailable.
  */
 static int
-make_setup_request (AVFormatContext *s, const char *host, int port,
-                    int lower_transport, const char *real_challenge)
+make_setup_request (AVFormatContext *s,
+                    int lower_transport)
 {
     RTSPState *rt = s->priv_data;
-    int j, i, err;
+    int i, err;
     RTSPStream *rtsp_st;
+    int interleaved_ct = 0; /* Netgem: rtsp asf support */
     RTSPHeader reply1, *reply = &reply1;
     char cmd[2048];
+    int setup_nb = 0; /* Netgem */
+    int localport = RTSP_RTP_PORT_MIN, serverport = RTSP_RTP_PORT_MIN; /* Netgem */
+    int must_open_rtp_handle; /* Netgem */
     const char *trans_pref;
 
+    memset(reply, 0, sizeof(*reply)); /* Netgem */
+
     if (rt->transport == RTSP_TRANSPORT_RDT)
         trans_pref = "x-pn-tng";
     else
@@ -945,23 +1258,53 @@ make_setup_request (AVFormatContext *s,
     /* XXX: we assume the same server is used for the control of each
        RTSP stream */
 
-    for(j = RTSP_RTP_PORT_MIN, i = 0; i < rt->nb_rtsp_streams; ++i) {
+    for(i = 0; i < rt->nb_rtsp_streams; ++i) {
         char transport[2048];
 
         rtsp_st = rt->rtsp_streams[i];
 
+        /* Netgem */
+        if (rtsp_st->stream_index >= 0) {
+            AVStream *st = s->streams[rtsp_st->stream_index];
+            if (st->codec->codec_type != CODEC_TYPE_AUDIO && 
+                st->codec->codec_type != CODEC_TYPE_VIDEO) {
+                /* send setup only for a/v streams */
+                continue;
+            }
+            if (st->codec->codec_id == CODEC_ID_NONE ||
+                st->discard >= AVDISCARD_ALL) {
+                /* send setup only for known streams */
+                continue;
+            }
+        }
+
+        if (setup_nb == 0) {
+            must_open_rtp_handle = 1;
+        }
+        else {
+            if (rt->asf) {
+                /* do not open rtp handle for that stream */
+                must_open_rtp_handle = 0;
+            }
+            else {
+                localport += 2; /* we will use two port by rtp stream (rtp and rtcp) */
+                must_open_rtp_handle = 1;
+            }
+        }
+        /* End Netgem */
+
         /* RTP/UDP */
         if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {
             char buf[256];
 
             /* first try in specified port range */
-            if (RTSP_RTP_PORT_MIN != 0) {
-                while(j <= RTSP_RTP_PORT_MAX) {
-                    snprintf(buf, sizeof(buf), "rtp://%s?localport=%d", host, j);
-                    j += 2; /* we will use two port by rtp stream (rtp and rtcp) */
+            if (RTSP_RTP_PORT_MIN != 0 && must_open_rtp_handle) {
+                while(localport <= RTSP_RTP_PORT_MAX) {
+                    snprintf(buf, sizeof(buf), "rtp://%s?localport=%d", rt->host, localport);
                     if (url_open(&rtsp_st->rtp_handle, buf, URL_RDWR) == 0) {
                         goto rtp_opened;
                     }
+                    localport += 2;
                 }
             }
 
@@ -973,21 +1316,28 @@ make_setup_request (AVFormatContext *s,
 */
 
         rtp_opened:
-            port = rtp_get_local_port(rtsp_st->rtp_handle);
+            if (rtsp_st->rtp_handle) {
+                serverport = rtp_get_local_port(rtsp_st->rtp_handle);
+            }
             snprintf(transport, sizeof(transport) - 1,
                      "%s/UDP;", trans_pref);
             if (rt->server_type != RTSP_SERVER_REAL)
                 av_strlcat(transport, "unicast;", sizeof(transport));
             av_strlcatf(transport, sizeof(transport),
-                     "client_port=%d", port);
+                     "client_port=%d", localport);
             if (rt->transport == RTSP_TRANSPORT_RTP)
-                av_strlcatf(transport, sizeof(transport), "-%d", port + 1);
+                av_strlcatf(transport, sizeof(transport), "-%d", localport + 1);
         }
 
         /* RTP/TCP */
         else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {
             snprintf(transport, sizeof(transport) - 1,
-                     "%s/TCP", trans_pref);
+                     "%s/TCP"
+            /* Netgem: rtsp asf support, we must define 'interleaved'.
+             * Other servers understand this */
+                     ";unicast;interleaved=%d-%d", trans_pref, interleaved_ct, interleaved_ct + 1);
+            interleaved_ct += 2;
+            /* End Netgem */
         }
 
         else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {
@@ -1003,14 +1353,14 @@ make_setup_request (AVFormatContext *s,
         if (i == 0 && rt->server_type == RTSP_SERVER_REAL) {
             char real_res[41], real_csum[9];
             ff_rdt_calc_response_and_checksum(real_res, real_csum,
-                                              real_challenge);
+                                              rt->real_challenge);
             av_strlcatf(cmd, sizeof(cmd),
                         "If-Match: %s\r\n"
                         "RealChallenge2: %s, sd=%s\r\n",
                         rt->session_id, real_res, real_csum);
         }
-        rtsp_send_cmd(s, cmd, reply, NULL);
-        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {
+        rtsp_send_cmd(s, cmd, NULL, reply, NULL);
+        if (reply->status_code == RTSP_STATUS_TRANSPORT && setup_nb/*Netgem*/ == 0) {
             err = 1;
             goto fail;
         } else if (reply->status_code != RTSP_STATUS_OK ||
@@ -1020,7 +1370,7 @@ make_setup_request (AVFormatContext *s,
         }
 
         /* XXX: same protocol for all streams is required */
-        if (i > 0) {
+        if (setup_nb/*Netgem*/ > 0) {
             if (reply->transports[0].lower_transport != rt->lower_transport ||
                 reply->transports[0].transport != rt->transport) {
                 err = AVERROR_INVALIDDATA;
@@ -1038,6 +1388,20 @@ make_setup_request (AVFormatContext *s,
             rtsp_st->rtp_handle = NULL;
         }
 
+        /* Netgem: dynamic rtsp packet */
+        if (reply->blocksize) {
+            rtsp_st->rtp_blocksize = reply->blocksize;
+        }
+        else {
+            rtsp_st->rtp_blocksize = RTP_MAX_PACKET_LENGTH;
+        }
+        rtsp_st->rtp_packet = av_malloc(rtsp_st->rtp_blocksize);
+        if (!rtsp_st->rtp_packet) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+        /* End Netgem */
+
         switch(reply->transports[0].lower_transport) {
         case RTSP_LOWER_TRANSPORT_TCP:
             rtsp_st->interleaved_min = reply->transports[0].interleaved_min;
@@ -1045,12 +1409,12 @@ make_setup_request (AVFormatContext *s,
             break;
 
         case RTSP_LOWER_TRANSPORT_UDP:
-            {
+            if (rtsp_st->rtp_handle) {
                 char url[1024];
 
                 /* XXX: also use address if specified */
                 snprintf(url, sizeof(url), "rtp://%s:%d",
-                         host, reply->transports[0].server_port_min);
+                         rt->host, reply->transports[0].server_port_min);
                 if (rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {
                     err = AVERROR_INVALIDDATA;
                     goto fail;
@@ -1074,9 +1438,12 @@ make_setup_request (AVFormatContext *s,
             }
             break;
         }
+        rtsp_free_reply(reply);
 
         if ((err = rtsp_open_transport_ctx(s, rtsp_st)))
             goto fail;
+
+        setup_nb++; /* Netgem: setup number could be not equal to i. */
     }
 
     if (rt->server_type == RTSP_SERVER_REAL)
@@ -1085,6 +1452,7 @@ make_setup_request (AVFormatContext *s,
     return 0;
 
 fail:
+    rtsp_free_reply(reply);
     for (i=0; i<rt->nb_rtsp_streams; i++) {
         if (rt->rtsp_streams[i]->rtp_handle) {
             url_close(rt->rtsp_streams[i]->rtp_handle);
@@ -1098,19 +1466,17 @@ static int rtsp_read_header(AVFormatCont
                             AVFormatParameters *ap)
 {
     RTSPState *rt = s->priv_data;
-    char host[1024], path[1024], tcpname[1024], cmd[2048], *option_list, *option;
+    char path[1024], tcpname[1024], cmd[2048], *option_list, *option;
     URLContext *rtsp_hd;
-    int port, ret, err;
+    int ret, err;
     RTSPHeader reply1, *reply = &reply1;
     unsigned char *content = NULL;
-    int lower_transport_mask = 0;
-    char real_challenge[64];
 
     /* extract hostname and port */
     url_split(NULL, 0, NULL, 0,
-              host, sizeof(host), &port, path, sizeof(path), s->filename);
-    if (port < 0)
-        port = RTSP_DEFAULT_PORT;
+              rt->host, sizeof(rt->host), &rt->port, path, sizeof(path), s->filename);
+    if (rt->port < 0)
+        rt->port = RTSP_DEFAULT_PORT;
 
     /* search for options */
     option_list = strchr(path, '?');
@@ -1125,19 +1491,21 @@ static int rtsp_read_header(AVFormatCont
                 *(option_list++) = 0;
             /* handle the options */
             if (strcmp(option, "udp") == 0)
-                lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_UDP);
+                rt->lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_UDP);
             else if (strcmp(option, "multicast") == 0)
-                lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_UDP_MULTICAST);
+                rt->lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_UDP_MULTICAST);
             else if (strcmp(option, "tcp") == 0)
-                lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_TCP);
+                rt->lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_TCP);
         }
     }
 
-    if (!lower_transport_mask)
-        lower_transport_mask = (1 << RTSP_LOWER_TRANSPORT_LAST) - 1;
+    /* Netgem */
+    if (!rt->lower_transport_mask)
+        rt->lower_transport_mask = rtsp_default_protocols;
+    /* End Netgem */
 
     /* open the tcp connexion */
-    snprintf(tcpname, sizeof(tcpname), "tcp://%s:%d", host, port);
+    snprintf(tcpname, sizeof(tcpname), "tcp://%s:%d", rt->host, rt->port);
     if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)
         return AVERROR(EIO);
     rt->rtsp_hd = rtsp_hd;
@@ -1163,7 +1531,7 @@ static int rtsp_read_header(AVFormatCont
                        "CompanyID: KnKV4M4I/B2FjJ1TToLycw==\r\n"
                        "GUID: 00000000-0000-0000-0000-000000000000\r\n",
                        sizeof(cmd));
-        rtsp_send_cmd(s, cmd, reply, NULL);
+        rtsp_send_cmd(s, cmd, NULL, reply, NULL);
         if (reply->status_code != RTSP_STATUS_OK) {
             err = AVERROR_INVALIDDATA;
             goto fail;
@@ -1172,10 +1540,17 @@ static int rtsp_read_header(AVFormatCont
         /* detect server type if not standard-compliant RTP */
         if (rt->server_type != RTSP_SERVER_REAL && reply->real_challenge[0]) {
             rt->server_type = RTSP_SERVER_REAL;
+            rtsp_free_reply(reply); /* Netgem */
             continue;
         } else if (rt->server_type == RTSP_SERVER_REAL) {
-            strcpy(real_challenge, reply->real_challenge);
+            strcpy(rt->real_challenge, reply->real_challenge);
         }
+
+        /* Netgem */
+        rt->methods = reply->methods;
+        rtsp_free_reply(reply);
+        /* End Netgem */
+
         break;
     }
 
@@ -1193,7 +1568,7 @@ static int rtsp_read_header(AVFormatCont
                    "Require: com.real.retain-entity-for-setup\r\n",
                    sizeof(cmd));
     }
-    rtsp_send_cmd(s, cmd, reply, &content);
+    rtsp_send_cmd(s, cmd, NULL, reply, &content);
     if (!content) {
         err = AVERROR_INVALIDDATA;
         goto fail;
@@ -1203,6 +1578,15 @@ static int rtsp_read_header(AVFormatCont
         goto fail;
     }
 
+    /* Netgem */
+    if (reply->content_base[0]) {
+        av_strlcpy(rt->default_control_url, reply->content_base,
+                   sizeof(rt->default_control_url));
+    }
+    /* End Netgem */
+
+    rtsp_free_reply(reply);
+
     /* now we got the SDP description, we parse it */
     ret = sdp_parse(s, (const char *)content);
     av_freep(&content);
@@ -1211,20 +1595,16 @@ static int rtsp_read_header(AVFormatCont
         goto fail;
     }
 
-    do {
-        int lower_transport = ff_log2_tab[lower_transport_mask & ~(lower_transport_mask - 1)];
-
-        err = make_setup_request(s, host, port, lower_transport,
-                                 rt->server_type == RTSP_SERVER_REAL ?
-                                     real_challenge : NULL);
-        if (err < 0)
-            goto fail;
-        lower_transport_mask &= ~(1 << lower_transport);
-        if (lower_transport_mask == 0 && err == 1) {
-            err = AVERROR(FF_NETERROR(EPROTONOSUPPORT));
-            goto fail;
+    /* Netgem: rtsp asf support  */
+    if (rt->asf) {
+        /* force TCP */
+        rt->lower_transport_mask = (1<< RTSP_LOWER_TRANSPORT_TCP);
+        /* force methods */
+        rt->methods = RTSP_METHOD_GET_PARAMETER | RTSP_METHOD_PAUSE;
         }
-    } while (err);
+    /* End Netgem */
+
+    /* Netgem: moved SETUP at play() */
 
     rt->state = RTSP_STATE_IDLE;
     rt->seek_timestamp = 0; /* default is to start stream at position
@@ -1237,20 +1617,84 @@ static int rtsp_read_header(AVFormatCont
             goto fail;
         }
     }
+
+    /* Netgem: rtsp asf support */
+    if (rt->asf) {
+        ret = rtp_asf_open(rt->asf, s);
+        if (ret < 0) {
+            err = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+    }
+    /* End Netgem */
+
     return 0;
  fail:
+    rtsp_free_reply(reply);
     rtsp_close_streams(rt);
     av_freep(&content);
     url_close(rt->rtsp_hd);
+    rt->rtsp_hd = NULL;
     return err;
 }
 
-static int tcp_read_packet(AVFormatContext *s, RTSPStream **prtsp_st,
-                           uint8_t *buf, int buf_size)
+/* Netgem: check for real message inside stream */
+static int rtsp_check_message(AVFormatContext *s, char *c)
+{
+    static const char *probe_message[] = {
+        "RTSP", /* RTSP/1.0 xxx xxx */
+        "PARA", /* PARAMETER xxx RTSP/1.0 */
+        "ANNO", /* ANNOUNCE xxx RTSP/1.0 */
+        NULL,
+    };
+    RTSPState *rt = s->priv_data;
+    char mess[5];
+    int i, len;
+
+    if (*c < 'A' || *c > 'Z')
+        return 0;
+
+    mess[0] = *c;
+    for (i=1 ; i<4 ; i++) {
+        len = url_readbuf(rt->rtsp_hd, c, 1);
+        if (len != 1)
+            return -1;
+        if (*c < 'A' || *c > 'Z')
+            return 0;
+        mess[i] = *c;
+    }
+    mess[4] = '\0';
+
+    dprintf(s, "mess=%s\n", mess);
+
+    i = 0;
+    while (probe_message[i]) {
+        if(strcmp(probe_message[i], mess) == 0) {
+            RTSPHeader reply;
+            rtsp_parse_reply(s, &reply, NULL);
+            if (rt->state == RTSP_STATE_EOS &&
+                strcasecmp(reply.content_type, "application/sdp") == 0 &&
+                s->event_report) {
+                /* new SDP message received after an EOS: 
+                 * a new stream has come! */
+                s->event_report(s->callback_priv_data,
+                                AVFMT_EVENT_REDIRECT, NULL);
+            }
+            rtsp_free_reply(&reply);
+            return 0;
+        }
+        i++;
+    }
+    return 0;
+}
+/* End Netgem */
+
+static int tcp_read_packet(AVFormatContext *s, RTSPStream **prtsp_st)
 {
     RTSPState *rt = s->priv_data;
     int id, len, i, ret;
-    RTSPStream *rtsp_st;
+    RTSPStream *rtsp_st = NULL;
+    char buf[2];
 
 #ifdef DEBUG_RTP_TCP
     printf("tcp_read_packet:\n");
@@ -1263,42 +1707,59 @@ static int tcp_read_packet(AVFormatConte
 #endif
         if (ret != 1)
             return -1;
+        ret = rtsp_check_message(s, &buf[0]);
+        if (ret < 0)
+            return ret;
+        if (rt->state == RTSP_STATE_EOS)
+            return AVERROR(EPIPE);
         if (buf[0] == '$')
             break;
     }
-    ret = url_readbuf(rt->rtsp_hd, buf, 3);
-    if (ret != 3)
+
+    ret = url_readbuf(rt->rtsp_hd, buf, 1);
+    if (ret != 1)
         return -1;
     id = buf[0];
-    len = AV_RB16(buf + 1);
+
+    /* find the matching stream */
+    for(i = 0; i < rt->nb_rtsp_streams; i++) {
+        rtsp_st = rt->rtsp_streams[i];
+        if (id >= rtsp_st->interleaved_min &&
+            id <= rtsp_st->interleaved_max)
+            break;
+    }
+    if (i == rt->nb_rtsp_streams) {
+        goto redo;
+    }
+
+    /* find packet len */
+    ret = url_readbuf(rt->rtsp_hd, buf, 2);
+    if (ret != 2)
+        return -1;
+    len = AV_RB16(buf);
+
 #ifdef DEBUG_RTP_TCP
     printf("id=%d len=%d\n", id, len);
 #endif
-    if (len > buf_size || len < 12)
+
+    if (len < 12 || len > rtsp_st->rtp_blocksize - 4) {
         goto redo;
+    }
+
     /* get the data */
-    ret = url_readbuf(rt->rtsp_hd, buf, len);
-    if (ret != len)
+    ret = url_readbuf(rt->rtsp_hd, rtsp_st->rtp_packet, len);
+    if (ret != len) {
         return -1;
+    }
     if (rt->transport == RTSP_TRANSPORT_RDT &&
         ff_rdt_parse_header(buf, len, &id, NULL, NULL, NULL, NULL) < 0)
         return -1;
 
-    /* find the matching stream */
-    for(i = 0; i < rt->nb_rtsp_streams; i++) {
-        rtsp_st = rt->rtsp_streams[i];
-        if (id >= rtsp_st->interleaved_min &&
-            id <= rtsp_st->interleaved_max)
-            goto found;
-    }
-    goto redo;
- found:
     *prtsp_st = rtsp_st;
     return len;
 }
 
-static int udp_read_packet(AVFormatContext *s, RTSPStream **prtsp_st,
-                           uint8_t *buf, int buf_size)
+static int udp_read_packet(AVFormatContext *s, RTSPStream **prtsp_st)
 {
     RTSPState *rt = s->priv_data;
     RTSPStream *rtsp_st;
@@ -1313,21 +1774,58 @@ static int udp_read_packet(AVFormatConte
         fd_max = -1;
         for(i = 0; i < rt->nb_rtsp_streams; i++) {
             rtsp_st = rt->rtsp_streams[i];
+            if (rtsp_st->rtp_handle) {
             /* currently, we cannot probe RTCP handle because of blocking restrictions */
             rtp_get_file_handles(rtsp_st->rtp_handle, &fd1, &fd2);
             if (fd1 > fd_max)
                 fd_max = fd1;
             FD_SET(fd1, &rfds);
         }
+        }
         tv.tv_sec = 0;
         tv.tv_usec = 100 * 1000;
         n = select(fd_max + 1, &rfds, NULL, NULL, &tv);
         if (n > 0) {
+
+            /* Netgem: avoid reading always the same stream */
+            int curstream = 0;
+            int64_t mintimestamp = -1;
+
             for(i = 0; i < rt->nb_rtsp_streams; i++) {
                 rtsp_st = rt->rtsp_streams[i];
+                if (rtsp_st->rtp_handle && rtsp_st->tx_ctx) {
+                    int64_t curtimestamp;
+                    AVStream *st;
+                    RTPDemuxContext *rtp_ctx = rtsp_st->tx_ctx;
+
+                    if (rtp_ctx->cur_timestamp <= 0) {
+                        curstream = i;
+                        break;
+                    }
+
+                    st = s->streams[rtsp_st->stream_index];
+                    curtimestamp = av_rescale_q(rtp_ctx->cur_timestamp, 
+                                                st->time_base, AV_TIME_BASE_Q);
+                    if (mintimestamp < 0 || curtimestamp < mintimestamp) {
+                        curstream = i;
+                        mintimestamp = curtimestamp;
+                    }
+                }
+            }
+            /* End Netgem */
+
+            for(i = 0; i < rt->nb_rtsp_streams; i++) {
+
+                /* Netgem: avoid reading always the same stream */
+                curstream %= rt->nb_rtsp_streams;
+                rtsp_st = rt->rtsp_streams[curstream/*Netgem*/];
+                curstream++;
+                /* End Netgem */
+
+                if (rtsp_st->rtp_handle) {
                 rtp_get_file_handles(rtsp_st->rtp_handle, &fd1, &fd2);
                 if (FD_ISSET(fd1, &rfds)) {
-                    ret = url_read(rtsp_st->rtp_handle, buf, buf_size);
+                        ret = url_read(rtsp_st->rtp_handle, rtsp_st->rtp_packet, rtsp_st->rtp_blocksize);
                     if (ret > 0) {
                         *prtsp_st = rtsp_st;
                         return ret;
@@ -1337,6 +1835,7 @@ static int udp_read_packet(AVFormatConte
         }
     }
 }
+}
 
 static int rtsp_read_packet(AVFormatContext *s,
                             AVPacket *pkt)
@@ -1344,7 +1843,11 @@ static int rtsp_read_packet(AVFormatCont
     RTSPState *rt = s->priv_data;
     RTSPStream *rtsp_st;
     int ret, len;
-    uint8_t buf[RTP_MAX_PACKET_LENGTH];
+
+    /* Netgem */
+    if (rt->state == RTSP_STATE_EOS)
+        return AVERROR(EPIPE);
+    /* End Netgem */
 
     if (rt->server_type == RTSP_SERVER_REAL && rt->need_subscription) {
         int i;
@@ -1364,15 +1867,21 @@ static int rtsp_read_packet(AVFormatCont
                     cmd, sizeof(cmd), i, 0);
         }
         av_strlcat(cmd, "\r\n", sizeof(cmd));
-        rtsp_send_cmd(s, cmd, reply, NULL);
+        rtsp_send_cmd(s, cmd, NULL, reply, NULL);
         if (reply->status_code != RTSP_STATUS_OK)
             return AVERROR_INVALIDDATA;
         rt->need_subscription = 0;
+        rtsp_free_reply(reply); /* Netgem */
 
         if (rt->state == RTSP_STATE_PLAYING)
             rtsp_read_play (s);
     }
 
+    /* Netgem */
+    if (rt->state != RTSP_STATE_PLAYING)
+        return -1;
+    /* End Netgem */
+
     /* get next frames from the same RTP packet */
     if (rt->cur_tx) {
         if (rt->transport == RTSP_TRANSPORT_RDT)
@@ -1394,11 +1903,11 @@ static int rtsp_read_packet(AVFormatCont
     switch(rt->lower_transport) {
     default:
     case RTSP_LOWER_TRANSPORT_TCP:
-        len = tcp_read_packet(s, &rtsp_st, buf, sizeof(buf));
+        len = tcp_read_packet(s, &rtsp_st);
         break;
     case RTSP_LOWER_TRANSPORT_UDP:
     case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:
-        len = udp_read_packet(s, &rtsp_st, buf, sizeof(buf));
+        len = udp_read_packet(s, &rtsp_st);
         if (len >=0 && rtsp_st->tx_ctx && rt->transport == RTSP_TRANSPORT_RTP)
             rtp_check_and_send_back_rr(rtsp_st->tx_ctx, len);
         break;
@@ -1406,9 +1915,9 @@ static int rtsp_read_packet(AVFormatCont
     if (len < 0)
         return len;
     if (rt->transport == RTSP_TRANSPORT_RDT)
-        ret = ff_rdt_parse_packet(rtsp_st->tx_ctx, pkt, buf, len);
+        ret = ff_rdt_parse_packet(rtsp_st->tx_ctx, pkt, rtsp_st->rtp_packet, len);
     else
-        ret = rtp_parse_packet(rtsp_st->tx_ctx, pkt, buf, len);
+        ret = rtp_parse_packet(rtsp_st->tx_ctx, pkt, rtsp_st->rtp_packet, len);
     if (ret < 0)
         goto redo;
     if (ret == 1) {
@@ -1423,26 +1932,105 @@ static int rtsp_read_play(AVFormatContex
     RTSPState *rt = s->priv_data;
     RTSPHeader reply1, *reply = &reply1;
     char cmd[1024];
+    int rv, flush;
 
     av_log(s, AV_LOG_DEBUG, "hello state=%d\n", rt->state);
 
+    /* Netgem: SETUP at play() */
+    if (rt->state == RTSP_STATE_IDLE && rt->lower_transport_mask) {
+        do {
+            int lower_transport = ff_log2_tab[rt->lower_transport_mask & ~(rt->lower_transport_mask - 1)];
+
+            rv = make_setup_request(s, lower_transport);
+            if (rv < 0)
+                return rv;
+            rt->lower_transport_mask &= ~(1 << lower_transport);
+            if (rt->lower_transport_mask == 0 && rv == 1) {
+                return AVERROR(FF_NETERROR(EPROTONOSUPPORT));
+            }
+        } while (rv);
+        rt->lower_transport_mask = 0;
+    }
+    /* End Netgem */
+
     if (!(rt->server_type == RTSP_SERVER_REAL && rt->need_subscription)) {
         if (rt->state == RTSP_STATE_PAUSED) {
             snprintf(cmd, sizeof(cmd),
                      "PLAY %s RTSP/1.0\r\n",
                      s->filename);
-        } else {
+            flush = 0; /* Netgem */
+        } else if (rt->seek_timestamp >= 0) {
             snprintf(cmd, sizeof(cmd),
                      "PLAY %s RTSP/1.0\r\n"
                      "Range: npt=%0.3f-\r\n",
                      s->filename,
                      (double)rt->seek_timestamp / AV_TIME_BASE);
+
+            /* Netgem: because of random first timestamp, start time changed every seek */
+            s->start_time = -rt->seek_timestamp;
+
+            rt->seek_timestamp = -1;
+            flush = 1; /* Netgem */
         }
-        rtsp_send_cmd(s, cmd, reply, NULL);
+        else {
+            return 0;
+        }
+
+        rtsp_send_cmd(s, cmd, NULL, reply, NULL);
         if (reply->status_code != RTSP_STATUS_OK) {
+            rt->state = RTSP_STATE_IDLE; /* Netgem: on error, change state */
+            rtsp_free_reply(reply);
             return -1;
         }
+
+        /* Netgem: better MP4-audio parsing */
+        if (flush) {
+            int num;
+            RTSPStream *rtsp_st;
+            RTPInfoField **info = reply->rtp_info;
+
+            /* reset current context */
+            rt->cur_tx = NULL;
+
+            for (num=0 ; num<rt->nb_rtsp_streams ; num++) {
+                RTPDemuxContext *rtp_ctx;
+                rtsp_st = rt->rtsp_streams[num];
+                if (!rtsp_st || !rtsp_st->tx_ctx)
+                    continue;
+                rtp_ctx = rtsp_st->tx_ctx;
+                
+                rtp_ctx->seq              = 0;
+                rtp_ctx->seq_initialized  = 0;
+                rtp_ctx->base_timestamp   = 0;
+                rtp_ctx->base_initialized = 0;
+                rtp_ctx->cur_timestamp    = 0;
+            }
+
+            while(*info) {
+                for (num=0 ; num<rt->nb_rtsp_streams ; num++) {
+                    RTPDemuxContext *rtp_ctx;
+                    rtsp_st = rt->rtsp_streams[num];
+                    if (!rtsp_st || !rtsp_st->tx_ctx)
+                        continue;
+                    rtp_ctx = rtsp_st->tx_ctx;
+
+                    if (strcmp(rtsp_st->control_url, (*info)->url) == 0 ||
+                        strcmp(rtsp_st->control_id,  (*info)->url) == 0) {
+                        if ((*info)->seq || (*info)->rtptime) {
+                            rtp_ctx->seq            = (*info)->seq;
+                            rtp_ctx->base_timestamp = (*info)->rtptime;
+                            rtp_ctx->base_initialized = 1;
+                        }
+                    }
+                }
+                info++;
     }
+        }
+
+        rtsp_free_reply(reply);
+        /* End Netgem */
+    }
+
     rt->state = RTSP_STATE_PLAYING;
     return 0;
 }
@@ -1453,23 +2041,82 @@ static int rtsp_read_pause(AVFormatConte
     RTSPState *rt = s->priv_data;
     RTSPHeader reply1, *reply = &reply1;
     char cmd[1024];
+    int rv;
 
     rt = s->priv_data;
 
     if (rt->state != RTSP_STATE_PLAYING)
         return 0;
-    else if (!(rt->server_type == RTSP_SERVER_REAL && rt->need_subscription)) {
+
+    if (!(rt->methods & RTSP_METHOD_PAUSE))
+        return -1;
+
         snprintf(cmd, sizeof(cmd),
                  "PAUSE %s RTSP/1.0\r\n",
                  s->filename);
-        rtsp_send_cmd(s, cmd, reply, NULL);
+    rtsp_send_cmd(s, cmd, NULL, reply, NULL);
         if (reply->status_code != RTSP_STATUS_OK) {
-            return -1;
+        rv= -1;
+    } else {
+        rt->state = RTSP_STATE_PAUSED;
+        rv= 0;
         }
+
+    rtsp_free_reply(reply);
+    return rv;
     }
-    rt->state = RTSP_STATE_PAUSED;
+
+/* Netgem: send GET_PARAMETER */
+static int rtsp_read_keepalive(AVFormatContext *s)
+{
+    RTSPState *rt = s->priv_data;
+    char cmd[1024];
+
+    if (rt->state != RTSP_STATE_PLAYING ||
+        rt->lower_transport != RTSP_LOWER_TRANSPORT_TCP) {
+        char c;
+        int len;
+        len = url_read(rt->rtsp_hd, &c, 1);
+        if (len == 1) {
+            rtsp_check_message(s, &c);
+            if (c == '$')
+                rtsp_skip_packet(s);
+        }
+    }
+
+    if (rt->timeout) {
+        int64_t curtime = -1;
+
+        if (rt->prev_timeout >= 0) {
+            curtime = av_gettime() / (1000 * 1000);
+            if (curtime < rt->prev_timeout) {
+                /* time changed */
+                rt->prev_timeout = -1;
+            }
+            else if ((curtime - rt->prev_timeout) > rt->timeout * 3 / 4) {
+                rt->prev_timeout = -1;
+            }
+        }
+
+        if (rt->prev_timeout < 0) {
+            if (curtime < 0) {
+                curtime = av_gettime() / (1000 * 1000);
+            }
+            rt->prev_timeout = curtime;
+
+            if (rt->methods & RTSP_METHOD_GET_PARAMETER) {
+                snprintf(cmd, sizeof(cmd),
+                         "GET_PARAMETER %s RTSP/1.0\r\n"
+                         "Content-Type: text/parameters\r\n",
+                         s->filename);
+                rtsp_send_cmd(s, cmd, "position\r\n", NULL, NULL);
+            }
+        }
+    }
+
     return 0;
 }
+/* End Netgem */
 
 static int rtsp_read_seek(AVFormatContext *s, int stream_index,
                           int64_t timestamp, int flags)
@@ -1477,6 +2124,10 @@ static int rtsp_read_seek(AVFormatContex
     RTSPState *rt = s->priv_data;
 
     rt->seek_timestamp = av_rescale_q(timestamp, s->streams[stream_index]->time_base, AV_TIME_BASE_Q);
+
+    /* Netgem: because of random first timestamp, start time changed every seek */
+    rt->seek_timestamp -= s->start_time;
+
     switch(rt->state) {
     default:
     case RTSP_STATE_IDLE:
@@ -1505,12 +2156,15 @@ static int rtsp_read_close(AVFormatConte
     }
 #endif
     snprintf(cmd, sizeof(cmd),
-             "TEARDOWN %s RTSP/1.0\r\n",
+             "TEARDOWN %s RTSP/1.0\r\n"
+             "Connection: close\r\n",
              s->filename);
-    rtsp_send_cmd(s, cmd, reply, NULL);
+    rtsp_send_cmd(s, cmd, NULL, reply, NULL);
+    rtsp_free_reply(reply);
 
     rtsp_close_streams(rt);
     url_close(rt->rtsp_hd);
+    rt->rtsp_hd = NULL;
     return 0;
 }
 
@@ -1527,6 +2181,7 @@ AVInputFormat rtsp_demuxer = {
     .flags = AVFMT_NOFILE,
     .read_play = rtsp_read_play,
     .read_pause = rtsp_read_pause,
+    .read_keepalive = rtsp_read_keepalive,
 };
 #endif
 
Only in ./libavformat: rtsp.d
diff -ruwp ./libavformat/rtsp.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtsp.h
--- ./libavformat/rtsp.h	2009-02-21 10:47:57.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/rtsp.h	2009-01-08 09:00:00.000000000 +0100
@@ -54,6 +54,15 @@ typedef struct RTSPTransportField {
     enum RTSPLowerTransport lower_transport;
 } RTSPTransportField;
 
+typedef struct RTPInfoField {
+    char url[1024];
+    uint32_t seq;
+    uint32_t rtptime;
+} RTPInfoField;
+
+#define RTSP_METHOD_GET_PARAMETER   (1<<0)
+#define RTSP_METHOD_PAUSE           (1<<2)
+
 typedef struct RTSPHeader {
     int content_length;
     enum RTSPStatusCode status_code; /**< response code from server */
@@ -61,8 +70,15 @@ typedef struct RTSPHeader {
     /** in AV_TIME_BASE unit, AV_NOPTS_VALUE if not used */
     int64_t range_start, range_end;
     RTSPTransportField transports[RTSP_MAX_TRANSPORTS];
+    RTPInfoField *rtp_info[MAX_STREAMS+1]; /* last info must be NULL */
     int seq; /**< sequence number */
     char session_id[512];
+    char content_type[64]; /**< Netgem: mime-type of current RTSP message  */
+    char content_base[1024]; /**< Netgem: base URL for control  */
+    int blocksize; /**< Netgem: rtp blocks length */
+    int timeout; /**< Netgem: timeout (in seconds) */
+    int notice; /**< Netgem: notice number */
+    int methods; /**< Netgem: supported methods */
     char real_challenge[64]; /**< the RealChallenge1 field from the server */
 } RTSPHeader;
 
Only in ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat: rtsp_internal.h
Only in ./libavformat: rtsp.o
Only in ./libavformat: sdp.d
Only in ./libavformat: sdp.o
Only in ./libavformat: segafilm.d
Only in ./libavformat: segafilm.o
Only in ./libavformat: sierravmd.d
Only in ./libavformat: sierravmd.o
Only in ./libavformat: siff.d
Only in ./libavformat: siff.o
Only in ./libavformat: smacker.d
Only in ./libavformat: smacker.o
Only in ./libavformat: sol.d
Only in ./libavformat: sol.o
Only in ./libavformat: .svn
Only in ./libavformat: swfdec.d
Only in ./libavformat: swfdec.o
Only in ./libavformat: swfenc.d
Only in ./libavformat: swfenc.o
Only in ./libavformat: tcp.d
Only in ./libavformat: tcp.o
Only in ./libavformat: thp.d
Only in ./libavformat: thp.o
Only in ./libavformat: tiertexseq.d
Only in ./libavformat: tiertexseq.o
Only in ./libavformat: tta.d
Only in ./libavformat: tta.o
Only in ./libavformat: txd.d
Only in ./libavformat: txd.o
Only in ./libavformat: udp.d
Only in ./libavformat: udp.o
diff -ruwp ./libavformat/utils.c ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/utils.c
--- ./libavformat/utils.c	2009-02-21 10:47:57.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavformat/utils.c	2009-01-08 09:00:00.000000000 +0100
@@ -294,6 +294,11 @@ int av_get_packet(ByteIOContext *s, AVPa
 
 int av_dup_packet(AVPacket *pkt)
 {
+    /* Netgem */
+    if (!pkt)
+        return AVERROR(ENOMEM);
+    /* End Netgem */
+
     if (pkt->destruct != av_destruct_packet) {
         uint8_t *data;
         /* We duplicate the packet and don't forget to add the padding again. */
@@ -547,9 +552,8 @@ int av_open_input_file(AVFormatContext *
             memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);
             if (url_fseek(pb, 0, SEEK_SET) < 0) {
                 url_fclose(pb);
-                if (url_fopen(&pb, filename, URL_RDONLY) < 0) {
-                    pb = NULL;
-                    err = AVERROR(EIO);
+                pb = NULL;  /* Netgem: reinit for next open */
+                if ((err=url_fopen(&pb, filename, URL_RDONLY)) < 0) { /* Netgem: return errcode */
                     goto fail;
                 }
             }
@@ -580,6 +584,7 @@ int av_open_input_file(AVFormatContext *
     av_freep(&pd->buf);
     if (pb)
         url_fclose(pb);
+    av_free(*ic_ptr); /* Netgem: memory leak if invalid protocol (for example) */
     *ic_ptr = NULL;
     return err;
 
@@ -642,12 +647,17 @@ int av_read_packet(AVFormatContext *s, A
         if(!pktl && st->codec->codec_id!=CODEC_ID_PROBE)
             return ret;
 
-        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);
+        if (!add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end))
+            return AVERROR(ENOMEM); /* Netgem: Memory management */
 
         if(st->codec->codec_id == CODEC_ID_PROBE){
             AVProbeData *pd = &st->probe_data;
+            unsigned char *buf;
 
-            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);
+            buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);
+            if (!buf) /* Netgem: Memory management */
+                return AVERROR(ENOMEM);
+            pd->buf = buf;
             memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);
             pd->buf_size += pkt->size;
             memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);
@@ -675,6 +685,11 @@ static int get_audio_frame_size(AVCodecC
     if(enc->codec_id == CODEC_ID_VORBIS)
         return -1;
 
+    /* Netgem */
+    if(enc->codec_id == CODEC_ID_AAC)
+        return 1024;
+    /* End Netgem */
+
     if (enc->frame_size <= 1) {
         int bits_per_sample = av_get_bits_per_sample(enc->codec_id);
 
@@ -1117,7 +1132,10 @@ int av_read_frame(AVFormatContext *s, AV
 
             if(av_dup_packet(add_to_pktbuf(&s->packet_buffer, pkt,
                                            &s->packet_buffer_end)) < 0)
+            {
+                av_free_packet(pkt); /* Netgem */
                 return AVERROR(ENOMEM);
+            }
         }else{
             assert(!s->packet_buffer);
             return av_read_frame_internal(s, pkt);
@@ -1125,16 +1143,24 @@ int av_read_frame(AVFormatContext *s, AV
     }
 }
 
+static void flush_packet_queue2(AVPacketList **packet_buffer);
+
 /* XXX: suppress the packet queue */
 static void flush_packet_queue(AVFormatContext *s)
 {
+    flush_packet_queue2(&s->packet_buffer);
+    flush_packet_queue2(&s->raw_packet_buffer); /* Netgem: memory leaks */
+}
+
+static void flush_packet_queue2(AVPacketList **packet_buffer)
+{
     AVPacketList *pktl;
 
     for(;;) {
-        pktl = s->packet_buffer;
+        pktl = *packet_buffer;
         if (!pktl)
             break;
-        s->packet_buffer = pktl->next;
+        *packet_buffer = pktl->next;
         av_free_packet(&pktl->pkt);
         av_free(pktl);
     }
@@ -1153,6 +1179,12 @@ int av_find_default_stream_index(AVForma
         return -1;
     for(i = 0; i < s->nb_streams; i++) {
         st = s->streams[i];
+
+        /* Netgem: deleted stream support */
+        if (!st)
+            continue;
+        /* End Netgem */
+
         if (st->codec->codec_type == CODEC_TYPE_VIDEO) {
             return i;
         }
@@ -1201,6 +1233,11 @@ void av_update_cur_dts(AVFormatContext *
     for(i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
 
+        /* Netgem: deleted stream support */
+        if (!st)
+            continue;
+        /* End Netgem */
+
         st->cur_dts = av_rescale(timestamp,
                                  st->time_base.den * (int64_t)ref_st->time_base.num,
                                  st->time_base.num * (int64_t)ref_st->time_base.den);
@@ -1296,7 +1333,7 @@ int av_index_search_timestamp(AVStream *
     return  m;
 }
 
-#define DEBUG_SEEK
+//#define DEBUG_SEEK
 
 int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags){
     AVInputFormat *avif= s->iformat;
@@ -2043,10 +2080,34 @@ int av_find_stream_info(AVFormatContext
 
     count = 0;
     read_size = 0;
+
+    /* Netgem: keepalive support */
+    ret = av_read_play(ic);
+    if (ret == AVERROR(ENOSYS))
+        ret = 0;
+    if (ret < 0) {
+        goto eof_or_error;
+    }
+    /* End Netgem */
+
     for(;;) {
+
+        /* Netgem: interruption */
+        if (url_interrupt_cb()) {
+            ret = AVERROR(EINTR);
+            break;
+        }
+        /* End Netgem */
+
         /* check if one codec still needs to be handled */
         for(i=0;i<ic->nb_streams;i++) {
             st = ic->streams[i];
+
+            /* Netgem: do not check discarded streams */
+            if (st->discard >= AVDISCARD_ALL)
+                continue;
+            /* End Netgem */
+
             if (!has_codec_parameters(st->codec))
                 break;
             /* variable fps and no guess at the real fps */
@@ -2078,6 +2139,7 @@ int av_find_stream_info(AVFormatContext
            (AVFMTCTX_NOHEADER) */
         ret = av_read_frame_internal(ic, &pkt1);
         if (ret < 0) {
+        eof_or_error: /* Netgem */
             /* EOF or error */
             ret = -1; /* we could not have all the codec parameters before EOF */
             for(i=0;i<ic->nb_streams;i++) {
@@ -2093,10 +2155,20 @@ int av_find_stream_info(AVFormatContext
             break;
         }
 
+        /* Netgem: keepalive support */
+        ret = av_read_keepalive(ic);
+        if (ret == AVERROR(ENOSYS))
+            ret = 0;
+        if (ret < 0) {
+            av_free_packet(&pkt1);
+            goto eof_or_error;
+        }
+        /* End Netgem */
+
         pkt= add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
         if(av_dup_packet(pkt) < 0) {
-            av_free(duration_error);
-            return AVERROR(ENOMEM);
+            av_free_packet(&pkt1); /* Netgem: Memory leak */
+            goto eof_or_error; /* Netgem: proper exit  */
         }
 
         read_size += pkt->size;
@@ -2267,6 +2339,17 @@ int av_read_pause(AVFormatContext *s)
     return AVERROR(ENOSYS);
 }
 
+/* Netgem: keepalive support */
+int av_read_keepalive(AVFormatContext *s)
+{
+    if (s->iformat->read_keepalive)
+        return s->iformat->read_keepalive(s);
+    if (s->pb)
+        return av_url_read_fkeepalive(s->pb);
+    return AVERROR(ENOSYS);
+}
+/* End Netgem */
+
 void av_close_input_stream(AVFormatContext *s)
 {
     int i;
@@ -2289,6 +2372,7 @@ void av_close_input_stream(AVFormatConte
         av_free(st->codec);
         av_free(st->filename);
         av_free(st->priv_data);
+        av_free(st->probe_data.buf); /* Netgem: memory leaks */
         av_free(st);
     }
     for(i=s->nb_programs-1; i>=0; i--) {
@@ -2299,6 +2383,7 @@ void av_close_input_stream(AVFormatConte
     }
     av_freep(&s->programs);
     flush_packet_queue(s);
+    av_freep(&s->drm_data); /* Netgem: DRM */
     av_freep(&s->priv_data);
     while(s->nb_chapters--) {
         av_free(s->chapters[s->nb_chapters]->title);
@@ -2321,19 +2406,25 @@ AVStream *av_new_stream(AVFormatContext
     AVStream *st;
     int i;
 
-    if (s->nb_streams >= MAX_STREAMS)
+    /* Netgem: added and deleted streams support */
+    for (i=0;i<MAX_STREAMS;i++){
+        if (s->streams[i]==NULL){
+            break;
+        }
+    }
+    if (i >= MAX_STREAMS)
         return NULL;
 
     st = av_mallocz(sizeof(AVStream));
     if (!st)
         return NULL;
+    st->index = i;
 
     st->codec= avcodec_alloc_context();
     if (s->iformat) {
         /* no default bitrate if decoding */
         st->codec->bit_rate = 0;
     }
-    st->index = s->nb_streams;
     st->id = id;
     st->start_time = AV_NOPTS_VALUE;
     st->duration = AV_NOPTS_VALUE;
@@ -2352,7 +2443,11 @@ AVStream *av_new_stream(AVFormatContext
 
     st->sample_aspect_ratio = (AVRational){0,1};
 
-    s->streams[s->nb_streams++] = st;
+    s->streams[st->index] = st;
+    if (st->index >= s->nb_streams) {
+        s->nb_streams++;
+    }
+
     return st;
 }
 
@@ -2448,6 +2543,11 @@ int av_write_header(AVFormatContext *s)
     for(i=0;i<s->nb_streams;i++) {
         st = s->streams[i];
 
+        /* Netgem: deleted streams support */
+        if (!st)
+            continue;
+        /* End Netgem */
+
         switch (st->codec->codec_type) {
         case CODEC_TYPE_AUDIO:
             if(st->codec->sample_rate<=0){
@@ -2500,9 +2600,20 @@ int av_write_header(AVFormatContext *s)
 
     /* init PTS generation */
     for(i=0;i<s->nb_streams;i++) {
-        int64_t den = AV_NOPTS_VALUE;
         st = s->streams[i];
+        if (!st)
+            continue;
+        ret = av_init_pts_generation(st);
+        if (ret != 0)
+            return ret;
+    }
+    return 0;
+}
 
+/* Netgem */
+int av_init_pts_generation(AVStream *st)
+{
+    int64_t den = AV_NOPTS_VALUE;
         switch (st->codec->codec_type) {
         case CODEC_TYPE_AUDIO:
             den = (int64_t)st->time_base.num * st->codec->sample_rate;
@@ -2518,9 +2629,9 @@ int av_write_header(AVFormatContext *s)
                 return AVERROR_INVALIDDATA;
             av_frac_init(&st->pts, 0, 0, den);
         }
-    }
     return 0;
 }
+/* End Netgem */
 
 //FIXME merge with compute_pkt_fields
 static int compute_pkt_fields2(AVStream *st, AVPacket *pkt){
@@ -2648,7 +2759,8 @@ int av_interleave_packet_per_dts(AVForma
         pktl= pktl->next;
     }
 
-    if(stream_count && (s->nb_streams == stream_count || flush)){
+    if(stream_count && (s->nb_streams == stream_count || flush)
+       && s->packet_buffer){ /* Netgem: deleted stream support */
         pktl= s->packet_buffer;
         *out= pktl->pkt;
 
@@ -2737,6 +2849,7 @@ fail:
     if(ret == 0)
        ret=url_ferror(s->pb);
     for(i=0;i<s->nb_streams;i++)
+        if (s->streams[i])
         av_freep(&s->streams[i]->priv_data);
     av_freep(&s->priv_data);
     return ret;
@@ -2771,7 +2884,10 @@ static void dump_stream_format(AVFormatC
     char buf[256];
     int flags = (is_output ? ic->oformat->flags : ic->iformat->flags);
     AVStream *st = ic->streams[i];
-    int g = ff_gcd(st->time_base.num, st->time_base.den);
+    int g;
+    if (!st)
+        return;
+    g = ff_gcd(st->time_base.num, st->time_base.den);
     avcodec_string(buf, sizeof(buf), st->codec, is_output);
     av_log(NULL, AV_LOG_INFO, "    Stream #%d.%d", index, i);
     /* the pid is an important information, so we display it */
@@ -2781,13 +2897,15 @@ static void dump_stream_format(AVFormatC
     if (strlen(st->language) > 0)
         av_log(NULL, AV_LOG_INFO, "(%s)", st->language);
     av_log(NULL, AV_LOG_DEBUG, ", %d/%d", st->time_base.num/g, st->time_base.den/g);
+    if (st->discard >= AVDISCARD_ALL) /* Netgem */
+        av_log(NULL, AV_LOG_DEBUG, ", discarded"); /* Netgem */
     av_log(NULL, AV_LOG_INFO, ": %s", buf);
     if(st->codec->codec_type == CODEC_TYPE_VIDEO){
         if(st->r_frame_rate.den && st->r_frame_rate.num)
             av_log(NULL, AV_LOG_INFO, ", %5.2f tb(r)", av_q2d(st->r_frame_rate));
-/*      else if(st->time_base.den && st->time_base.num)
-            av_log(NULL, AV_LOG_INFO, ", %5.2f tb(m)", 1/av_q2d(st->time_base));*/
-        else
+       /*  else */ if(st->time_base.den && st->time_base.num)
+            av_log(NULL, AV_LOG_INFO, ", %5.2f tb(m)", 1/av_q2d(st->time_base));
+        /* else */ if(st->codec->time_base.den && st->codec->time_base.num)
             av_log(NULL, AV_LOG_INFO, ", %5.2f tb(c)", 1/av_q2d(st->codec->time_base));
     }
     av_log(NULL, AV_LOG_INFO, "\n");
@@ -3080,7 +3198,7 @@ int av_get_frame_filename(char *buf, int
     return -1;
 }
 
-static void hex_dump_internal(void *avcl, FILE *f, int level, uint8_t *buf, int size)
+static void hex_dump_internal(void *avcl, FILE *f, int level, const uint8_t *buf, int size)
 {
     int len, i, j, c;
 #define PRINT(...) do { if (!f) av_log(avcl, level, __VA_ARGS__); else fprintf(f, __VA_ARGS__); } while(0)
@@ -3108,12 +3226,12 @@ static void hex_dump_internal(void *avcl
 #undef PRINT
 }
 
-void av_hex_dump(FILE *f, uint8_t *buf, int size)
+void av_hex_dump(FILE *f, const uint8_t *buf, int size)
 {
     hex_dump_internal(NULL, f, 0, buf, size);
 }
 
-void av_hex_dump_log(void *avcl, int level, uint8_t *buf, int size)
+void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
 {
     hex_dump_internal(avcl, NULL, level, buf, size);
 }
@@ -3141,7 +3259,7 @@ static void pkt_dump_internal(void *avcl
     PRINT("  size=%d\n", pkt->size);
 #undef PRINT
     if (dump_payload)
-        av_hex_dump(f, pkt->data, pkt->size);
+        hex_dump_internal(avcl, f, level, pkt->data, pkt->size);
 }
 
 void av_pkt_dump(FILE *f, AVPacket *pkt, int dump_payload)
Only in ./libavformat: utils.d
Only in ./libavformat: utils.o
Only in ./libavformat: vc1test.d
Only in ./libavformat: vc1testenc.d
Only in ./libavformat: vc1testenc.o
Only in ./libavformat: vc1test.o
Only in ./libavformat: voc.d
Only in ./libavformat: vocdec.d
Only in ./libavformat: vocdec.o
Only in ./libavformat: vocenc.d
Only in ./libavformat: vocenc.o
Only in ./libavformat: voc.o
Only in ./libavformat: wav.d
Only in ./libavformat: wav.o
Only in ./libavformat: wc3movie.d
Only in ./libavformat: wc3movie.o
Only in ./libavformat: westwood.d
Only in ./libavformat: westwood.o
Only in ./libavformat: wv.d
Only in ./libavformat: wv.o
Only in ./libavformat: xa.d
Only in ./libavformat: xa.o
Only in ./libavformat: yuv4mpeg.d
Only in ./libavformat: yuv4mpeg.o
Only in ./libavutil: adler32.d
Only in ./libavutil: adler32.o
Only in ./libavutil: aes.d
Only in ./libavutil: aes.o
Only in ./libavutil/arm: .svn
Only in ./libavutil: avstring.d
Only in ./libavutil: avstring.o
Only in ./libavutil: avutil.h.orig
Only in ./libavutil: base64.d
Only in ./libavutil: base64.o
Only in ./libavutil/bfin: .svn
diff -ruwp ./libavutil/common.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/common.h
--- ./libavutil/common.h	2009-02-21 10:50:58.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/common.h	2009-01-08 09:00:00.000000000 +0100
@@ -29,9 +29,6 @@
 #include <inttypes.h>
 
 #ifdef HAVE_AV_CONFIG_H
-/* only include the following when compiling package */
-#    include "config.h"
-
 #    include <stdlib.h>
 #    include <stdio.h>
 #    include <string.h>
@@ -39,6 +36,9 @@
 #    include <limits.h>
 #    include <errno.h>
 #    include <math.h>
+
+/* only include the following when compiling package */
+#    include "config.h"
 #endif /* HAVE_AV_CONFIG_H */
 
 #ifndef av_always_inline
@@ -405,4 +405,58 @@ tend= AV_READ_TIME();\
 #   define NULL_IF_CONFIG_SMALL(x) x
 #endif
 
+/* Netgem compatibility layer */
+#ifndef INT64_C
+#  define INT64_C(c)            c ## LL
+#endif
+#ifndef UINT64_C
+#  define UINT64_C(c)           c ## ULL
+#endif
+#ifndef PRId64
+#  define PRId64 "lld"
+#endif
+#ifndef PRIx64
+#  define PRIx64 "llx"
+#endif
+#ifndef PRIX64
+#  define PRIX64 "llX"
+#endif
+#ifndef PRIu64
+#  define PRIu64 "llu"
+#endif
+#ifndef PRIdFAST16
+#  define PRIdFAST16 "d"
+#endif
+#ifndef PRIdFAST32
+#  define PRIdFAST32 "d"
+#endif
+/* end Netgem */
+
+/* Netgem kludge for nthreads support */
+#if defined(CONFIG_NTHREADS)
+#include <sys/time.h>
+#include <unistd.h>
+#include <fcntl.h>
+int nthread_select(int nb_fd, fd_set *readfds, fd_set *writefds,
+		   fd_set *exceptfds, struct timeval *tv);
+void nthread_sleep(int64_t _time);
+#define open(filename, flags...) nthread_open(filename, ##flags)
+#define close(fd) nthread_close(fd)
+#define read(fd, buf, n) nthread_read(fd, buf, n)
+#define write(fd, buf, n) nthread_write(fd, buf, n)
+#define select(n,rfds,wfds,efds,tv) nthread_select(n,rfds,wfds,efds,tv)
+#define socket(af,type,proto) nthread_socket(af,type,proto)
+#define recv(fd,buf,len,flags) nthread_recv(fd,buf,len,flags)
+#define recvfrom(fd,buf,len,flags,from,fromlen) nthread_recvfrom(fd,buf,len,flags,from,fromlen)
+#define send(fd,buf,len,flags) nthread_send(fd,buf,len,flags)
+#define sendto(fd,buf,len,flags,to,tolen) nthread_sendto(fd,buf,len,flags,to,tolen)
+#define connect(fd, addr, len) nthread_connect(fd, addr, len)
+#define accept(fd, addr, len) nthread_accept(fd, addr, len)
+#define fcntl(fd, cmd...) nthread_fcntl(fd, ##cmd)
+#define nanosleep(req, rem) nthread_sleep(((int64_t)(req)->tv_sec*1000)+((int64_t)(req)->tv_nsec/(1000*1000)))
+#define sleep(sec) nthread_sleep((sec)*1000)
+#define usleep(usec) nthread_sleep((usec)/1000)
+#endif
+/* End Netgem kludge */
+
 #endif /* AVUTIL_COMMON_H */
Only in ./libavutil: crc.d
Only in ./libavutil: crc.o
Only in ./libavutil: des.d
Only in ./libavutil: des.o
Only in ./libavutil: fifo.d
Only in ./libavutil: fifo.o
diff -ruwp ./libavutil/internal.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/internal.h
--- ./libavutil/internal.h	2009-02-21 10:50:58.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/internal.h	2009-01-08 09:00:00.000000000 +0100
@@ -117,7 +117,7 @@
 #ifdef DEBUG
 #    define dprintf(pctx, ...) av_log(pctx, AV_LOG_DEBUG, __VA_ARGS__)
 #else
-#    define dprintf(pctx, ...)
+#    define dprintf(pctx, ...) do {} while (0)
 #endif
 
 #define av_abort()      do { av_log(NULL, AV_LOG_ERROR, "Abort at %s:%d\n", __FILE__, __LINE__); abort(); } while (0)
Only in ./libavutil: intfloat_readwrite.d
Only in ./libavutil: intfloat_readwrite.o
Only in ./libavutil: lfg.d
Only in ./libavutil: lfg.o
Only in ./libavutil: libavutil.a
Only in ./libavutil: libavutil.pc
Only in ./libavutil: libavutil-uninstalled.pc
Only in ./libavutil: lls.d
Only in ./libavutil: lls.o
Only in ./libavutil: log.d
Only in ./libavutil: log.o
Only in ./libavutil: lzo.d
Only in ./libavutil: lzo.o
Only in ./libavutil: Makefile
Only in ./libavutil: mathematics.d
Only in ./libavutil: mathematics.o
Only in ./libavutil: md5.d
Only in ./libavutil: md5.o
Only in ./libavutil: mem.d
Only in ./libavutil: mem.o
Only in ./libavutil: random.d
Only in ./libavutil: random.o
Only in ./libavutil: rational.d
Only in ./libavutil: rational.o
Only in ./libavutil: rc4.d
Only in ./libavutil: rc4.o
Only in ./libavutil/sh4: .svn
Only in ./libavutil: sha1.d
Only in ./libavutil: sha1.o
Only in ./libavutil: .svn
Only in ./libavutil: svn-commit.tmp
Only in ./libavutil: tree.d
Only in ./libavutil: tree.o
Only in ./libavutil: utils.d
Only in ./libavutil: utils.o
diff -ruwp ./libavutil/x86/bswap.h ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/x86/bswap.h
--- ./libavutil/x86/bswap.h	2009-02-21 10:46:35.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//libavutil/x86/bswap.h	2009-01-08 09:00:00.000000000 +0100
@@ -25,7 +25,7 @@
 #define AVUTIL_X86_BSWAP_H
 
 #include <stdint.h>
-#include "config.h"
+#include "libavutil/config.h"
 #include "libavutil/common.h"
 
 #define bswap_16 bswap_16
Only in ./libavutil/x86: .svn
Only in ./libpostproc: Makefile
Only in ./libpostproc: .svn
Only in ./libswscale: libswscale.a
Only in ./libswscale: libswscale.pc
Only in ./libswscale: libswscale-uninstalled.pc
Only in ./libswscale: Makefile
Only in ./libswscale: rgb2rgb.d
Only in ./libswscale: rgb2rgb.o
Only in ./libswscale: stcdtUuv
Only in ./libswscale: .svn
Only in ./libswscale: swscale_avoption.d
Only in ./libswscale: swscale_avoption.o
Only in ./libswscale: swscale.d
Only in ./libswscale: swscale.o
Only in ./libswscale: swscale_template.c.orig
Only in ./libswscale: swscale_template.c.rej
Only in ./libswscale: yuv2rgb.d
Only in ./libswscale: yuv2rgb.o
Only in .: MAINTAINERS.orig
Only in .: Makefile
Only in .: patchaac
Only in .: patchavcconsumed
Only in .: patchavio
Only in .: patchavuninit
Only in .: patcherrorresilience
Only in .: patchextlib
Only in .: patchffserver
Only in .: patchgccversion
Only in .: patchgetpixelformat
Only in .: patchh264parser
Only in .: patchh264sse2icc
Only in .: patchhwaccel
Only in .: patchiccwarnings
Only in .: patchiccwarnings2
Only in .: patchipmovie
Only in .: patchmpeg12factor
Only in .: patchnetgem
Only in .: patchogm
Only in .: patchparallel
Only in .: patchqcelp
Only in .: patchrefdistflag
Only in .: patchriff
Only in .: patchsh
Only in .: patchtests
Only in .: patchvdpaubuffers
Only in .: patchvdpauceh1
Only in .: patchvdpauconfigure
Only in .: patchvdpauerframeend
Only in .: patchvdpauffreference
Only in .: patchvdpauffvdpau
Only in .: patchvdpauh264
Only in .: patchvdpauMakefile
Only in .: patchvdpaumpeg
Only in .: patchvdpaumpeg1
Only in .: patchvdpausetbuffers
Only in .: patchvdpauswscale
Only in .: patchvdpauunderscore
Only in .: patchvdpauvc1
Only in .: patchvdpauvc1map
Only in .: stack
Only in .: stream.dump
diff -ruwp ./subdir.mak ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//subdir.mak
--- ./subdir.mak	2009-02-21 10:51:00.000000000 +0100
+++ ../utils-netgem-netboxHD-5.1.08/libs/ffmpeg//subdir.mak	2009-01-08 09:00:00.000000000 +0100
@@ -37,7 +37,9 @@ $(SUBDIR)$(SLIBNAME_WITH_MAJOR): $(DEP_L
 endif
 endif
 
-install-lib$(NAME)-shared: $(SUBDIR)$(SLIBNAME)
+install-lib$(NAME)-shared: $(SHLIBDIR)/$(SLIBNAME_WITH_VERSION)
+
+$(SHLIBDIR)/$(SLIBNAME_WITH_VERSION): $(SUBDIR)$(SLIBNAME)
 	install -d "$(SHLIBDIR)"
 	install -m 755 $(SUBDIR)$(SLIBNAME) "$(SHLIBDIR)/$(SLIBNAME_WITH_VERSION)"
 	$(STRIP) "$(SHLIBDIR)/$(SLIBNAME_WITH_VERSION)"
@@ -47,16 +49,19 @@ install-lib$(NAME)-shared: $(SUBDIR)$(SL
 		$(LN_S) $(SLIBNAME_WITH_VERSION) $(SLIBNAME)
 	$(SLIB_INSTALL_EXTRA_CMD)
 
-install-lib$(NAME)-static: $(SUBDIR)$(LIBNAME)
+install-lib$(NAME)-static: $(LIBDIR)/$(LIBNAME)
+
+$(LIBDIR)/$(LIBNAME): $(SUBDIR)$(LIBNAME)
 	install -d "$(LIBDIR)"
 	install -m 644 $(SUBDIR)$(LIBNAME) "$(LIBDIR)"
 	$(LIB_INSTALL_EXTRA_CMD)
 
 install-headers::
 	install -d "$(INCINSTDIR)"
-	install -d "$(LIBDIR)/pkgconfig"
-	install -m 644 $(addprefix "$(SRC_DIR)"/,$(HEADERS)) "$(INCINSTDIR)"
-	install -m 644 $(BUILD_ROOT)/lib$(NAME)/lib$(NAME).pc "$(LIBDIR)/pkgconfig"
+#	install -d "$(LIBDIR)/pkgconfig"
+#	install -m 644 $(addprefix "$(SRC_DIR)"/,$(HEADERS)) "$(INCINSTDIR)"
+#	install -m 644 $(BUILD_ROOT)/lib$(NAME)/lib$(NAME).pc "$(LIBDIR)/pkgconfig"
+	ln -sf $(addprefix $(SRC_DIR)/,$(HEADERS)) "$(INCINSTDIR)"
 
 uninstall-libs::
 	-rm -f "$(SHLIBDIR)/$(SLIBNAME_WITH_MAJOR)" \
@@ -66,8 +71,8 @@ uninstall-libs::
 	-rm -f "$(LIBDIR)/$(LIBNAME)"
 
 uninstall-headers::
-	rm -f $(addprefix "$(INCINSTDIR)/",$(HEADERS))
-	rm -f "$(LIBDIR)/pkgconfig/lib$(NAME).pc"
+	-rm -f $(addprefix "$(INCINSTDIR)/",$(HEADERS))
+	-rm -f "$(LIBDIR)/pkgconfig/lib$(NAME).pc"
 	-rmdir "$(INCDIR)"
 endef
 
Only in .: .svn
Only in .: svn-commit.2.tmp
Only in .: svn-commit.3.tmp
Only in .: svn-commit.4.tmp
Only in .: svn-commit.5.tmp
Only in .: svn-commit.6.tmp
Only in .: svn-commit.7.tmp
Only in .: svn-commit.tmp
Only in .: test.avi
Only in .: test.jpg
Only in .: test.raw
Only in ./tests: asynth1.sw
Only in ./tests: audiogen
Only in ./tests: data
Only in ./tests: rotozoom
Only in ./tests: seek_test
Only in ./tests: .svn
Only in ./tests: tiny_psnr
Only in ./tests: videogen
Only in ./tests: vsynth1
Only in ./tests: vsynth2
Only in .: time
Only in ./tools: .svn
Only in .: version.h
Only in ./vhook: drawtext.d
Only in ./vhook: drawtext.o
Only in ./vhook: drawtext.so
Only in ./vhook: fish.d
Only in ./vhook: fish.o
Only in ./vhook: fish.so
Only in ./vhook: null.d
Only in ./vhook: null.o
Only in ./vhook: null.so
Only in ./vhook: ppm.d
Only in ./vhook: ppm.o
Only in ./vhook: ppm.so
Only in ./vhook: .svn
Only in ./vhook: watermark.d
Only in ./vhook: watermark.o
Only in ./vhook: watermark.so
